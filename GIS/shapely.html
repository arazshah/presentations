<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹ Shapely - ØªØ­Ù„ÛŒÙ„ Ù‡Ù†Ø¯Ø³ÛŒ Ø¯Ø± Ù¾Ø§ÛŒØªÙˆÙ†</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <!-- Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    
    <style>
        :root {
            --primary: #3B82F6;
            --primary-dark: #2563EB;
            --primary-light: #60A5FA;
            --secondary: #8B5CF6;
            --accent: #F59E0B;
            --bg-dark: #0F172A;
            --bg-card: #1E293B;
            --bg-code: #0D1117;
            --text-primary: #F1F5F9;
            --text-secondary: #94A3B8;
            --text-muted: #64748B;
            --border: #334155;
            --success: #22C55E;
            --warning: #F59E0B;
            --error: #EF4444;
            --info: #06B6D4;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Vazirmatn', system-ui, -apple-system, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.8;
            overflow-x: hidden;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-light);
        }

        /* Navigation */
        .nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 2rem;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            text-decoration: none;
        }

        .logo-icon {
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .logo-text {
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .nav-links {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-link:hover,
        .nav-link.active {
            color: var(--primary);
            background: rgba(59, 130, 246, 0.1);
        }

        /* Hero Section */
        .hero {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8rem 2rem 4rem;
            position: relative;
            overflow: hidden;
        }

        .hero-bg {
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(59, 130, 246, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 50%, rgba(139, 92, 246, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 50% 80%, rgba(245, 158, 11, 0.1) 0%, transparent 50%);
        }

        /* Animated shapes */
        .hero-shapes {
            position: absolute;
            inset: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .shape {
            position: absolute;
            opacity: 0.1;
            animation: float 20s infinite ease-in-out;
        }

        .shape-1 {
            top: 10%;
            left: 10%;
            width: 100px;
            height: 100px;
            border: 3px solid var(--primary);
            border-radius: 50%;
            animation-delay: 0s;
        }

        .shape-2 {
            top: 60%;
            right: 15%;
            width: 80px;
            height: 80px;
            border: 3px solid var(--secondary);
            transform: rotate(45deg);
            animation-delay: -5s;
        }

        .shape-3 {
            bottom: 20%;
            left: 20%;
            width: 0;
            height: 0;
            border-left: 40px solid transparent;
            border-right: 40px solid transparent;
            border-bottom: 70px solid var(--accent);
            opacity: 0.05;
            animation-delay: -10s;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-20px) rotate(5deg); }
            50% { transform: translateY(0) rotate(0deg); }
            75% { transform: translateY(20px) rotate(-5deg); }
        }

        .hero-content {
            position: relative;
            text-align: center;
            max-width: 900px;
        }

        .hero-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            padding: 0.5rem 1.25rem;
            border-radius: 50px;
            font-size: 0.9rem;
            color: var(--primary);
            margin-bottom: 2rem;
        }

        .hero-title {
            font-size: clamp(2.5rem, 6vw, 4.5rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 1.5rem;
        }

        .hero-title .highlight {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero-subtitle {
            font-size: 1.25rem;
            color: var(--text-secondary);
            margin-bottom: 2.5rem;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .hero-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 1rem 2rem;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            cursor: pointer;
            border: none;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--primary);
            background: rgba(59, 130, 246, 0.1);
        }

        /* Features Grid */
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 4rem;
        }

        .feature-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .feature-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.1);
        }

        .feature-icon {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
            margin: 0 auto 1rem;
        }

        .feature-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .feature-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Section */
        .section {
            margin-bottom: 4rem;
            scroll-margin-top: 100px;
        }

        .section-header {
            display: flex;
            align-items: flex-start;
            gap: 1.5rem;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
        }

        .section-icon {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            flex-shrink: 0;
        }

        .section-number {
            font-size: 0.9rem;
            color: var(--primary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 0.25rem;
        }

        .section-title {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
        }

        .section-subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Headings */
        h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 2.5rem 0 1.5rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        h4 {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 2rem 0 1rem;
            color: var(--primary-light);
        }

        p {
            margin-bottom: 1rem;
            color: var(--text-secondary);
        }

        /* Code Block */
        .code-block {
            background: var(--bg-code);
            border-radius: 16px;
            overflow: hidden;
            margin: 1.5rem 0;
            border: 1px solid var(--border);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid var(--border);
        }

        .code-lang {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .code-lang-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
        }

        .code-lang-icon.python {
            background: #3776AB;
            color: #FFD43B;
        }

        .code-lang-icon.bash {
            background: #4EAA25;
            color: white;
        }

        .code-lang-icon.json {
            background: #292929;
            color: #F7DF1E;
        }

        .code-actions {
            display: flex;
            gap: 0.5rem;
        }

        .code-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.3s ease;
        }

        .code-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .code-btn.copied {
            border-color: var(--success);
            color: var(--success);
        }

        .code-body {
            direction: ltr;
            padding: 1.25rem;
            overflow-x: auto;
        }

        .code-body pre {
            margin: 0;
        }

        .code-body code {
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.7;
        }

        /* Info Box */
        .info-box {
            display: flex;
            gap: 1rem;
            padding: 1.25rem;
            border-radius: 12px;
            margin: 1.5rem 0;
            border: 1px solid;
        }

        .info-box.tip {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
        }

        .info-box.warning {
            background: rgba(245, 158, 11, 0.1);
            border-color: rgba(245, 158, 11, 0.3);
        }

        .info-box.info {
            background: rgba(6, 182, 212, 0.1);
            border-color: rgba(6, 182, 212, 0.3);
        }

        .info-box.danger {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
        }

        .info-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .info-content h4 {
            margin: 0 0 0.5rem 0;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .info-content p {
            margin: 0;
            font-size: 0.95rem;
        }

        .info-content ul {
            margin: 0.5rem 0 0 1.5rem;
            color: var(--text-secondary);
        }

        .info-content li {
            margin-bottom: 0.25rem;
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            margin: 1.5rem 0;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        th, td {
            padding: 1rem;
            text-align: right;
            border-bottom: 1px solid var(--border);
        }

        th {
            background: var(--bg-card);
            font-weight: 600;
            color: var(--primary);
        }

        tr:hover {
            background: rgba(59, 130, 246, 0.05);
        }

        /* Function Cards Grid */
        .function-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .function-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            transition: all 0.3s ease;
        }

        .function-card:hover {
            border-color: var(--primary);
            transform: translateY(-3px);
        }

        .function-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .function-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }

        .function-syntax {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            background: var(--bg-code);
            padding: 0.5rem;
            border-radius: 6px;
            color: var(--text-muted);
        }

        /* Geometry Visual */
        .geometry-visual {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .geometry-item {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .geometry-item:hover {
            border-color: var(--primary);
            transform: translateY(-3px);
        }

        .geometry-icon {
            font-size: 3rem;
            margin-bottom: 0.75rem;
        }

        .geometry-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .geometry-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* Footer */
        .footer {
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            padding: 3rem 2rem;
            text-align: center;
            margin-top: 4rem;
        }

        .footer-content {
            max-width: 600px;
            margin: 0 auto;
        }

        .footer-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 1.5rem 0;
            flex-wrap: wrap;
        }

        .footer-links a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .footer-links a:hover {
            color: var(--primary);
        }

        .copyright {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }

            .hero {
                padding: 6rem 1rem 3rem;
            }

            .hero-title {
                font-size: 2rem;
            }

            .section-header {
                flex-direction: column;
                text-align: center;
            }

            .section-icon {
                margin: 0 auto;
            }

            h3 {
                font-size: 1.25rem;
            }
        }

        /* Inline Code */
        code:not([class*="language-"]) {
            background: rgba(59, 130, 246, 0.1);
            color: var(--primary);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
        }

        /* Links */
        a {
            color: var(--primary);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Lists */
        ul, ol {
            margin: 1rem 0 1rem 2rem;
            color: var(--text-secondary);
        }

        li {
            margin-bottom: 0.5rem;
        }

        /* Resources Grid */
        .resources-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .resource-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .resource-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary);
        }

        .resource-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .resource-card h4 {
            margin: 0 0 0.5rem 0;
            color: var(--text-primary);
        }

        .resource-card p {
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .resource-card a {
            display: inline-block;
            padding: 0.5rem 1rem;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            font-size: 0.9rem;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .resource-card a:hover {
            background: var(--primary-dark);
            text-decoration: none;
        }

        /* Comparison */
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .comparison-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            text-align: center;
        }

        .comparison-card h5 {
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: var(--primary);
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-container">
            <a href="#" class="nav-logo">
                <div class="logo-icon">ğŸ“</div>
                <span class="logo-text">Shapely</span>
            </a>
            <div class="nav-links">
                <a href="#intro" class="nav-link">Ù…Ø¹Ø±ÙÛŒ</a>
                <a href="#installation" class="nav-link">Ù†ØµØ¨</a>
                <a href="#geometries" class="nav-link">Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§</a>
                <a href="#properties" class="nav-link">ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§</a>
                <a href="#predicates" class="nav-link">Ø±ÙˆØ§Ø¨Ø·</a>
                <a href="#operations" class="nav-link">Ø¹Ù…Ù„ÛŒØ§Øª</a>
                <a href="#analysis" class="nav-link">ØªØ­Ù„ÛŒÙ„</a>
                <a href="#io" class="nav-link">ÙˆØ±ÙˆØ¯ÛŒ/Ø®Ø±ÙˆØ¬ÛŒ</a>
                <a href="#advanced" class="nav-link">Ù¾ÛŒØ´Ø±ÙØªÙ‡</a>
                <a href="#projects" class="nav-link">Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§</a>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <header class="hero">
        <div class="hero-bg"></div>
        <div class="hero-shapes">
            <div class="shape shape-1"></div>
            <div class="shape shape-2"></div>
            <div class="shape shape-3"></div>
        </div>
        <div class="hero-content">
            <div class="hero-badge">
                <span>ğŸ</span>
                <span>Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Ù¾Ø§ÛŒØªÙˆÙ† Ø¨Ø±Ø§ÛŒ ØªØ­Ù„ÛŒÙ„ Ù‡Ù†Ø¯Ø³ÛŒ</span>
            </div>
            <h1 class="hero-title">
                Ø¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹
                <span class="highlight">Shapely</span>
            </h1>
            <p class="hero-subtitle">
                Ù‚Ø¯Ø±ØªÙ…Ù†Ø¯ØªØ±ÛŒÙ† Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Ù¾Ø§ÛŒØªÙˆÙ† Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªÚ©Ø§Ø±ÛŒ Ùˆ ØªØ­Ù„ÛŒÙ„ Ø§Ø´Ú©Ø§Ù„ Ù‡Ù†Ø¯Ø³ÛŒ.
                Ø§Ø² Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù‚Ø·Ù‡ ØªØ§ Ø¹Ù…Ù„ÛŒØ§Øª Ù¾ÛŒÚ†ÛŒØ¯Ù‡ Ù…Ú©Ø§Ù†ÛŒØŒ Ù‡Ù…Ù‡ Ú†ÛŒØ² Ø¨Ø§ Shapely!
            </p>
            <div class="hero-buttons">
                <a href="#intro" class="btn btn-primary">
                    <span>ğŸ“–</span>
                    Ø´Ø±ÙˆØ¹ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ
                </a>
                <a href="https://shapely.readthedocs.io" target="_blank" class="btn btn-secondary">
                    <span>ğŸ”—</span>
                    Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø±Ø³Ù…ÛŒ
                </a>
            </div>

            <!-- Features Grid -->
            <div class="features-grid">
                <div class="feature-card">
                    <div class="feature-icon">ğŸ“</div>
                    <div class="feature-title">Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ØªÙ†ÙˆØ¹</div>
                    <div class="feature-desc">PointØŒ LineØŒ Polygon Ùˆ Ø§Ù†ÙˆØ§Ø¹ Multi</div>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">ğŸ”„</div>
                    <div class="feature-title">Ø¹Ù…Ù„ÛŒØ§Øª Ù…Ú©Ø§Ù†ÛŒ</div>
                    <div class="feature-desc">BufferØŒ UnionØŒ Intersection Ùˆ...</div>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">ğŸ”</div>
                    <div class="feature-title">Ø±ÙˆØ§Ø¨Ø· ØªÙˆÙ¾ÙˆÙ„ÙˆÚ˜ÛŒÚ©</div>
                    <div class="feature-desc">ContainsØŒ WithinØŒ Intersects Ùˆ...</div>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">âš¡</div>
                    <div class="feature-title">Ø³Ø±ÛŒØ¹ Ùˆ Ø¨Ù‡ÛŒÙ†Ù‡</div>
                    <div class="feature-desc">Ù…Ø¨ØªÙ†ÛŒ Ø¨Ø± GEOS Ø¨Ø§ Ú©Ø§Ø±Ø§ÛŒÛŒ Ø¨Ø§Ù„Ø§</div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main>
        <!-- Section 1: Introduction -->
        <section class="section" id="intro">
            <div class="section-header">
                <div class="section-icon">ğŸ“</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ø§ÙˆÙ„</div>
                    <h2 class="section-title">Ù…Ø¹Ø±ÙÛŒ Shapely</h2>
                    <p class="section-subtitle">Ø¢Ø´Ù†Ø§ÛŒÛŒ Ø¨Ø§ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ ØªØ­Ù„ÛŒÙ„ Ù‡Ù†Ø¯Ø³ÛŒ Ù¾Ø§ÛŒØªÙˆÙ†</p>
                </div>
            </div>

            <h3>ğŸ¯ Shapely Ú†ÛŒØ³ØªØŸ</h3>
            <p>
                <strong>Shapely</strong> ÛŒÚ© Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Ù¾Ø§ÛŒØªÙˆÙ† Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªÚ©Ø§Ø±ÛŒ Ùˆ ØªØ­Ù„ÛŒÙ„ Ø§Ø´Ú©Ø§Ù„ Ù‡Ù†Ø¯Ø³ÛŒ Ù…Ø³Ø·Ø­ Ø§Ø³Øª.
                Ø§ÛŒÙ† Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Ø¨Ø± Ù¾Ø§ÛŒÙ‡ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ <strong>GEOS</strong> (Geometry Engine - Open Source) Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡
                Ùˆ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ <strong>OGC Simple Features</strong> Ø±Ø§ Ø§Ø±Ø§Ø¦Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.
            </p>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">GEOS</div>
                    <div class="stat-label">Ù…ÙˆØªÙˆØ± Ù‡Ù†Ø¯Ø³ÛŒ</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">OGC</div>
                    <div class="stat-label">Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">2D</div>
                    <div class="stat-label">Ù‡Ù†Ø¯Ø³Ù‡ Ù…Ø³Ø·Ø­</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">BSD</div>
                    <div class="stat-label">Ù„Ø§ÛŒØ³Ù†Ø³ Ø¢Ø²Ø§Ø¯</div>
                </div>
            </div>

            <h3>âœ¨ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ù„ÛŒØ¯ÛŒ</h3>
            <ul>
                <li><strong>Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ù†Ø¯Ø³Ù‡:</strong> Ø³Ø§Ø®Øª PointØŒ LineStringØŒ Polygon Ùˆ Ø§Ù†ÙˆØ§Ø¹ Multi</li>
                <li><strong>Ø¹Ù…Ù„ÛŒØ§Øª Ù…Ø¬Ù…ÙˆØ¹Ù‡â€ŒØ§ÛŒ:</strong> UnionØŒ IntersectionØŒ DifferenceØŒ Symmetric Difference</li>
                <li><strong>Ø±ÙˆØ§Ø¨Ø· ØªÙˆÙ¾ÙˆÙ„ÙˆÚ˜ÛŒÚ©:</strong> ContainsØŒ WithinØŒ IntersectsØŒ TouchesØŒ Crosses</li>
                <li><strong>ØªØ­Ù„ÛŒÙ„ Ù‡Ù†Ø¯Ø³ÛŒ:</strong> BufferØŒ Convex HullØŒ SimplifyØŒ Centroid</li>
                <li><strong>Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ:</strong> AreaØŒ LengthØŒ DistanceØŒ Bounds</li>
                <li><strong>ØªØ¨Ø¯ÛŒÙ„ ÙØ±Ù…Øª:</strong> WKTØŒ WKBØŒ GeoJSON</li>
            </ul>

            <h3>ğŸ”· Ø§Ù†ÙˆØ§Ø¹ Ù‡Ù†Ø¯Ø³Ù‡</h3>
            <div class="geometry-visual">
                <div class="geometry-item">
                    <div class="geometry-icon">ğŸ“</div>
                    <div class="geometry-name">Point</div>
                    <div class="geometry-desc">Ù†Ù‚Ø·Ù‡</div>
                </div>
                <div class="geometry-item">
                    <div class="geometry-icon">ğŸ“ğŸ“</div>
                    <div class="geometry-name">MultiPoint</div>
                    <div class="geometry-desc">Ú†Ù†Ø¯ Ù†Ù‚Ø·Ù‡</div>
                </div>
                <div class="geometry-item">
                    <div class="geometry-icon">ğŸ“</div>
                    <div class="geometry-name">LineString</div>
                    <div class="geometry-desc">Ø®Ø·</div>
                </div>
                <div class="geometry-item">
                    <div class="geometry-icon">ğŸ“ğŸ“</div>
                    <div class="geometry-name">MultiLineString</div>
                    <div class="geometry-desc">Ú†Ù†Ø¯ Ø®Ø·</div>
                </div>
                <div class="geometry-item">
                    <div class="geometry-icon">ğŸ”·</div>
                    <div class="geometry-name">Polygon</div>
                    <div class="geometry-desc">Ú†Ù†Ø¯Ø¶Ù„Ø¹ÛŒ</div>
                </div>
                <div class="geometry-item">
                    <div class="geometry-icon">ğŸ”·ğŸ”·</div>
                    <div class="geometry-name">MultiPolygon</div>
                    <div class="geometry-desc">Ú†Ù†Ø¯ Ú†Ù†Ø¯Ø¶Ù„Ø¹ÛŒ</div>
                </div>
                <div class="geometry-item">
                    <div class="geometry-icon">ğŸ’</div>
                    <div class="geometry-name">LinearRing</div>
                    <div class="geometry-desc">Ø­Ù„Ù‚Ù‡ Ø¨Ø³ØªÙ‡</div>
                </div>
                <div class="geometry-item">
                    <div class="geometry-icon">ğŸ“¦</div>
                    <div class="geometry-name">GeometryCollection</div>
                    <div class="geometry-desc">Ù…Ø¬Ù…ÙˆØ¹Ù‡</div>
                </div>
            </div>

            <h3>ğŸ†š Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø´Ø§Ø¨Ù‡</h3>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>ÙˆÛŒÚ˜Ú¯ÛŒ</th>
                            <th>Shapely</th>
                            <th>GeoPandas</th>
                            <th>PostGIS</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Ø²Ø¨Ø§Ù†</td>
                            <td>Python</td>
                            <td>Python</td>
                            <td>SQL</td>
                        </tr>
                        <tr>
                            <td>Ø³Ø·Ø­</td>
                            <td>Ù‡Ù†Ø¯Ø³Ù‡ Ù¾Ø§ÛŒÙ‡</td>
                            <td>DataFrame</td>
                            <td>Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡</td>
                        </tr>
                        <tr>
                            <td>Attributes</td>
                            <td>âŒ</td>
                            <td>âœ…</td>
                            <td>âœ…</td>
                        </tr>
                        <tr>
                            <td>CRS</td>
                            <td>âŒ</td>
                            <td>âœ…</td>
                            <td>âœ…</td>
                        </tr>
                        <tr>
                            <td>Ø³Ø±Ø¹Øª</td>
                            <td>Ø¨Ø§Ù„Ø§</td>
                            <td>Ù…ØªÙˆØ³Ø·</td>
                            <td>Ø¨Ø§Ù„Ø§</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="info-box info">
                <div class="info-icon">ğŸ’¡</div>
                <div class="info-content">
                    <h4>Ù†Ú©ØªÙ‡ Ù…Ù‡Ù…</h4>
                    <p>
                        Shapely ÙÙ‚Ø· Ø¨Ø§ Ù‡Ù†Ø¯Ø³Ù‡ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ø³ÛŒØ³ØªÙ… Ù…Ø®ØªØµØ§Øª (CRS) ÛŒØ§ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ ØªÙˆØµÛŒÙÛŒ Ù†Ø¯Ø§Ø±Ø¯.
                        Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø± Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ú©Ø§Ù…Ù„ Ø§Ø² <strong>GeoPandas</strong> Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯ Ú©Ù‡
                        Ø§Ø² Shapely Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù…ÙˆØªÙˆØ± Ù‡Ù†Ø¯Ø³ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
                    </p>
                </div>
            </div>
        </section>

        <!-- Section 2: Installation -->
        <section class="section" id="installation">
            <div class="section-header">
                <div class="section-icon">âš™ï¸</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ø¯ÙˆÙ…</div>
                    <h2 class="section-title">Ù†ØµØ¨ Ùˆ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ</h2>
                    <p class="section-subtitle">Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ù†ØµØ¨ Shapely</p>
                </div>
            </div>

            <h3>ğŸ“¦ Ù†ØµØ¨ Ø¨Ø§ pip</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon bash">$</div>
                        <span>Terminal</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-bash"># Ù†ØµØ¨ Ø³Ø§Ø¯Ù‡
pip install shapely

# Ù†ØµØ¨ Ø¨Ø§ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ø®ØªÛŒØ§Ø±ÛŒ
pip install shapely[vectorized]

# Ù†ØµØ¨ Ù†Ø³Ø®Ù‡ Ø®Ø§Øµ
pip install shapely==2.0.0

# Ø§Ø±ØªÙ‚Ø§ Ø¨Ù‡ Ø¢Ø®Ø±ÛŒÙ† Ù†Ø³Ø®Ù‡
pip install --upgrade shapely</code></pre>
                </div>
            </div>

            <h3>ğŸ Ù†ØµØ¨ Ø¨Ø§ Conda</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon bash">$</div>
                        <span>Terminal</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-bash"># Ø§Ø² Ú©Ø§Ù†Ø§Ù„ conda-forge (ØªÙˆØµÛŒÙ‡ Ø´Ø¯Ù‡)
conda install -c conda-forge shapely

# Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ÛŒØ· Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Shapely
conda create -n geo python=3.11 shapely geopandas
conda activate geo</code></pre>
                </div>
            </div>

            <h3>âœ… Ø¨Ø±Ø±Ø³ÛŒ Ù†ØµØ¨</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>check_install.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">import shapely
from shapely import geos_version, __version__

print(f"Shapely version: {__version__}")
print(f"GEOS version: {'.'.join(map(str, geos_version))}")

# ØªØ³Øª Ø³Ø§Ø¯Ù‡
from shapely import Point
point = Point(0, 0)
print(f"Point created: {point}")
print(f"Point WKT: {point.wkt}")

# Ø®Ø±ÙˆØ¬ÛŒ:
# Shapely version: 2.0.2
# GEOS version: 3.11.1
# Point created: POINT (0 0)
# Point WKT: POINT (0 0)</code></pre>
                </div>
            </div>

            <h3>ğŸ“š Import Ù‡Ø§ÛŒ Ø±Ø§ÛŒØ¬</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>imports.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python"># â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Import Ù‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø±ÙˆØ´ Û±: Import Ù…Ø³ØªÙ‚ÛŒÙ… Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ (Shapely 2.0+)
from shapely import Point, LineString, Polygon
from shapely import MultiPoint, MultiLineString, MultiPolygon
from shapely import LinearRing, GeometryCollection

# Ø±ÙˆØ´ Û²: Import Ø§Ø² geometry (Ø³Ø§Ø²Ú¯Ø§Ø± Ø¨Ø§ Ù†Ø³Ø®Ù‡â€ŒÙ‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ)
from shapely.geometry import Point, LineString, Polygon
from shapely.geometry import MultiPoint, MultiLineString, MultiPolygon
from shapely.geometry import LinearRing, GeometryCollection, box

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Import Ù‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§ØªÛŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely.ops import (
    unary_union,          # Ø§Ø¬ØªÙ…Ø§Ø¹ Ú†Ù†Ø¯ Ù‡Ù†Ø¯Ø³Ù‡
    cascaded_union,       # Ø§Ø¬ØªÙ…Ø§Ø¹ Ø¢Ø¨Ø´Ø§Ø±ÛŒ (Ù‚Ø¯ÛŒÙ…ÛŒ)
    linemerge,            # Ø§Ø¯ØºØ§Ù… Ø®Ø·ÙˆØ·
    polygonize,           # ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ polygon
    split,                # ØªÙ‚Ø³ÛŒÙ… Ù‡Ù†Ø¯Ø³Ù‡
    snap,                 # Ú†Ø³Ø¨Ø§Ù†Ø¯Ù†
    nearest_points,       # Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø§Ø·
    transform,            # ØªØ¨Ø¯ÛŒÙ„ Ù…Ø®ØªØµØ§Øª
    triangulate,          # Ù…Ø«Ù„Ø«â€ŒØ¨Ù†Ø¯ÛŒ
    voronoi_diagram,      # Ù†Ù…ÙˆØ¯Ø§Ø± Voronoi
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Import Ù‡Ø§ÛŒ ØªØ¨Ø¯ÛŒÙ„ ÙØ±Ù…Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely import wkt, wkb
from shapely.geometry import shape, mapping

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Import Ù‡Ø§ÛŒ Ú©Ù…Ú©ÛŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely.validation import make_valid, explain_validity
from shapely.affinity import (
    rotate,               # Ú†Ø±Ø®Ø´
    scale,                # Ù…Ù‚ÛŒØ§Ø³
    translate,            # Ø§Ù†ØªÙ‚Ø§Ù„
    skew,                 # Ú©Ø¬ Ú©Ø±Ø¯Ù†
    affine_transform,     # ØªØ¨Ø¯ÛŒÙ„ Ø¢ÙÛŒÙ†
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Import Ù‡Ø§ÛŒ Shapely 2.0
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import shapely
from shapely import (
    area,
    length,
    distance,
    buffer,
    intersection,
    union,
    difference,
    symmetric_difference,
    contains,
    within,
    intersects,
    touches,
    crosses,
    overlaps,
    is_valid,
    is_empty,
    centroid,
    convex_hull,
    envelope,
    simplify,
)</code></pre>
                </div>
            </div>

            <div class="info-box warning">
                <div class="info-icon">âš ï¸</div>
                <div class="info-content">
                    <h4>ØªØºÛŒÛŒØ±Ø§Øª Shapely 2.0</h4>
                    <p>
                        Ø¯Ø± Shapely 2.0 ØªØºÛŒÛŒØ±Ø§Øª Ù…Ù‡Ù…ÛŒ Ø±Ø® Ø¯Ø§Ø¯Ù‡ Ø§Ø³Øª. ØªÙˆØ§Ø¨Ø¹ Ø¨Ù‡ ØµÙˆØ±Øª vectorized Ø¯Ø± Ø³Ø·Ø­ Ù…Ø§Ú˜ÙˆÙ„
                        Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ Ù‡Ø³ØªÙ†Ø¯ Ùˆ Ú©Ø§Ø±Ø§ÛŒÛŒ Ø¨Ù‡ØªØ±ÛŒ Ø¯Ø§Ø±Ù†Ø¯. Ø¨Ø±Ø§ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø§Ø² Shapely 2.0+ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.
                    </p>
                </div>
            </div>
        </section>

        <!-- Section 3: Geometries -->
        <section class="section" id="geometries">
            <div class="section-header">
                <div class="section-icon">ğŸ”·</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ø³ÙˆÙ…</div>
                    <h2 class="section-title">Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§</h2>
                    <p class="section-subtitle">Ø³Ø§Ø®Øª Ø§Ù†ÙˆØ§Ø¹ Ø§Ø´Ú©Ø§Ù„ Ù‡Ù†Ø¯Ø³ÛŒ</p>
                </div>
            </div>

            <h3>ğŸ“ Point (Ù†Ù‚Ø·Ù‡)</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>point.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point
from shapely.geometry import MultiPoint

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Point
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù†Ù‚Ø·Ù‡ Û² Ø¨Ø¹Ø¯ÛŒ
point_2d = Point(51.3890, 35.6892)
print(f"Point 2D: {point_2d}")  # POINT (51.389 35.6892)

# Ù†Ù‚Ø·Ù‡ Û³ Ø¨Ø¹Ø¯ÛŒ (Ø¨Ø§ Ø§Ø±ØªÙØ§Ø¹)
point_3d = Point(51.3890, 35.6892, 1200)
print(f"Point 3D: {point_3d}")  # POINT Z (51.389 35.6892 1200)

# Ø§Ø² tuple ÛŒØ§ list
coords = (51.3890, 35.6892)
point_from_tuple = Point(coords)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…Ø®ØªØµØ§Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

point = Point(51.3890, 35.6892, 1200)

# Ù…Ø®ØªØµØ§Øª x, y, z
print(f"X: {point.x}")  # 51.389
print(f"Y: {point.y}")  # 35.6892
print(f"Z: {point.z}")  # 1200.0 (ÛŒØ§ exception Ø§Ú¯Ø± 2D Ø¨Ø§Ø´Ø¯)

# Ø¨Ù‡ ØµÙˆØ±Øª tuple
print(f"Coords: {point.coords[:]}")  # [(51.389, 35.6892, 1200.0)]
print(f"XY: {point.coords.xy}")      # (array([51.389]), array([35.6892]))

# Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¨Ø¹Ø§Ø¯
print(f"Has Z: {point.has_z}")  # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MultiPoint
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§Ø² Ù„ÛŒØ³Øª Ù†Ù‚Ø§Ø·
multi_point = MultiPoint([
    (51.3890, 35.6892),
    (51.6680, 32.6546),
    (52.5837, 29.5918)
])
print(f"MultiPoint: {multi_point}")

# Ø§Ø² Ø§Ø´ÛŒØ§Ø¡ Point
p1 = Point(51.3890, 35.6892)
p2 = Point(51.6680, 32.6546)
p3 = Point(52.5837, 29.5918)
multi_point2 = MultiPoint([p1, p2, p3])

# Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù†Ù‚Ø§Ø·
print(f"ØªØ¹Ø¯Ø§Ø¯ Ù†Ù‚Ø§Ø·: {len(multi_point.geoms)}")
for i, pt in enumerate(multi_point.geoms):
    print(f"  Point {i}: ({pt.x}, {pt.y})")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù†Ù‚Ø·Ù‡ Ø®Ø§Ù„ÛŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

empty_point = Point()
print(f"Empty: {empty_point.is_empty}")  # True
print(f"WKT: {empty_point.wkt}")         # POINT EMPTY</code></pre>
                </div>
            </div>

            <h3>ğŸ“ LineString (Ø®Ø·)</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>linestring.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import LineString
from shapely.geometry import MultiLineString

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ LineString
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§Ø² Ù„ÛŒØ³Øª Ù…Ø®ØªØµØ§Øª
line = LineString([
    (51.3890, 35.6892),  # ØªÙ‡Ø±Ø§Ù†
    (50.8764, 34.6401),  # Ù‚Ù…
    (51.6680, 32.6546)   # Ø§ØµÙÙ‡Ø§Ù†
])
print(f"LineString: {line}")

# Ø§Ø² Ø§Ø´ÛŒØ§Ø¡ Point
from shapely import Point
p1 = Point(51.3890, 35.6892)
p2 = Point(50.8764, 34.6401)
p3 = Point(51.6680, 32.6546)
line_from_points = LineString([p1, p2, p3])

# Û³ Ø¨Ø¹Ø¯ÛŒ
line_3d = LineString([
    (51.3890, 35.6892, 1200),
    (50.8764, 34.6401, 900),
    (51.6680, 32.6546, 1500)
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…Ø®ØªØµØ§Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù„ÛŒØ³Øª Ù…Ø®ØªØµØ§Øª
coords = list(line.coords)
print(f"Coords: {coords}")

# Ù…Ø®ØªØµØ§Øª x Ùˆ y Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡
x, y = line.xy
print(f"X values: {list(x)}")
print(f"Y values: {list(y)}")

# ØªØ¹Ø¯Ø§Ø¯ Ù†Ù‚Ø§Ø·
print(f"ØªØ¹Ø¯Ø§Ø¯ Ù†Ù‚Ø§Ø·: {len(line.coords)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø®Ø·
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print(f"Ø·ÙˆÙ„: {line.length}")
print(f"Bounds: {line.bounds}")  # (minx, miny, maxx, maxy)

# Ù†Ù‚Ø·Ù‡ Ø´Ø±ÙˆØ¹ Ùˆ Ù¾Ø§ÛŒØ§Ù†
print(f"Ù†Ù‚Ø·Ù‡ Ø´Ø±ÙˆØ¹: {Point(line.coords[0])}")
print(f"Ù†Ù‚Ø·Ù‡ Ù¾Ø§ÛŒØ§Ù†: {Point(line.coords[-1])}")

# Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø³ØªÙ‡ Ø¨ÙˆØ¯Ù†
print(f"Ø¨Ø³ØªÙ‡ Ø§Ø³Øª: {line.is_ring}")  # False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MultiLineString
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

multi_line = MultiLineString([
    [(0, 0), (1, 1), (2, 0)],
    [(3, 0), (4, 1), (5, 0)]
])
print(f"MultiLineString: {multi_line}")
print(f"ØªØ¹Ø¯Ø§Ø¯ Ø®Ø·ÙˆØ·: {len(multi_line.geoms)}")

# Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù‡Ø± Ø®Ø·
for i, ln in enumerate(multi_line.geoms):
    print(f"  Line {i}: {ln.wkt}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LinearRing (Ø­Ù„Ù‚Ù‡ Ø¨Ø³ØªÙ‡)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely import LinearRing

# Ø­Ù„Ù‚Ù‡ Ø¨Ù‡ ØµÙˆØ±Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ø³ØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
ring = LinearRing([
    (0, 0), (1, 0), (1, 1), (0, 1)
    # Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ ØªÚ©Ø±Ø§Ø± Ù†Ù‚Ø·Ù‡ Ø§ÙˆÙ„ Ù†ÛŒØ³Øª
])
print(f"Ring: {ring}")
print(f"Ø¨Ø³ØªÙ‡ Ø§Ø³Øª: {ring.is_ring}")  # True
print(f"Ø³Ø§Ø¯Ù‡ Ø§Ø³Øª: {ring.is_simple}")  # True</code></pre>
                </div>
            </div>

            <h3>ğŸ”· Polygon (Ú†Ù†Ø¯Ø¶Ù„Ø¹ÛŒ)</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>polygon.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Polygon
from shapely.geometry import MultiPolygon, box

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Polygon Ø³Ø§Ø¯Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§Ø² Ù„ÛŒØ³Øª Ù…Ø®ØªØµØ§Øª (Ø­Ù„Ù‚Ù‡ Ø¨ÛŒØ±ÙˆÙ†ÛŒ)
polygon = Polygon([
    (0, 0), (4, 0), (4, 4), (0, 4)
    # Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ ØªÚ©Ø±Ø§Ø± Ù†Ù‚Ø·Ù‡ Ø§ÙˆÙ„ Ù†ÛŒØ³Øª
])
print(f"Polygon: {polygon}")

# Ø¨Ø§ Ù…Ø®ØªØµØ§Øª ØµØ±ÛŒØ­
polygon2 = Polygon(shell=[
    (0, 0), (4, 0), (4, 4), (0, 4), (0, 0)
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Polygon Ø¨Ø§ Ø³ÙˆØ±Ø§Ø® (Hole)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø­Ù„Ù‚Ù‡ Ø¨ÛŒØ±ÙˆÙ†ÛŒ Ùˆ Ø³ÙˆØ±Ø§Ø®â€ŒÙ‡Ø§
exterior = [(0, 0), (10, 0), (10, 10), (0, 10)]
hole1 = [(2, 2), (2, 4), (4, 4), (4, 2)]
hole2 = [(6, 6), (6, 8), (8, 8), (8, 6)]

polygon_with_holes = Polygon(shell=exterior, holes=[hole1, hole2])
print(f"Polygon Ø¨Ø§ Ø³ÙˆØ±Ø§Ø®: {polygon_with_holes}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§Ø¬Ø²Ø§
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø­Ù„Ù‚Ù‡ Ø¨ÛŒØ±ÙˆÙ†ÛŒ
exterior_ring = polygon_with_holes.exterior
print(f"Ø­Ù„Ù‚Ù‡ Ø¨ÛŒØ±ÙˆÙ†ÛŒ: {exterior_ring}")
print(f"Ù…Ø®ØªØµØ§Øª Ø¨ÛŒØ±ÙˆÙ†ÛŒ: {list(exterior_ring.coords)}")

# Ø³ÙˆØ±Ø§Ø®â€ŒÙ‡Ø§
print(f"ØªØ¹Ø¯Ø§Ø¯ Ø³ÙˆØ±Ø§Ø®: {len(polygon_with_holes.interiors)}")
for i, hole in enumerate(polygon_with_holes.interiors):
    print(f"  Ø³ÙˆØ±Ø§Ø® {i}: {hole}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Polygon
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

poly = Polygon([(0, 0), (4, 0), (4, 3), (0, 3)])

print(f"Ù…Ø³Ø§Ø­Øª: {poly.area}")              # 12.0
print(f"Ù…Ø­ÛŒØ·: {poly.length}")             # 14.0
print(f"Bounds: {poly.bounds}")           # (0.0, 0.0, 4.0, 3.0)
print(f"Ù…Ø±Ú©Ø²: {poly.centroid}")           # POINT (2 1.5)
print(f"Ù…Ø¹ØªØ¨Ø±: {poly.is_valid}")          # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø³ØªØ·ÛŒÙ„ Ø¨Ø§ box
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# box(minx, miny, maxx, maxy)
rectangle = box(0, 0, 4, 3)
print(f"Rectangle: {rectangle}")

# Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø±Ø¨Ø¹
square = box(0, 0, 5, 5)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MultiPolygon
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

poly1 = Polygon([(0, 0), (2, 0), (2, 2), (0, 2)])
poly2 = Polygon([(3, 0), (5, 0), (5, 2), (3, 2)])

multi_poly = MultiPolygon([poly1, poly2])
print(f"MultiPolygon: {multi_poly}")
print(f"ØªØ¹Ø¯Ø§Ø¯ polygon: {len(multi_poly.geoms)}")
print(f"Ù…Ø³Ø§Ø­Øª Ú©Ù„: {multi_poly.area}")

# Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù‡Ø± polygon
for i, p in enumerate(multi_poly.geoms):
    print(f"  Polygon {i}: area={p.area}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GeometryCollection
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely import GeometryCollection, Point, LineString

gc = GeometryCollection([
    Point(0, 0),
    LineString([(0, 0), (1, 1)]),
    Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])
])
print(f"GeometryCollection: {gc}")
print(f"ØªØ¹Ø¯Ø§Ø¯: {len(gc.geoms)}")

for geom in gc.geoms:
    print(f"  {geom.geom_type}: {geom}")</code></pre>
                </div>
            </div>

            <h3>ğŸ”§ ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø³Ø§Ø®Øª Ù‡Ù†Ø¯Ø³Ù‡</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>geometry_helpers.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, Polygon
from shapely.geometry import box
import math

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø§ÛŒØ±Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_circle(center_x, center_y, radius, num_points=64):
    """Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø§ÛŒØ±Ù‡ Ø¨Ø§ ØªØ¹Ø¯Ø§Ø¯ Ù†Ù‚Ø§Ø· Ù…Ø´Ø®Øµ"""
    angles = [2 * math.pi * i / num_points for i in range(num_points)]
    points = [
        (center_x + radius * math.cos(angle),
         center_y + radius * math.sin(angle))
        for angle in angles
    ]
    return Polygon(points)

circle = create_circle(0, 0, 5, 64)
print(f"Circle area: {circle.area:.2f}")  # ~78.54

# Ø±ÙˆØ´ Ø³Ø§Ø¯Ù‡â€ŒØªØ± Ø¨Ø§ buffer
circle_simple = Point(0, 0).buffer(5, resolution=64)
print(f"Circle (buffer): {circle_simple.area:.2f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ø¨ÛŒØ¶ÛŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_ellipse(center_x, center_y, a, b, num_points=64):
    """Ø§ÛŒØ¬Ø§Ø¯ Ø¨ÛŒØ¶ÛŒ Ø¨Ø§ Ù†ÛŒÙ…â€ŒÙ…Ø­ÙˆØ±Ù‡Ø§ÛŒ a Ùˆ b"""
    angles = [2 * math.pi * i / num_points for i in range(num_points)]
    points = [
        (center_x + a * math.cos(angle),
         center_y + b * math.sin(angle))
        for angle in angles
    ]
    return Polygon(points)

ellipse = create_ellipse(0, 0, 10, 5, 64)
print(f"Ellipse area: {ellipse.area:.2f}")  # ~157.08

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ú†Ù†Ø¯Ø¶Ù„Ø¹ÛŒ Ù…Ù†ØªØ¸Ù…
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_regular_polygon(center_x, center_y, radius, num_sides):
    """Ø§ÛŒØ¬Ø§Ø¯ Ú†Ù†Ø¯Ø¶Ù„Ø¹ÛŒ Ù…Ù†ØªØ¸Ù…"""
    angles = [2 * math.pi * i / num_sides - math.pi/2 for i in range(num_sides)]
    points = [
        (center_x + radius * math.cos(angle),
         center_y + radius * math.sin(angle))
        for angle in angles
    ]
    return Polygon(points)

# Ù…Ø«Ù„Ø« Ù…ØªØ³Ø§ÙˆÛŒâ€ŒØ§Ù„Ø§Ø¶Ù„Ø§Ø¹
triangle = create_regular_polygon(0, 0, 5, 3)

# Ù…Ø±Ø¨Ø¹
square = create_regular_polygon(0, 0, 5, 4)

# Ø´Ø´â€ŒØ¶Ù„Ø¹ÛŒ
hexagon = create_regular_polygon(0, 0, 5, 6)

print(f"Triangle area: {triangle.area:.2f}")
print(f"Square area: {square.area:.2f}")
print(f"Hexagon area: {hexagon.area:.2f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ø³ØªØ§Ø±Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_star(center_x, center_y, outer_radius, inner_radius, num_points):
    """Ø§ÛŒØ¬Ø§Ø¯ Ø³ØªØ§Ø±Ù‡ Ø¨Ø§ ØªØ¹Ø¯Ø§Ø¯ Ù¾Ø± Ù…Ø´Ø®Øµ"""
    points = []
    for i in range(num_points * 2):
        angle = math.pi * i / num_points - math.pi / 2
        r = outer_radius if i % 2 == 0 else inner_radius
        points.append((
            center_x + r * math.cos(angle),
            center_y + r * math.sin(angle)
        ))
    return Polygon(points)

star = create_star(0, 0, 10, 4, 5)  # Ø³ØªØ§Ø±Ù‡ Ûµ Ù¾Ø±
print(f"Star area: {star.area:.2f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø·Ø§Ø¹ Ø¯Ø§ÛŒØ±Ù‡ (Sector)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_sector(center_x, center_y, radius, start_angle, end_angle, num_points=32):
    """Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø·Ø§Ø¹ Ø¯Ø§ÛŒØ±Ù‡ (Ø²Ø§ÙˆÛŒÙ‡ Ø¨Ù‡ Ø¯Ø±Ø¬Ù‡)"""
    start_rad = math.radians(start_angle)
    end_rad = math.radians(end_angle)
    
    angles = [start_rad + (end_rad - start_rad) * i / num_points 
              for i in range(num_points + 1)]
    
    points = [(center_x, center_y)]  # Ù…Ø±Ú©Ø²
    points.extend([
        (center_x + radius * math.cos(angle),
         center_y + radius * math.sin(angle))
        for angle in angles
    ])
    
    return Polygon(points)

sector = create_sector(0, 0, 5, 0, 90)  # Ø±Ø¨Ø¹ Ø¯Ø§ÛŒØ±Ù‡
print(f"Sector area: {sector.area:.2f}")  # ~19.63

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù…Ø§Ù† (Arc) Ø¨Ù‡ ØµÙˆØ±Øª Ø®Ø·
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely import LineString

def create_arc(center_x, center_y, radius, start_angle, end_angle, num_points=32):
    """Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù…Ø§Ù† Ø¨Ù‡ ØµÙˆØ±Øª LineString"""
    start_rad = math.radians(start_angle)
    end_rad = math.radians(end_angle)
    
    angles = [start_rad + (end_rad - start_rad) * i / num_points 
              for i in range(num_points + 1)]
    
    points = [
        (center_x + radius * math.cos(angle),
         center_y + radius * math.sin(angle))
        for angle in angles
    ]
    
    return LineString(points)

arc = create_arc(0, 0, 5, 0, 180)  # Ù†ÛŒÙ…â€ŒØ¯Ø§ÛŒØ±Ù‡
print(f"Arc length: {arc.length:.2f}")</code></pre>
                </div>
            </div>
        </section>

        <!-- Section 4: Properties -->
        <section class="section" id="properties">
            <div class="section-header">
                <div class="section-icon">ğŸ“Š</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ú†Ù‡Ø§Ø±Ù…</div>
                    <h2 class="section-title">ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù‡Ù†Ø¯Ø³Ù‡</h2>
                    <p class="section-subtitle">Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ùˆ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø·Ù„Ø§Ø¹Ø§Øª</p>
                </div>
            </div>

            <h3>ğŸ“ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>measurements.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely.geometry import box

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù…Ø³Ø§Ø­Øª (Area)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù…Ø³Ø§Ø­Øª Polygon
polygon = Polygon([(0, 0), (4, 0), (4, 3), (0, 3)])
print(f"Ù…Ø³Ø§Ø­Øª: {polygon.area}")  # 12.0

# Ù…Ø³Ø§Ø­Øª Ø¨Ø§ Ø³ÙˆØ±Ø§Ø®
exterior = [(0, 0), (10, 0), (10, 10), (0, 10)]
hole = [(2, 2), (2, 4), (4, 4), (4, 2)]
polygon_hole = Polygon(exterior, [hole])
print(f"Ù…Ø³Ø§Ø­Øª Ø¨Ø§ Ø³ÙˆØ±Ø§Ø®: {polygon_hole.area}")  # 96.0 (100 - 4)

# Ù…Ø³Ø§Ø­Øª Ø¯Ø§ÛŒØ±Ù‡
circle = Point(0, 0).buffer(5)
print(f"Ù…Ø³Ø§Ø­Øª Ø¯Ø§ÛŒØ±Ù‡: {circle.area:.4f}")  # ~78.5398

# Ù†Ú©ØªÙ‡: Point Ùˆ LineString Ù…Ø³Ø§Ø­Øª ØµÙØ± Ø¯Ø§Ø±Ù†Ø¯
print(f"Ù…Ø³Ø§Ø­Øª Ù†Ù‚Ø·Ù‡: {Point(0, 0).area}")     # 0.0
print(f"Ù…Ø³Ø§Ø­Øª Ø®Ø·: {LineString([(0, 0), (1, 1)]).area}")  # 0.0

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø·ÙˆÙ„ (Length)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø·ÙˆÙ„ Ø®Ø·
line = LineString([(0, 0), (3, 4)])
print(f"Ø·ÙˆÙ„ Ø®Ø·: {line.length}")  # 5.0 (ÙÛŒØ«Ø§ØºÙˆØ±Ø³)

# Ø·ÙˆÙ„ Ø®Ø· Ú†Ù†Ø¯ Ù‚Ø·Ø¹Ù‡â€ŒØ§ÛŒ
multi_line = LineString([(0, 0), (3, 0), (3, 4)])
print(f"Ø·ÙˆÙ„ Ø®Ø· Ø´Ú©Ø³ØªÙ‡: {multi_line.length}")  # 7.0

# Ù…Ø­ÛŒØ· Polygon
polygon = Polygon([(0, 0), (4, 0), (4, 3), (0, 3)])
print(f"Ù…Ø­ÛŒØ·: {polygon.length}")  # 14.0

# Ù…Ø­ÛŒØ· Ø¯Ø§ÛŒØ±Ù‡
circle = Point(0, 0).buffer(5)
print(f"Ù…Ø­ÛŒØ· Ø¯Ø§ÛŒØ±Ù‡: {circle.length:.4f}")  # ~31.4159

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ÙØ§ØµÙ„Ù‡ (Distance)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

p1 = Point(0, 0)
p2 = Point(3, 4)
print(f"ÙØ§ØµÙ„Ù‡ Ø¯Ùˆ Ù†Ù‚Ø·Ù‡: {p1.distance(p2)}")  # 5.0

# ÙØ§ØµÙ„Ù‡ Ù†Ù‚Ø·Ù‡ ØªØ§ Ø®Ø·
point = Point(0, 2)
line = LineString([(0, 0), (4, 0)])
print(f"ÙØ§ØµÙ„Ù‡ Ù†Ù‚Ø·Ù‡ ØªØ§ Ø®Ø·: {point.distance(line)}")  # 2.0

# ÙØ§ØµÙ„Ù‡ Ø¯Ùˆ polygon
poly1 = box(0, 0, 2, 2)
poly2 = box(4, 0, 6, 2)
print(f"ÙØ§ØµÙ„Ù‡ Ø¯Ùˆ polygon: {poly1.distance(poly2)}")  # 2.0

# ÙØ§ØµÙ„Ù‡ ØµÙØ± = ØªÙ…Ø§Ø³ ÛŒØ§ ØªÙ‚Ø§Ø·Ø¹
poly3 = box(1, 0, 3, 2)
print(f"ÙØ§ØµÙ„Ù‡ (ØªÙ‚Ø§Ø·Ø¹): {poly1.distance(poly3)}")  # 0.0

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Hausdorff Distance
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

line1 = LineString([(0, 0), (1, 0), (2, 0)])
line2 = LineString([(0, 1), (1, 1), (2, 1)])
print(f"Hausdorff distance: {line1.hausdorff_distance(line2)}")  # 1.0

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Bounds (Ù…Ø­Ø¯ÙˆØ¯Ù‡)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = Polygon([(1, 2), (5, 2), (5, 6), (1, 6)])
bounds = polygon.bounds  # (minx, miny, maxx, maxy)
print(f"Bounds: {bounds}")  # (1.0, 2.0, 5.0, 6.0)

minx, miny, maxx, maxy = bounds
print(f"Ø¹Ø±Ø¶: {maxx - minx}")   # 4.0
print(f"Ø§Ø±ØªÙØ§Ø¹: {maxy - miny}")  # 4.0</code></pre>
                </div>
            </div>

            <h3>ğŸ¯ Ù†Ù‚Ø§Ø· ÙˆÛŒÚ˜Ù‡</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>special_points.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely.geometry import box

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Centroid (Ù…Ø±Ú©Ø² Ù‡Ù†Ø¯Ø³ÛŒ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù…Ø±Ú©Ø² Ù…Ø³ØªØ·ÛŒÙ„
rect = box(0, 0, 4, 6)
centroid = rect.centroid
print(f"Centroid: {centroid}")  # POINT (2 3)

# Ù…Ø±Ú©Ø² Ù…Ø«Ù„Ø«
triangle = Polygon([(0, 0), (4, 0), (2, 3)])
print(f"Triangle centroid: {triangle.centroid}")  # POINT (2 1)

# Ù…Ø±Ú©Ø² Ø®Ø·
line = LineString([(0, 0), (4, 0)])
print(f"Line centroid: {line.centroid}")  # POINT (2 0)

# Ù†Ú©ØªÙ‡: centroid Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø®Ø§Ø±Ø¬ Ø§Ø² Ù‡Ù†Ø¯Ø³Ù‡ Ø¨Ø§Ø´Ø¯
concave = Polygon([(0, 0), (4, 0), (4, 4), (2, 2), (0, 4)])
print(f"Concave centroid: {concave.centroid}")
print(f"Centroid inside: {concave.contains(concave.centroid)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Representative Point (Ù†Ù‚Ø·Ù‡ Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù†Ù‚Ø·Ù‡â€ŒØ§ÛŒ Ú©Ù‡ ØªØ¶Ù…ÛŒÙ† Ø´Ø¯Ù‡ Ø¯Ø§Ø®Ù„ Ù‡Ù†Ø¯Ø³Ù‡ Ø§Ø³Øª
concave = Polygon([(0, 0), (4, 0), (4, 4), (2, 2), (0, 4)])
rep_point = concave.representative_point()
print(f"Representative point: {rep_point}")
print(f"Inside: {concave.contains(rep_point)}")  # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Point on Surface
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù…Ø´Ø§Ø¨Ù‡ representative_point
point_on_surface = concave.point_on_surface()
print(f"Point on surface: {point_on_surface}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Envelope (Ù¾ÙˆØ´ Ù…Ø³ØªØ·ÛŒÙ„ÛŒ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

triangle = Polygon([(0, 0), (4, 0), (2, 3)])
envelope = triangle.envelope
print(f"Envelope: {envelope}")  # Ù…Ø³ØªØ·ÛŒÙ„ Ù…Ø­ÛŒØ·ÛŒ

# Minimum Rotated Rectangle
from shapely import minimum_rotated_rectangle
min_rect = minimum_rotated_rectangle(triangle)
print(f"Min rotated rectangle: {min_rect}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Convex Hull (Ù¾ÙˆØ´ Ù…Ø­Ø¯Ø¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely.geometry import MultiPoint

points = MultiPoint([(0, 0), (1, 1), (0, 2), (2, 2), (3, 1), (2, 0)])
hull = points.convex_hull
print(f"Convex hull: {hull}")
print(f"Hull area: {hull.area}")

# Ø¨Ø±Ø§ÛŒ polygon Ù…Ù‚Ø¹Ø±
concave = Polygon([(0, 0), (2, 2), (4, 0), (4, 4), (0, 4)])
print(f"Original area: {concave.area}")
print(f"Hull area: {concave.convex_hull.area}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø®Ø· Ø¨Ø§ ÙØ§ØµÙ„Ù‡ Ù…Ø´Ø®Øµ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

line = LineString([(0, 0), (10, 0)])

# Ù†Ù‚Ø·Ù‡ Ø¯Ø± ÙØ§ØµÙ„Ù‡ Û³ Ø§Ø² Ø§Ø¨ØªØ¯Ø§
point_at_3 = line.interpolate(3)
print(f"Point at distance 3: {point_at_3}")  # POINT (3 0)

# Ù†Ù‚Ø·Ù‡ Ø¯Ø± ÛµÛ°Ùª Ø·ÙˆÙ„
point_at_half = line.interpolate(0.5, normalized=True)
print(f"Point at 50%: {point_at_half}")  # POINT (5 0)

# ÙØ§ØµÙ„Ù‡ Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø®Ø· Ø§Ø² Ø§Ø¨ØªØ¯Ø§
point = Point(7, 0)
distance_along = line.project(point)
print(f"Distance along line: {distance_along}")  # 7.0

# Ø¨Ù‡ ØµÙˆØ±Øª Ù†Ø±Ù…Ø§Ù„â€ŒØ´Ø¯Ù‡
normalized_dist = line.project(point, normalized=True)
print(f"Normalized distance: {normalized_dist}")  # 0.7</code></pre>
                </div>
            </div>

            <h3>âœ… Ø¨Ø±Ø±Ø³ÛŒâ€ŒÙ‡Ø§ÛŒ ØµØ­Øª</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>validity.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely.validation import make_valid, explain_validity

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¨Ø±Ø±Ø³ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = Polygon([(0, 0), (4, 0), (4, 4), (0, 4)])

# Ø¢ÛŒØ§ Ù…Ø¹ØªØ¨Ø± Ø§Ø³ØªØŸ
print(f"is_valid: {polygon.is_valid}")  # True

# Ø¢ÛŒØ§ Ø®Ø§Ù„ÛŒ Ø§Ø³ØªØŸ
print(f"is_empty: {polygon.is_empty}")  # False

# Ø¢ÛŒØ§ Ø³Ø§Ø¯Ù‡ Ø§Ø³ØªØŸ (Ø¨Ø¯ÙˆÙ† Ø®ÙˆØ¯-ØªÙ‚Ø§Ø·Ø¹)
print(f"is_simple: {polygon.is_simple}")  # True

# Ø¢ÛŒØ§ Ø­Ù„Ù‚Ù‡ Ø§Ø³ØªØŸ (ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø®Ø·)
line = LineString([(0, 0), (1, 1), (0, 0)])
print(f"is_ring: {line.is_ring}")  # True

# Ø¢ÛŒØ§ Ø¨Ø³ØªÙ‡ Ø§Ø³ØªØŸ
print(f"is_closed: {line.is_closed}")  # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Polygon Ù†Ø§Ù…Ø¹ØªØ¨Ø± (Ø®ÙˆØ¯-ØªÙ‚Ø§Ø·Ø¹)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Polygon Ù¾Ø§Ù¾ÛŒÙˆÙ†ÛŒ (self-intersecting)
bowtie = Polygon([(0, 0), (2, 2), (2, 0), (0, 2)])
print(f"Bowtie is_valid: {bowtie.is_valid}")  # False

# Ø¯Ù„ÛŒÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¨ÙˆØ¯Ù†
print(f"Reason: {explain_validity(bowtie)}")
# Self-intersection[1 1]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ØµÙ„Ø§Ø­ Ù‡Ù†Ø¯Ø³Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ù‡Ù†Ø¯Ø³Ù‡ Ù…Ø¹ØªØ¨Ø±
valid_geom = make_valid(bowtie)
print(f"Valid type: {valid_geom.geom_type}")  # MultiPolygon
print(f"Valid is_valid: {valid_geom.is_valid}")  # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ù†ÙˆØ§Ø¹ Ø®Ø·Ø§Ù‡Ø§ÛŒ Ø±Ø§ÛŒØ¬
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Û±. Ring Self-intersection
invalid1 = Polygon([(0, 0), (2, 2), (2, 0), (0, 2)])
print(f"1. {explain_validity(invalid1)}")

# Û². Hole outside shell
exterior = [(0, 0), (4, 0), (4, 4), (0, 4)]
hole = [(10, 10), (12, 10), (12, 12), (10, 12)]  # Ø®Ø§Ø±Ø¬ Ø§Ø² Ø­Ù„Ù‚Ù‡ Ø¨ÛŒØ±ÙˆÙ†ÛŒ
invalid2 = Polygon(exterior, [hole])
print(f"2. {explain_validity(invalid2)}")

# Û³. Nested holes
hole1 = [(1, 1), (3, 1), (3, 3), (1, 3)]
hole2 = [(1.5, 1.5), (2.5, 1.5), (2.5, 2.5), (1.5, 2.5)]  # Ø¯Ø§Ø®Ù„ hole1
invalid3 = Polygon(exterior, [hole1, hole2])
print(f"3. {explain_validity(invalid3)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¨Ø±Ø±Ø³ÛŒ Ù†ÙˆØ¹ Ù‡Ù†Ø¯Ø³Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely import Point, LineString, Polygon, MultiPoint

geoms = [
    Point(0, 0),
    LineString([(0, 0), (1, 1)]),
    Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]),
    MultiPoint([(0, 0), (1, 1)])
]

for geom in geoms:
    print(f"Type: {geom.geom_type}")
    print(f"  has_z: {geom.has_z}")
    print(f"  is_empty: {geom.is_empty}")
    print(f"  is_valid: {geom.is_valid}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Buffer ØµÙØ± Ø¨Ø±Ø§ÛŒ Ø§ØµÙ„Ø§Ø­
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ú¯Ø§Ù‡ÛŒ buffer(0) Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù‡Ù†Ø¯Ø³Ù‡ Ø±Ø§ Ø§ØµÙ„Ø§Ø­ Ú©Ù†Ø¯
slightly_invalid = Polygon([(0, 0), (2, 2), (2, 0), (0, 2)])
fixed = slightly_invalid.buffer(0)
print(f"Fixed with buffer(0): {fixed.is_valid}")</code></pre>
                </div>
            </div>

            <h3>ğŸ“‹ Ø¬Ø¯ÙˆÙ„ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§</h3>
            <div class="function-grid">
                <div class="function-card">
                    <div class="function-name">area</div>
                    <div class="function-desc">Ù…Ø³Ø§Ø­Øª (ÙÙ‚Ø· Polygon)</div>
                    <div class="function-syntax">geom.area</div>
                </div>
                <div class="function-card">
                    <div class="function-name">length</div>
                    <div class="function-desc">Ø·ÙˆÙ„/Ù…Ø­ÛŒØ·</div>
                    <div class="function-syntax">geom.length</div>
                </div>
                <div class="function-card">
                    <div class="function-name">bounds</div>
                    <div class="function-desc">Ù…Ø­Ø¯ÙˆØ¯Ù‡ (minx, miny, maxx, maxy)</div>
                    <div class="function-syntax">geom.bounds</div>
                </div>
                <div class="function-card">
                    <div class="function-name">centroid</div>
                    <div class="function-desc">Ù…Ø±Ú©Ø² Ù‡Ù†Ø¯Ø³ÛŒ</div>
                    <div class="function-syntax">geom.centroid</div>
                </div>
                <div class="function-card">
                    <div class="function-name">envelope</div>
                    <div class="function-desc">Ù…Ø³ØªØ·ÛŒÙ„ Ù…Ø­ÛŒØ·ÛŒ</div>
                    <div class="function-syntax">geom.envelope</div>
                </div>
                <div class="function-card">
                    <div class="function-name">convex_hull</div>
                    <div class="function-desc">Ù¾ÙˆØ´ Ù…Ø­Ø¯Ø¨</div>
                    <div class="function-syntax">geom.convex_hull</div>
                </div>
                <div class="function-card">
                    <div class="function-name">is_valid</div>
                    <div class="function-desc">Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±</div>
                    <div class="function-syntax">geom.is_valid</div>
                </div>
                <div class="function-card">
                    <div class="function-name">is_empty</div>
                    <div class="function-desc">Ø¨Ø±Ø±Ø³ÛŒ Ø®Ø§Ù„ÛŒ Ø¨ÙˆØ¯Ù†</div>
                    <div class="function-syntax">geom.is_empty</div>
                </div>
            </div>
        </section>

        <!-- Section 5: Predicates -->
        <section class="section" id="predicates">
            <div class="section-header">
                <div class="section-icon">ğŸ”</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ù¾Ù†Ø¬Ù…</div>
                    <h2 class="section-title">Ø±ÙˆØ§Ø¨Ø· ØªÙˆÙ¾ÙˆÙ„ÙˆÚ˜ÛŒÚ©</h2>
                    <p class="section-subtitle">Ø¨Ø±Ø±Ø³ÛŒ Ø±ÙˆØ§Ø¨Ø· Ù…Ú©Ø§Ù†ÛŒ Ø¨ÛŒÙ† Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§</p>
                </div>
            </div>

            <h3>ğŸ¯ Ø±ÙˆØ§Ø¨Ø· DE-9IM</h3>
            <p>
                Shapely Ø§Ø² Ù…Ø¯Ù„ <strong>DE-9IM</strong> (Dimensionally Extended 9-Intersection Model)
                Ø¨Ø±Ø§ÛŒ ØªØ¹Ø±ÛŒÙ Ø±ÙˆØ§Ø¨Ø· Ù…Ú©Ø§Ù†ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ø§ÛŒÙ† Ù…Ø¯Ù„ Û¹ Ø±Ø§Ø¨Ø·Ù‡ Ø¨ÛŒÙ† InteriorØŒ Boundary Ùˆ Exterior
                Ø¯Ùˆ Ù‡Ù†Ø¯Ø³Ù‡ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
            </p>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>predicates.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely.geometry import box

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ¹Ø±ÛŒÙ Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

poly1 = box(0, 0, 4, 4)
poly2 = box(2, 2, 6, 6)  # Ù‡Ù…Ù¾ÙˆØ´Ø§Ù†ÛŒ Ø¨Ø§ poly1
poly3 = box(5, 0, 8, 4)  # Ø¬Ø¯Ø§ Ø§Ø² poly1
poly4 = box(1, 1, 3, 3)  # Ø¯Ø§Ø®Ù„ poly1

point_inside = Point(2, 2)
point_outside = Point(10, 10)
point_on_boundary = Point(4, 2)

line = LineString([(0, 2), (6, 2)])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# equals - Ø¨Ø±Ø§Ø¨Ø±ÛŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

poly_a = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])
poly_b = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])
poly_c = Polygon([(0, 0), (0, 1), (1, 1), (1, 0)])  # ØªØ±ØªÛŒØ¨ Ù…ØªÙØ§ÙˆØª

print(f"equals (same): {poly_a.equals(poly_b)}")      # True
print(f"equals (diff order): {poly_a.equals(poly_c)}")  # True

# equals_exact Ø¨Ø§ tolerance
print(f"equals_exact: {poly_a.equals_exact(poly_b, 0.001)}")  # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# contains - Ø´Ø§Ù…Ù„ Ø¨ÙˆØ¯Ù†
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø¢ÛŒØ§ poly1 Ø´Ø§Ù…Ù„ point_inside Ø§Ø³ØªØŸ
print(f"contains point: {poly1.contains(point_inside)}")  # True

# Ø¢ÛŒØ§ poly1 Ø´Ø§Ù…Ù„ poly4 Ø§Ø³ØªØŸ
print(f"contains polygon: {poly1.contains(poly4)}")  # True

# Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ù…Ø±Ø² Ø´Ø§Ù…Ù„ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯
print(f"contains boundary point: {poly1.contains(point_on_boundary)}")  # False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# within - Ø¯Ø§Ø®Ù„ Ø¨ÙˆØ¯Ù† (Ù…Ø¹Ú©ÙˆØ³ contains)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print(f"point within poly: {point_inside.within(poly1)}")  # True
print(f"poly4 within poly1: {poly4.within(poly1)}")        # True

# Ø±Ø§Ø¨Ø·Ù‡: A.contains(B) == B.within(A)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# covers / covered_by
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# covers Ø´Ø§Ù…Ù„ Ù†Ù‚Ø§Ø· Ø±ÙˆÛŒ Ù…Ø±Ø² Ù‡Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯
print(f"covers boundary point: {poly1.covers(point_on_boundary)}")  # True
print(f"contains boundary point: {poly1.contains(point_on_boundary)}")  # False

print(f"covered_by: {point_on_boundary.covered_by(poly1)}")  # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# intersects - ØªÙ‚Ø§Ø·Ø¹
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print(f"poly1 intersects poly2: {poly1.intersects(poly2)}")  # True
print(f"poly1 intersects poly3: {poly1.intersects(poly3)}")  # False
print(f"poly1 intersects line: {poly1.intersects(line)}")    # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# disjoint - Ø¬Ø¯Ø§ Ø¨ÙˆØ¯Ù† (Ù…Ø¹Ú©ÙˆØ³ intersects)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print(f"poly1 disjoint poly3: {poly1.disjoint(poly3)}")  # True
print(f"poly1 disjoint poly2: {poly1.disjoint(poly2)}")  # False

# Ø±Ø§Ø¨Ø·Ù‡: A.intersects(B) == not A.disjoint(B)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# touches - ØªÙ…Ø§Ø³ (ÙÙ‚Ø· Ø¯Ø± Ù…Ø±Ø²)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

poly_touch1 = box(0, 0, 2, 2)
poly_touch2 = box(2, 0, 4, 2)  # Ù…Ø´ØªØ±Ú© Ø¯Ø± ÛŒÚ© Ø¶Ù„Ø¹

print(f"touches: {poly_touch1.touches(poly_touch2)}")  # True

# Ø§Ú¯Ø± Ù‡Ù…Ù¾ÙˆØ´Ø§Ù†ÛŒ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù†Ø¯ØŒ touches Ù†ÛŒØ³Øª
print(f"poly1 touches poly2: {poly1.touches(poly2)}")  # False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# overlaps - Ù‡Ù…Ù¾ÙˆØ´Ø§Ù†ÛŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù‡Ù…Ù¾ÙˆØ´Ø§Ù†ÛŒ: Ø¨Ø®Ø´ÛŒ Ù…Ø´ØªØ±Ú© Ùˆ Ø¨Ø®Ø´ÛŒ Ø¬Ø¯Ø§
print(f"poly1 overlaps poly2: {poly1.overlaps(poly2)}")  # True
print(f"poly1 overlaps poly4: {poly1.overlaps(poly4)}")  # False (ÛŒÚ©ÛŒ Ø¯Ø§Ø®Ù„ Ø¯ÛŒÚ¯Ø±ÛŒ)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# crosses - Ø¹Ø¨ÙˆØ±
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø®Ø· Ø§Ø² polygon Ø¹Ø¨ÙˆØ± Ù…ÛŒâ€ŒÚ©Ù†Ø¯
print(f"line crosses poly1: {line.crosses(poly1)}")  # True

# Ø¯Ùˆ Ø®Ø· Ù…ØªÙ‚Ø§Ø·Ø¹
line1 = LineString([(0, 0), (2, 2)])
line2 = LineString([(0, 2), (2, 0)])
print(f"lines cross: {line1.crosses(line2)}")  # True</code></pre>
                </div>
            </div>

            <h3>ğŸ”¬ DE-9IM Matrix</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>de9im.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely.geometry import box

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù…Ø§ØªØ±ÛŒØ³ DE-9IM
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

poly1 = box(0, 0, 4, 4)
poly2 = box(2, 2, 6, 6)

# Ø¯Ø±ÛŒØ§ÙØª Ù…Ø§ØªØ±ÛŒØ³ Ø±Ø§Ø¨Ø·Ù‡
matrix = poly1.relate(poly2)
print(f"DE-9IM Matrix: {matrix}")  # 212101212

"""
Ù…Ø§ØªØ±ÛŒØ³ Û¹ Ú©Ø§Ø±Ø§Ú©ØªØ±ÛŒ:
       Interior  Boundary  Exterior
Int      2         1         2
Bound    1         0         1
Ext      2         1         2

Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§:
- F: False (Ø¨Ø¯ÙˆÙ† ØªÙ‚Ø§Ø·Ø¹)
- 0: Ù†Ù‚Ø·Ù‡
- 1: Ø®Ø·
- 2: Ø³Ø·Ø­
- T: True (Ù‡Ø± Ø¨Ø¹Ø¯ÛŒ)
- *: Ù‡Ø± Ú†ÛŒØ²ÛŒ
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø§ pattern
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ø±Ø§Ø¨Ø·Ù‡ Ø¨Ø§ pattern Ù…Ø·Ø§Ø¨Ù‚Øª Ø¯Ø§Ø±Ø¯
# contains pattern: T*F**FFF*
print(f"poly1 contains pattern: {poly1.relate_pattern(poly2, 'T*F**FFF*')}")

# within pattern: T*F**F***
# intersects pattern: T******** ÛŒØ§ *T******* ÛŒØ§ ***T***** ÛŒØ§ ****T****

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù…Ø«Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù†Ù‚Ø·Ù‡ Ø¯Ø§Ø®Ù„ polygon
point = Point(2, 2)
polygon = box(0, 0, 4, 4)
print(f"Point-Polygon: {point.relate(polygon)}")  # 0FFFFF212

# Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ù…Ø±Ø²
point_boundary = Point(4, 2)
print(f"Point on boundary: {point_boundary.relate(polygon)}")  # F0FFFF212

# Ø¯Ùˆ Ø®Ø· Ù…ØªÙ‚Ø§Ø·Ø¹
line1 = LineString([(0, 0), (4, 4)])
line2 = LineString([(0, 4), (4, 0)])
print(f"Crossing lines: {line1.relate(line2)}")  # 0F1FF0102

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ ØªÙØ³ÛŒØ±
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def interpret_de9im(matrix):
    """ØªÙØ³ÛŒØ± Ù…Ø§ØªØ±ÛŒØ³ DE-9IM"""
    labels = ['II', 'IB', 'IE', 'BI', 'BB', 'BE', 'EI', 'EB', 'EE']
    dims = {'F': 'Empty', '0': 'Point', '1': 'Line', '2': 'Area', 'T': 'Non-empty'}
    
    result = {}
    for i, char in enumerate(matrix):
        result[labels[i]] = dims.get(char, char)
    
    return result

print(interpret_de9im(poly1.relate(poly2)))</code></pre>
                </div>
            </div>

            <h3>ğŸ“‹ Ø¬Ø¯ÙˆÙ„ Ø±ÙˆØ§Ø¨Ø· ØªÙˆÙ¾ÙˆÙ„ÙˆÚ˜ÛŒÚ©</h3>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Ø±Ø§Ø¨Ø·Ù‡</th>
                            <th>ØªÙˆØ¶ÛŒØ­</th>
                            <th>DE-9IM Pattern</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>equals</code></td>
                            <td>Ø¯Ùˆ Ù‡Ù†Ø¯Ø³Ù‡ ÛŒÚ©Ø³Ø§Ù† Ù‡Ø³ØªÙ†Ø¯</td>
                            <td>T*F**FFF*</td>
                        </tr>
                        <tr>
                            <td><code>contains</code></td>
                            <td>A Ú©Ø§Ù…Ù„Ø§Ù‹ Ø´Ø§Ù…Ù„ B Ø§Ø³Øª</td>
                            <td>T*****FF*</td>
                        </tr>
                        <tr>
                            <td><code>within</code></td>
                            <td>A Ú©Ø§Ù…Ù„Ø§Ù‹ Ø¯Ø§Ø®Ù„ B Ø§Ø³Øª</td>
                            <td>T*F**F***</td>
                        </tr>
                        <tr>
                            <td><code>covers</code></td>
                            <td>A Ø´Ø§Ù…Ù„ B Ø§Ø³Øª (Ø¨Ø§ Ù…Ø±Ø²)</td>
                            <td>T*****FF* ÛŒØ§ *T****FF* ÛŒØ§ ...</td>
                        </tr>
                        <tr>
                            <td><code>intersects</code></td>
                            <td>A Ùˆ B Ø§Ø´ØªØ±Ø§Ú© Ø¯Ø§Ø±Ù†Ø¯</td>
                            <td>not disjoint</td>
                        </tr>
                        <tr>
                            <td><code>disjoint</code></td>
                            <td>A Ùˆ B Ú©Ø§Ù…Ù„Ø§Ù‹ Ø¬Ø¯Ø§ Ù‡Ø³ØªÙ†Ø¯</td>
                            <td>FF*FF****</td>
                        </tr>
                        <tr>
                            <td><code>touches</code></td>
                            <td>ÙÙ‚Ø· Ø¯Ø± Ù…Ø±Ø² ØªÙ…Ø§Ø³ Ø¯Ø§Ø±Ù†Ø¯</td>
                            <td>FT******* ÛŒØ§ F**T***** ÛŒØ§ ...</td>
                        </tr>
                        <tr>
                            <td><code>overlaps</code></td>
                            <td>Ù‡Ù…Ù¾ÙˆØ´Ø§Ù†ÛŒ Ø¬Ø²Ø¦ÛŒ Ø¯Ø§Ø±Ù†Ø¯</td>
                            <td>T*T***T** (Ø¨Ø±Ø§ÛŒ polygon)</td>
                        </tr>
                        <tr>
                            <td><code>crosses</code></td>
                            <td>Ø§Ø² Ù‡Ù… Ø¹Ø¨ÙˆØ± Ù…ÛŒâ€ŒÚ©Ù†Ù†Ø¯</td>
                            <td>T*T****** (line/polygon)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Section 6: Operations -->
        <section class="section" id="operations">
            <div class="section-header">
                <div class="section-icon">ğŸ”„</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ø´Ø´Ù…</div>
                    <h2 class="section-title">Ø¹Ù…Ù„ÛŒØ§Øª Ù‡Ù†Ø¯Ø³ÛŒ</h2>
                    <p class="section-subtitle">BufferØŒ Set Operations Ùˆ ØªØ¨Ø¯ÛŒÙ„Ø§Øª</p>
                </div>
            </div>

            <h3>ğŸ”µ Buffer (Ø­Ø±ÛŒÙ…)</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>buffer.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely.geometry import box

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Buffer Ù†Ù‚Ø·Ù‡ (Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø§ÛŒØ±Ù‡)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

point = Point(0, 0)

# buffer Ø³Ø§Ø¯Ù‡
circle = point.buffer(5)
print(f"Circle area: {circle.area:.4f}")  # ~78.5398

# Ú©Ù†ØªØ±Ù„ Ø¯Ù‚Øª (ØªØ¹Ø¯Ø§Ø¯ Ù‚Ø·Ø¹Ø§Øª)
circle_low = point.buffer(5, resolution=4)   # Û´ Ù‚Ø·Ø¹Ù‡ Ø¯Ø± Ù‡Ø± Ø±Ø¨Ø¹
circle_high = point.buffer(5, resolution=64)  # Û¶Û´ Ù‚Ø·Ø¹Ù‡ Ø¯Ø± Ù‡Ø± Ø±Ø¨Ø¹

print(f"Low res points: {len(circle_low.exterior.coords)}")
print(f"High res points: {len(circle_high.exterior.coords)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Buffer Ø®Ø·
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

line = LineString([(0, 0), (10, 0)])
line_buffer = line.buffer(2)
print(f"Line buffer area: {line_buffer.area}")

# Ø§Ù†ÙˆØ§Ø¹ cap_style (Ø§Ù†ØªÙ‡Ø§ÛŒ Ø®Ø·)
# 1 = round (Ú¯Ø±Ø¯ - Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
# 2 = flat (ØµØ§Ù)
# 3 = square (Ù…Ø±Ø¨Ø¹)

buffer_round = line.buffer(2, cap_style=1)
buffer_flat = line.buffer(2, cap_style=2)
buffer_square = line.buffer(2, cap_style=3)

print(f"Round cap area: {buffer_round.area:.2f}")
print(f"Flat cap area: {buffer_flat.area:.2f}")
print(f"Square cap area: {buffer_square.area:.2f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Buffer Ø¨Ø§ join_style
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø®Ø· Ø´Ú©Ø³ØªÙ‡
bent_line = LineString([(0, 0), (5, 0), (5, 5)])

# Ø§Ù†ÙˆØ§Ø¹ join_style (Ú¯ÙˆØ´Ù‡â€ŒÙ‡Ø§)
# 1 = round (Ú¯Ø±Ø¯ - Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
# 2 = mitre (ØªÛŒØ²)
# 3 = bevel (Ø¨Ø±ÛŒØ¯Ù‡)

buffer_join_round = bent_line.buffer(1, join_style=1)
buffer_join_mitre = bent_line.buffer(1, join_style=2)
buffer_join_bevel = bent_line.buffer(1, join_style=3)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Buffer Polygon
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = box(0, 0, 4, 4)

# Ø¨Ø²Ø±Ú¯ Ú©Ø±Ø¯Ù†
expanded = polygon.buffer(1)
print(f"Original area: {polygon.area}")
print(f"Expanded area: {expanded.area}")

# Ú©ÙˆÚ†Ú© Ú©Ø±Ø¯Ù† (buffer Ù…Ù†ÙÛŒ)
shrunk = polygon.buffer(-0.5)
print(f"Shrunk area: {shrunk.area}")

# buffer Ù…Ù†ÙÛŒ Ø²ÛŒØ§Ø¯ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù‡Ù†Ø¯Ø³Ù‡ Ø±Ø§ Ø®Ø§Ù„ÛŒ Ú©Ù†Ø¯
very_shrunk = polygon.buffer(-3)
print(f"Very shrunk is_empty: {very_shrunk.is_empty}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Buffer ÛŒÚ©â€ŒØ·Ø±ÙÙ‡ (single_sided)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

line = LineString([(0, 0), (10, 0)])

# buffer ÙÙ‚Ø· ÛŒÚ© Ø·Ø±Ù
left_buffer = line.buffer(2, single_sided=True)   # Ø³Ù…Øª Ú†Ù¾
right_buffer = line.buffer(-2, single_sided=True)  # Ø³Ù…Øª Ø±Ø§Ø³Øª

print(f"Left buffer area: {left_buffer.area}")
print(f"Right buffer area: {right_buffer.area}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Buffer Ø¨Ø§ mitre_limit
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø¨Ø±Ø§ÛŒ Ú¯ÙˆØ´Ù‡â€ŒÙ‡Ø§ÛŒ ØªÛŒØ²
sharp_corner = LineString([(0, 0), (5, 0), (5.1, 5)])

# Ø¨Ø¯ÙˆÙ† Ù…Ø­Ø¯ÙˆØ¯ÛŒØª mitre
buffer_no_limit = sharp_corner.buffer(1, join_style=2, mitre_limit=10)

# Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª mitre
buffer_limited = sharp_corner.buffer(1, join_style=2, mitre_limit=2)</code></pre>
                </div>
            </div>

            <h3>â• Ø¹Ù…Ù„ÛŒØ§Øª Ù…Ø¬Ù…ÙˆØ¹Ù‡â€ŒØ§ÛŒ</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>set_operations.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, Polygon
from shapely.geometry import box
from shapely.ops import unary_union

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ¹Ø±ÛŒÙ Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

poly1 = box(0, 0, 4, 4)
poly2 = box(2, 2, 6, 6)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Union (Ø§Ø¬ØªÙ…Ø§Ø¹)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

union_result = poly1.union(poly2)
print(f"Union type: {union_result.geom_type}")
print(f"Union area: {union_result.area}")  # 28.0 (16 + 16 - 4)

# Ø¹Ù…Ù„Ú¯Ø± |
union_op = poly1 | poly2
print(f"Using |: {union_op.equals(union_result)}")  # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Intersection (Ø§Ø´ØªØ±Ø§Ú©)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

intersection_result = poly1.intersection(poly2)
print(f"Intersection type: {intersection_result.geom_type}")
print(f"Intersection area: {intersection_result.area}")  # 4.0

# Ø¹Ù…Ù„Ú¯Ø± &
intersection_op = poly1 & poly2
print(f"Using &: {intersection_op.equals(intersection_result)}")  # True

# Ø¨Ø¯ÙˆÙ† Ø§Ø´ØªØ±Ø§Ú©
poly3 = box(10, 10, 12, 12)
no_intersection = poly1.intersection(poly3)
print(f"No intersection is_empty: {no_intersection.is_empty}")  # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Difference (ØªÙØ§Ø¶Ù„)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# poly1 Ù…Ù†Ù‡Ø§ÛŒ poly2
diff_result = poly1.difference(poly2)
print(f"Difference type: {diff_result.geom_type}")
print(f"Difference area: {diff_result.area}")  # 12.0

# Ø¹Ù…Ù„Ú¯Ø± -
diff_op = poly1 - poly2
print(f"Using -: {diff_op.equals(diff_result)}")  # True

# ØªØ±ØªÛŒØ¨ Ù…Ù‡Ù… Ø§Ø³Øª
diff_reverse = poly2.difference(poly1)
print(f"Reverse difference area: {diff_reverse.area}")  # 12.0 (Ù…ØªÙØ§ÙˆØª)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Symmetric Difference (ØªÙØ§Ø¶Ù„ Ù…ØªÙ‚Ø§Ø±Ù†)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sym_diff = poly1.symmetric_difference(poly2)
print(f"Symmetric diff type: {sym_diff.geom_type}")  # MultiPolygon
print(f"Symmetric diff area: {sym_diff.area}")  # 24.0

# Ø¹Ù…Ù„Ú¯Ø± ^
sym_diff_op = poly1 ^ poly2
print(f"Using ^: {sym_diff_op.equals(sym_diff)}")  # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Unary Union (Ø§Ø¬ØªÙ…Ø§Ø¹ Ú†Ù†Ø¯ Ù‡Ù†Ø¯Ø³Ù‡)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygons = [
    box(0, 0, 2, 2),
    box(1, 1, 3, 3),
    box(2, 2, 4, 4),
    box(3, 3, 5, 5)
]

# Ø±ÙˆØ´ Û±: unary_union
combined = unary_union(polygons)
print(f"Unary union type: {combined.geom_type}")
print(f"Unary union area: {combined.area}")

# Ø±ÙˆØ´ Û²: Ø¨Ø§ reduce
from functools import reduce
combined2 = reduce(lambda a, b: a.union(b), polygons)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø§ Ù†ØªØ§ÛŒØ¬ Ù…Ø®ØªÙ„Ù
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§Ø´ØªØ±Ø§Ú© Ø®Ø· Ø¨Ø§ polygon
line = LineString([(0, 2), (6, 2)])
polygon = box(1, 0, 5, 4)

line_intersection = line.intersection(polygon)
print(f"Line-Polygon intersection: {line_intersection}")
print(f"Type: {line_intersection.geom_type}")  # LineString

# Ø§Ø´ØªØ±Ø§Ú© Ø¯Ùˆ Ø®Ø·
line1 = LineString([(0, 0), (4, 4)])
line2 = LineString([(0, 4), (4, 0)])

lines_intersection = line1.intersection(line2)
print(f"Lines intersection: {lines_intersection}")  # Point</code></pre>
                </div>
            </div>

            <h3>ğŸ”€ ØªØ¨Ø¯ÛŒÙ„Ø§Øª Ø¢ÙÛŒÙ†</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>affine.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, Polygon
from shapely.geometry import box
from shapely.affinity import (
    translate, rotate, scale, skew, affine_transform
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Translate (Ø§Ù†ØªÙ‚Ø§Ù„)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = box(0, 0, 4, 4)

# Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ù‡ Ø±Ø§Ø³Øª Ùˆ Ø¨Ø§Ù„Ø§
translated = translate(polygon, xoff=5, yoff=3)
print(f"Original centroid: {polygon.centroid}")
print(f"Translated centroid: {translated.centroid}")

# Ø§Ù†ØªÙ‚Ø§Ù„ Û³ Ø¨Ø¹Ø¯ÛŒ
translated_3d = translate(polygon, xoff=5, yoff=3, zoff=10)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Rotate (Ú†Ø±Ø®Ø´)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = box(0, 0, 4, 4)

# Ú†Ø±Ø®Ø´ Û´Ûµ Ø¯Ø±Ø¬Ù‡ Ø­ÙˆÙ„ Ù…Ø±Ú©Ø²
rotated_center = rotate(polygon, 45)  # origin='center' Ù¾ÛŒØ´â€ŒÙØ±Ø¶
print(f"Rotated (center): {rotated_center}")

# Ú†Ø±Ø®Ø´ Ø­ÙˆÙ„ Ù†Ù‚Ø·Ù‡ Ù…Ø¨Ø¯Ø£
rotated_origin = rotate(polygon, 45, origin=(0, 0))

# Ú†Ø±Ø®Ø´ Ø­ÙˆÙ„ centroid
rotated_centroid = rotate(polygon, 45, origin='centroid')

# Ú†Ø±Ø®Ø´ Ø­ÙˆÙ„ Ù†Ù‚Ø·Ù‡ Ø¯Ù„Ø®ÙˆØ§Ù‡
rotated_custom = rotate(polygon, 45, origin=(2, 2))

# use_radians=True Ø¨Ø±Ø§ÛŒ Ø²Ø§ÙˆÛŒÙ‡ Ø±Ø§Ø¯ÛŒØ§Ù†
import math
rotated_rad = rotate(polygon, math.pi/4, use_radians=True)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Scale (Ù…Ù‚ÛŒØ§Ø³)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = box(0, 0, 4, 4)

# Ø¨Ø²Ø±Ú¯â€ŒÙ†Ù…Ø§ÛŒÛŒ Û² Ø¨Ø±Ø§Ø¨Ø±
scaled_2x = scale(polygon, xfact=2, yfact=2)
print(f"Original area: {polygon.area}")
print(f"Scaled 2x area: {scaled_2x.area}")  # 64.0

# Ù…Ù‚ÛŒØ§Ø³ Ù…ØªÙØ§ÙˆØª Ø¯Ø± x Ùˆ y
scaled_stretch = scale(polygon, xfact=2, yfact=0.5)
print(f"Stretched area: {scaled_stretch.area}")  # 16.0

# Ù…Ù‚ÛŒØ§Ø³ Ø­ÙˆÙ„ Ù†Ù‚Ø·Ù‡ Ø¯Ù„Ø®ÙˆØ§Ù‡
scaled_origin = scale(polygon, xfact=2, yfact=2, origin=(0, 0))
scaled_center = scale(polygon, xfact=2, yfact=2, origin='center')

# Ø¢ÛŒÙ†Ù‡ (mirror) Ø¨Ø§ Ù…Ù‚ÛŒØ§Ø³ Ù…Ù†ÙÛŒ
mirrored_x = scale(polygon, xfact=-1, yfact=1, origin='center')  # Ø¢ÛŒÙ†Ù‡ Ø§ÙÙ‚ÛŒ
mirrored_y = scale(polygon, xfact=1, yfact=-1, origin='center')  # Ø¢ÛŒÙ†Ù‡ Ø¹Ù…ÙˆØ¯ÛŒ

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Skew (Ú©Ø¬ Ú©Ø±Ø¯Ù†)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = box(0, 0, 4, 4)

# Ú©Ø¬ Ú©Ø±Ø¯Ù† Ø¯Ø± Ø¬Ù‡Øª x
skewed_x = skew(polygon, xs=30)  # Û³Û° Ø¯Ø±Ø¬Ù‡
print(f"Skewed X: {skewed_x}")

# Ú©Ø¬ Ú©Ø±Ø¯Ù† Ø¯Ø± Ø¬Ù‡Øª y
skewed_y = skew(polygon, ys=30)

# Ú©Ø¬ Ú©Ø±Ø¯Ù† Ø¯Ø± Ù‡Ø± Ø¯Ùˆ Ø¬Ù‡Øª
skewed_both = skew(polygon, xs=15, ys=15)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Affine Transform (ØªØ¨Ø¯ÛŒÙ„ Ø¢ÙÛŒÙ† Ú©Ø§Ù…Ù„)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ù…Ø§ØªØ±ÛŒØ³ ØªØ¨Ø¯ÛŒÙ„ Ø¢ÙÛŒÙ† Û²D:
| a  b  xoff |   | x |   | a*x + b*y + xoff |
| d  e  yoff | Ã— | y | = | d*x + e*y + yoff |
| 0  0  1    |   | 1 |   | 1                |

Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§: [a, b, d, e, xoff, yoff]
"""

polygon = box(0, 0, 2, 2)

# Ù…Ø§ØªØ±ÛŒØ³ Ù‡Ù…Ø§Ù†ÛŒ
identity = affine_transform(polygon, [1, 0, 0, 1, 0, 0])

# Ø§Ù†ØªÙ‚Ø§Ù„
translate_matrix = affine_transform(polygon, [1, 0, 0, 1, 5, 3])

# Ú†Ø±Ø®Ø´ Û¹Û° Ø¯Ø±Ø¬Ù‡
import math
angle = math.pi / 2
rotate_matrix = affine_transform(polygon, [
    math.cos(angle), -math.sin(angle),
    math.sin(angle), math.cos(angle),
    0, 0
])

# ØªØ±Ú©ÛŒØ¨ Ú†Ø±Ø®Ø´ Ùˆ Ø§Ù†ØªÙ‚Ø§Ù„
combined = affine_transform(polygon, [
    math.cos(angle), -math.sin(angle),
    math.sin(angle), math.cos(angle),
    5, 3
])</code></pre>
                </div>
            </div>

            <h3>âœ‚ï¸ Ø¹Ù…Ù„ÛŒØ§Øª Ø³Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ùˆ ØªÙ‚Ø³ÛŒÙ…</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>simplify_split.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely.ops import split, snap, linemerge

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Simplify (Ø³Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø®Ø· Ù¾ÛŒÚ†ÛŒØ¯Ù‡
complex_line = LineString([
    (0, 0), (1, 0.1), (2, -0.1), (3, 0.05),
    (4, -0.05), (5, 0.1), (6, 0), (7, -0.1),
    (8, 0.05), (9, -0.05), (10, 0)
])

print(f"Original points: {len(complex_line.coords)}")

# Ø³Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Douglas-Peucker
simplified = complex_line.simplify(0.2)
print(f"Simplified points: {len(simplified.coords)}")

# preserve_topology=True (Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
# Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ù†Ø¯Ø³Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±
simplified_safe = complex_line.simplify(0.2, preserve_topology=True)

# preserve_topology=False (Ø³Ø±ÛŒØ¹â€ŒØªØ±)
simplified_fast = complex_line.simplify(0.2, preserve_topology=False)

# Ø³Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ polygon
circle = Point(0, 0).buffer(5, resolution=64)
print(f"Circle points: {len(circle.exterior.coords)}")

simplified_circle = circle.simplify(0.5)
print(f"Simplified circle points: {len(simplified_circle.exterior.coords)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Split (ØªÙ‚Ø³ÛŒÙ…)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely.ops import split

# ØªÙ‚Ø³ÛŒÙ… Ø®Ø· Ø¨Ø§ Ù†Ù‚Ø·Ù‡
line = LineString([(0, 0), (10, 0)])
point = Point(5, 0)

split_result = split(line, point)
print(f"Split count: {len(split_result.geoms)}")  # 2
for i, part in enumerate(split_result.geoms):
    print(f"  Part {i}: {part}")

# ØªÙ‚Ø³ÛŒÙ… polygon Ø¨Ø§ Ø®Ø·
polygon = Polygon([(0, 0), (10, 0), (10, 10), (0, 10)])
splitter = LineString([(5, -1), (5, 11)])

split_polygon = split(polygon, splitter)
print(f"Split polygon count: {len(split_polygon.geoms)}")  # 2
for i, part in enumerate(split_polygon.geoms):
    print(f"  Part {i} area: {part.area}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Snap (Ú†Ø³Ø¨Ø§Ù†Ø¯Ù†)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely.ops import snap

# Ø¯Ùˆ Ø®Ø· Ú©Ù‡ ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹ Ø¨Ù‡ Ù‡Ù… Ù…ÛŒâ€ŒØ±Ø³Ù†Ø¯
line1 = LineString([(0, 0), (5, 0)])
line2 = LineString([(5.1, 0), (10, 0)])  # Ú©Ù…ÛŒ ÙØ§ØµÙ„Ù‡ Ø¯Ø§Ø±Ø¯

# Ú†Ø³Ø¨Ø§Ù†Ø¯Ù† Ø¨Ø§ tolerance
snapped = snap(line2, line1, tolerance=0.2)
print(f"Original line2 start: {line2.coords[0]}")
print(f"Snapped line2 start: {snapped.coords[0]}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Line Merge (Ø§Ø¯ØºØ§Ù… Ø®Ø·ÙˆØ·)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely.ops import linemerge
from shapely.geometry import MultiLineString

# Ø®Ø·ÙˆØ· Ù…ØªØµÙ„
lines = MultiLineString([
    [(0, 0), (1, 1)],
    [(1, 1), (2, 0)],
    [(2, 0), (3, 1)]
])

merged = linemerge(lines)
print(f"Merged type: {merged.geom_type}")  # LineString
print(f"Merged coords: {list(merged.coords)}")

# Ø®Ø·ÙˆØ· ØºÛŒØ±Ù…ØªØµÙ„
disconnected_lines = MultiLineString([
    [(0, 0), (1, 1)],
    [(5, 5), (6, 6)]
])

merged_disconnected = linemerge(disconnected_lines)
print(f"Disconnected merge type: {merged_disconnected.geom_type}")  # MultiLineString

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Polygonize (ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Polygon)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from shapely.ops import polygonize, polygonize_full

# Ø®Ø·ÙˆØ·ÛŒ Ú©Ù‡ ÛŒÚ© Ù…Ø±Ø¨Ø¹ ØªØ´Ú©ÛŒÙ„ Ù…ÛŒâ€ŒØ¯Ù‡Ù†Ø¯
lines = [
    LineString([(0, 0), (4, 0)]),
    LineString([(4, 0), (4, 4)]),
    LineString([(4, 4), (0, 4)]),
    LineString([(0, 4), (0, 0)])
]

# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ polygon
polygons = list(polygonize(lines))
print(f"Polygonized count: {len(polygons)}")
for poly in polygons:
    print(f"  Area: {poly.area}")

# polygonize_full - Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨ÛŒØ´ØªØ±
result, dangles, cuts, invalids = polygonize_full(lines)
print(f"Valid polygons: {len(result.geoms) if hasattr(result, 'geoms') else 1}")
print(f"Dangles: {dangles}")
print(f"Cuts: {cuts}")
print(f"Invalids: {invalids}")</code></pre>
                </div>
            </div>
        </section>

        <!-- Section 7: Analysis -->
        <section class="section" id="analysis">
            <div class="section-header">
                <div class="section-icon">ğŸ“Š</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ù‡ÙØªÙ…</div>
                    <h2 class="section-title">ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡</h2>
                    <p class="section-subtitle">VoronoiØŒ Triangulation Ùˆ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ</p>
                </div>
            </div>

            <h3>ğŸ”º Triangulation (Ù…Ø«Ù„Ø«â€ŒØ¨Ù†Ø¯ÛŒ)</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>triangulation.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, Polygon
from shapely.geometry import MultiPoint
from shapely.ops import triangulate

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Delaunay Triangulation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ù†Ù‚Ø§Ø·
points = MultiPoint([
    (0, 0), (4, 0), (2, 3),
    (1, 1), (3, 1), (2, 2)
])

# Ù…Ø«Ù„Ø«â€ŒØ¨Ù†Ø¯ÛŒ Delaunay
triangles = triangulate(points)
print(f"ØªØ¹Ø¯Ø§Ø¯ Ù…Ø«Ù„Ø«: {len(triangles)}")

for i, tri in enumerate(triangles):
    print(f"Ù…Ø«Ù„Ø« {i}: Ù…Ø³Ø§Ø­Øª = {tri.area:.2f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù…Ø«Ù„Ø«â€ŒØ¨Ù†Ø¯ÛŒ Polygon
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = Polygon([(0, 0), (4, 0), (4, 4), (2, 2), (0, 4)])

# Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†Ù‚Ø§Ø· Ø§Ø² polygon
from shapely.geometry import MultiPoint
polygon_points = MultiPoint(list(polygon.exterior.coords)[:-1])

# Ù…Ø«Ù„Ø«â€ŒØ¨Ù†Ø¯ÛŒ
poly_triangles = triangulate(polygon_points)

# ÙÛŒÙ„ØªØ± Ù…Ø«Ù„Ø«â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ polygon
inside_triangles = [
    tri for tri in poly_triangles 
    if polygon.contains(tri.centroid)
]

print(f"Ù…Ø«Ù„Ø«â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø®Ù„: {len(inside_triangles)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù…Ø«Ù„Ø«â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§ edges
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø¯Ø±ÛŒØ§ÙØª ÛŒØ§Ù„â€ŒÙ‡Ø§ Ø¨Ù‡ Ø¬Ø§ÛŒ Ù…Ø«Ù„Ø«â€ŒÙ‡Ø§
edges = triangulate(points, edges=True)
print(f"ØªØ¹Ø¯Ø§Ø¯ ÛŒØ§Ù„: {len(edges)}")

for edge in edges:
    print(f"  {edge}")  # LineString</code></pre>
                </div>
            </div>

            <h3>ğŸ”· Voronoi Diagram</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>voronoi.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, Polygon
from shapely.geometry import MultiPoint, box
from shapely.ops import voronoi_diagram

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù…ÙˆØ¯Ø§Ø± Voronoi
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù†Ù‚Ø§Ø· Ø§ÛŒØ³ØªÚ¯Ø§Ù‡â€ŒÙ‡Ø§
stations = MultiPoint([
    (1, 1), (3, 1), (2, 3),
    (0, 2), (4, 2), (2, 0), (2, 4)
])

# Ù†Ù…ÙˆØ¯Ø§Ø± Voronoi
voronoi = voronoi_diagram(stations)
print(f"ØªØ¹Ø¯Ø§Ø¯ Ø³Ù„ÙˆÙ„: {len(voronoi.geoms)}")

for i, cell in enumerate(voronoi.geoms):
    print(f"Ø³Ù„ÙˆÙ„ {i}: {cell.geom_type}, Ù…Ø³Ø§Ø­Øª = {cell.area:.2f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Voronoi Ø¨Ø§ envelope
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø¨Ø±Ø´
boundary = box(0, 0, 5, 5)

# Voronoi Ø¨Ø§ envelope
voronoi_bounded = voronoi_diagram(stations, envelope=boundary)

# Ø¨Ø±Ø´ Ø³Ù„ÙˆÙ„â€ŒÙ‡Ø§ Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯Ù‡
clipped_cells = []
for cell in voronoi_bounded.geoms:
    clipped = cell.intersection(boundary)
    if not clipped.is_empty:
        clipped_cells.append(clipped)

print(f"Ø³Ù„ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø´â€ŒØ®ÙˆØ±Ø¯Ù‡: {len(clipped_cells)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Voronoi Ø¨Ø§ edges
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø¯Ø±ÛŒØ§ÙØª ÛŒØ§Ù„â€ŒÙ‡Ø§ Ø¨Ù‡ Ø¬Ø§ÛŒ Ø³Ù„ÙˆÙ„â€ŒÙ‡Ø§
voronoi_edges = voronoi_diagram(stations, edges=True)
print(f"ØªØ¹Ø¯Ø§Ø¯ ÛŒØ§Ù„: {len(voronoi_edges.geoms)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ú©Ø§Ø±Ø¨Ø±Ø¯: ØªØ¹ÛŒÛŒÙ† Ø­ÙˆØ²Ù‡ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§ÛŒØ³ØªÚ¯Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ø¢ØªØ´â€ŒÙ†Ø´Ø§Ù†ÛŒ
fire_stations = MultiPoint([
    (2, 2), (8, 2), (5, 7), (2, 8), (8, 8)
])

# Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø´Ù‡Ø±
city = box(0, 0, 10, 10)

# Ø­ÙˆØ²Ù‡ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ Ù‡Ø± Ø§ÛŒØ³ØªÚ¯Ø§Ù‡
service_areas = voronoi_diagram(fire_stations, envelope=city)

# Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø³Ø§Ø­Øª Ù‡Ø± Ø­ÙˆØ²Ù‡
for i, area in enumerate(service_areas.geoms):
    clipped = area.intersection(city)
    if not clipped.is_empty:
        print(f"Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ {i+1}: {clipped.area:.2f} ÙˆØ§Ø­Ø¯ Ù…Ø±Ø¨Ø¹")</code></pre>
                </div>
            </div>

            <h3>ğŸ“ Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø§Ø·</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>nearest.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely.ops import nearest_points
from shapely.geometry import MultiPoint

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø§Ø· Ø¨ÛŒÙ† Ø¯Ùˆ Ù‡Ù†Ø¯Ø³Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

point = Point(0, 0)
line = LineString([(2, 1), (5, 4)])

# ÛŒØ§ÙØªÙ† Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø§Ø·
p1, p2 = nearest_points(point, line)
print(f"Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ point: {p1}")
print(f"Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ line: {p2}")
print(f"ÙØ§ØµÙ„Ù‡: {p1.distance(p2):.4f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø§Ø² Ù…Ø¬Ù…ÙˆØ¹Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

target = Point(5, 5)
candidates = MultiPoint([
    (0, 0), (3, 3), (7, 2), (4, 6), (8, 8)
])

# ÛŒØ§ÙØªÙ† Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ†
_, nearest = nearest_points(target, candidates)
print(f"Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ø¨Ù‡ {target}: {nearest}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Polygon
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

point = Point(6, 6)
polygon = Polygon([(0, 0), (4, 0), (4, 4), (0, 4)])

p1, p2 = nearest_points(point, polygon)
print(f"Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ polygon: {p2}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ÛŒØ§ÙØªÙ† K Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ†
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def k_nearest(target, points, k):
    """ÛŒØ§ÙØªÙ† k Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡"""
    distances = []
    for pt in points.geoms:
        dist = target.distance(pt)
        distances.append((pt, dist))
    
    # Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ ÙØ§ØµÙ„Ù‡
    distances.sort(key=lambda x: x[1])
    
    return distances[:k]

target = Point(5, 5)
points = MultiPoint([
    (0, 0), (1, 1), (2, 2), (3, 3), (4, 4),
    (6, 6), (7, 7), (8, 8), (9, 9), (10, 10)
])

nearest_3 = k_nearest(target, points, 3)
for pt, dist in nearest_3:
    print(f"  {pt}: ÙØ§ØµÙ„Ù‡ = {dist:.2f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¬Ø³ØªØ¬ÙˆÛŒ Ø´Ø¹Ø§Ø¹ÛŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def points_within_radius(center, points, radius):
    """ÛŒØ§ÙØªÙ† Ù†Ù‚Ø§Ø· Ø¯Ø± Ø´Ø¹Ø§Ø¹ Ù…Ø´Ø®Øµ"""
    result = []
    for pt in points.geoms:
        if center.distance(pt) <= radius:
            result.append(pt)
    return MultiPoint(result) if result else None

center = Point(5, 5)
radius = 3

nearby = points_within_radius(center, points, radius)
if nearby:
    print(f"Ù†Ù‚Ø§Ø· Ø¯Ø± Ø´Ø¹Ø§Ø¹ {radius}: {len(nearby.geoms)}")</code></pre>
                </div>
            </div>

            <h3>ğŸ”— ØªØ­Ù„ÛŒÙ„ Ø´Ø¨Ú©Ù‡</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>network_analysis.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString
from shapely.geometry import MultiLineString
from shapely.ops import linemerge, unary_union, split

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¨Ú©Ù‡ Ø®ÛŒØ§Ø¨Ø§Ù†
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

streets = MultiLineString([
    # Ø®ÛŒØ§Ø¨Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø§ÙÙ‚ÛŒ
    [(0, 0), (10, 0)],
    [(0, 3), (10, 3)],
    [(0, 6), (10, 6)],
    # Ø®ÛŒØ§Ø¨Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø¹Ù…ÙˆØ¯ÛŒ
    [(0, 0), (0, 6)],
    [(5, 0), (5, 6)],
    [(10, 0), (10, 6)]
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ÛŒØ§ÙØªÙ† ØªÙ‚Ø§Ø·Ø¹â€ŒÙ‡Ø§
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def find_intersections(lines):
    """ÛŒØ§ÙØªÙ† Ù†Ù‚Ø§Ø· ØªÙ‚Ø§Ø·Ø¹ Ø®Ø·ÙˆØ·"""
    intersections = []
    line_list = list(lines.geoms)
    
    for i in range(len(line_list)):
        for j in range(i + 1, len(line_list)):
            if line_list[i].intersects(line_list[j]):
                inter = line_list[i].intersection(line_list[j])
                if inter.geom_type == 'Point':
                    intersections.append(inter)
                elif inter.geom_type == 'MultiPoint':
                    intersections.extend(inter.geoms)
    
    return intersections

intersections = find_intersections(streets)
print(f"ØªØ¹Ø¯Ø§Ø¯ ØªÙ‚Ø§Ø·Ø¹: {len(intersections)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªÙ‚Ø³ÛŒÙ… Ø®Ø·ÙˆØ· Ø¯Ø± ØªÙ‚Ø§Ø·Ø¹â€ŒÙ‡Ø§
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def split_lines_at_intersections(lines):
    """ØªÙ‚Ø³ÛŒÙ… Ø®Ø·ÙˆØ· Ø¯Ø± Ù†Ù‚Ø§Ø· ØªÙ‚Ø§Ø·Ø¹"""
    # Ø§Ø¬ØªÙ…Ø§Ø¹ Ù‡Ù…Ù‡ Ø®Ø·ÙˆØ· (ØªÙ‚Ø³ÛŒÙ… Ø®ÙˆØ¯Ú©Ø§Ø± Ø¯Ø± ØªÙ‚Ø§Ø·Ø¹â€ŒÙ‡Ø§)
    merged = unary_union(lines)
    
    if merged.geom_type == 'MultiLineString':
        return list(merged.geoms)
    elif merged.geom_type == 'LineString':
        return [merged]
    else:
        return []

segments = split_lines_at_intersections(streets)
print(f"ØªØ¹Ø¯Ø§Ø¯ Ù‚Ø·Ø¹Ø§Øª: {len(segments)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ú¯Ø±Ø§Ù Ø´Ø¨Ú©Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_network_graph(segments):
    """Ø§ÛŒØ¬Ø§Ø¯ Ú¯Ø±Ø§Ù Ø§Ø² Ù‚Ø·Ø¹Ø§Øª Ø®Ø·"""
    nodes = {}
    edges = []
    node_id = 0
    
    for seg in segments:
        coords = list(seg.coords)
        start = coords[0]
        end = coords[-1]
        
        # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú¯Ø±Ù‡â€ŒÙ‡Ø§
        if start not in nodes:
            nodes[start] = node_id
            node_id += 1
        if end not in nodes:
            nodes[end] = node_id
            node_id += 1
        
        # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ÛŒØ§Ù„
        edges.append({
            'start': nodes[start],
            'end': nodes[end],
            'length': seg.length,
            'geometry': seg
        })
    
    return nodes, edges

nodes, edges = create_network_graph(segments)
print(f"Ú¯Ø±Ù‡â€ŒÙ‡Ø§: {len(nodes)}, ÛŒØ§Ù„â€ŒÙ‡Ø§: {len(edges)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ÛŒØ§ÙØªÙ† Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø´Ø¨Ú©Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def snap_to_network(point, network):
    """ÛŒØ§ÙØªÙ† Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø´Ø¨Ú©Ù‡"""
    min_dist = float('inf')
    nearest_point = None
    nearest_segment = None
    
    for seg in network:
        # Ù¾Ø±ÙˆØ¬Ú©Ø´Ù† Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø®Ø·
        dist = point.distance(seg)
        if dist < min_dist:
            min_dist = dist
            # Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø®Ø·
            proj_dist = seg.project(point)
            nearest_point = seg.interpolate(proj_dist)
            nearest_segment = seg
    
    return nearest_point, nearest_segment, min_dist

point = Point(2.5, 1.5)
snapped, segment, distance = snap_to_network(point, segments)
print(f"Ù†Ù‚Ø·Ù‡ Ø§ØµÙ„ÛŒ: {point}")
print(f"Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø´Ø¨Ú©Ù‡: {snapped}")
print(f"ÙØ§ØµÙ„Ù‡: {distance:.2f}")</code></pre>
                </div>
            </div>
        </section>

        <!-- Section 8: I/O -->
        <section class="section" id="io">
            <div class="section-header">
                <div class="section-icon">ğŸ“</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ù‡Ø´ØªÙ…</div>
                    <h2 class="section-title">ÙˆØ±ÙˆØ¯ÛŒ Ùˆ Ø®Ø±ÙˆØ¬ÛŒ</h2>
                    <p class="section-subtitle">WKTØŒ WKBØŒ GeoJSON Ùˆ ÙØ±Ù…Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÛŒÚ¯Ø±</p>
                </div>
            </div>

            <h3>ğŸ“ WKT (Well-Known Text)</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>wkt.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely import wkt
from shapely.wkt import loads, dumps

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ WKT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

point = Point(51.3890, 35.6892)
line = LineString([(0, 0), (1, 1), (2, 0)])
polygon = Polygon([(0, 0), (4, 0), (4, 4), (0, 4)])

# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² .wkt
print(f"Point WKT: {point.wkt}")
# POINT (51.389 35.6892)

print(f"Line WKT: {line.wkt}")
# LINESTRING (0 0, 1 1, 2 0)

print(f"Polygon WKT: {polygon.wkt}")
# POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))

# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² dumps Ø¨Ø§ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
wkt_str = dumps(point, rounding_precision=2)
print(f"Rounded WKT: {wkt_str}")
# POINT (51.39 35.69)

# Ø¨Ø¯ÙˆÙ† SRID
wkt_no_srid = dumps(polygon, include_srid=False)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø² WKT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² loads
wkt_string = "POINT (51.389 35.6892)"
point_from_wkt = loads(wkt_string)
print(f"From WKT: {point_from_wkt}")
print(f"Type: {point_from_wkt.geom_type}")

# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² wkt.loads
from shapely import wkt
polygon_wkt = "POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))"
polygon_from_wkt = wkt.loads(polygon_wkt)
print(f"Polygon area: {polygon_from_wkt.area}")

# Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ù†ÙˆØ§Ø¹ Ù…Ø®ØªÙ„Ù
geometries = [
    "POINT (0 0)",
    "POINT Z (0 0 5)",
    "LINESTRING (0 0, 1 1, 2 0)",
    "POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))",
    "MULTIPOINT ((0 0), (1 1))",
    "MULTILINESTRING ((0 0, 1 1), (2 2, 3 3))",
    "MULTIPOLYGON (((0 0, 1 0, 1 1, 0 1, 0 0)), ((2 2, 3 2, 3 3, 2 3, 2 2)))",
    "GEOMETRYCOLLECTION (POINT (0 0), LINESTRING (0 0, 1 1))"
]

for wkt_str in geometries:
    geom = loads(wkt_str)
    print(f"{geom.geom_type}: valid={geom.is_valid}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WKT Ø¨Ø§ Ø³ÙˆØ±Ø§Ø®
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon_with_hole = "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0), (2 2, 2 4, 4 4, 4 2, 2 2))"
poly_hole = loads(polygon_with_hole)
print(f"Area with hole: {poly_hole.area}")  # 96 (100 - 4)</code></pre>
                </div>
            </div>

            <h3>ğŸ”¢ WKB (Well-Known Binary)</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>wkb.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, Polygon
from shapely import wkb
from shapely.wkb import loads, dumps

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ WKB
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

point = Point(51.3890, 35.6892)
polygon = Polygon([(0, 0), (4, 0), (4, 4), (0, 4)])

# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ WKB (Ø¨Ø§ÛŒÙ†Ø±ÛŒ)
point_wkb = point.wkb
print(f"WKB type: {type(point_wkb)}")  # bytes
print(f"WKB length: {len(point_wkb)} bytes")

# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ WKB hex
point_wkb_hex = point.wkb_hex
print(f"WKB Hex: {point_wkb_hex}")

# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² dumps
wkb_bytes = dumps(polygon)
wkb_hex = dumps(polygon, hex=True)

# Ø¨Ø§ byte order Ù…Ø´Ø®Øµ
# big endian
wkb_be = dumps(point, big_endian=True)
# little endian (Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
wkb_le = dumps(point, big_endian=False)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø² WKB
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§Ø² bytes
point_restored = loads(point_wkb)
print(f"Restored: {point_restored}")

# Ø§Ø² hex string
point_from_hex = loads(point_wkb_hex, hex=True)
print(f"From hex: {point_from_hex}")

# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² wkb.loads
from shapely import wkb
geom = wkb.loads(polygon.wkb)
print(f"Polygon area: {geom.area}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø¯Ø± Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ (Ø¨Ù‡ ØµÙˆØ±Øª bytes ÛŒØ§ hex)
def save_to_db(geometry):
    """Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
    return geometry.wkb_hex

def load_from_db(wkb_hex):
    """Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
    return loads(wkb_hex, hex=True)

# Ù…Ø«Ø§Ù„
original = Polygon([(0, 0), (4, 0), (4, 4), (0, 4)])
stored = save_to_db(original)
restored = load_from_db(stored)
print(f"Equal: {original.equals(restored)}")</code></pre>
                </div>
            </div>

            <h3>ğŸŒ GeoJSON</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>geojson.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, LineString, Polygon
from shapely.geometry import shape, mapping
import json

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ GeoJSON
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

point = Point(51.3890, 35.6892)
line = LineString([(0, 0), (1, 1), (2, 0)])
polygon = Polygon([(0, 0), (4, 0), (4, 4), (0, 4)])

# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² mapping
point_geojson = mapping(point)
print(f"Point GeoJSON: {point_geojson}")
# {'type': 'Point', 'coordinates': (51.389, 35.6892)}

line_geojson = mapping(line)
print(f"Line GeoJSON: {line_geojson}")

polygon_geojson = mapping(polygon)
print(f"Polygon GeoJSON: {polygon_geojson}")

# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ JSON string
json_str = json.dumps(mapping(polygon), indent=2)
print(json_str)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø² GeoJSON
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§Ø² dict
geojson_dict = {
    "type": "Polygon",
    "coordinates": [[(0, 0), (4, 0), (4, 4), (0, 4), (0, 0)]]
}
polygon_from_geojson = shape(geojson_dict)
print(f"From GeoJSON: {polygon_from_geojson}")
print(f"Area: {polygon_from_geojson.area}")

# Ø§Ø² JSON string
json_string = '{"type": "Point", "coordinates": [51.389, 35.6892]}'
geojson_data = json.loads(json_string)
point_from_json = shape(geojson_data)
print(f"From JSON: {point_from_json}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GeoJSON Ø¨Ø§ Properties (Feature)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def geometry_to_feature(geometry, properties=None):
    """ØªØ¨Ø¯ÛŒÙ„ Ù‡Ù†Ø¯Ø³Ù‡ Ø¨Ù‡ GeoJSON Feature"""
    return {
        "type": "Feature",
        "geometry": mapping(geometry),
        "properties": properties or {}
    }

# Ø§ÛŒØ¬Ø§Ø¯ Feature
feature = geometry_to_feature(
    polygon,
    {"name": "Ù…Ù†Ø·Ù‚Ù‡ Û±", "area": polygon.area}
)
print(json.dumps(feature, indent=2, ensure_ascii=False))

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FeatureCollection
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_feature_collection(features):
    """Ø§ÛŒØ¬Ø§Ø¯ FeatureCollection"""
    return {
        "type": "FeatureCollection",
        "features": features
    }

# Ú†Ù†Ø¯ Feature
features = [
    geometry_to_feature(Point(0, 0), {"id": 1, "name": "Ù†Ù‚Ø·Ù‡ Û±"}),
    geometry_to_feature(Point(1, 1), {"id": 2, "name": "Ù†Ù‚Ø·Ù‡ Û²"}),
    geometry_to_feature(Point(2, 2), {"id": 3, "name": "Ù†Ù‚Ø·Ù‡ Û³"})
]

fc = create_feature_collection(features)
print(json.dumps(fc, indent=2, ensure_ascii=False))

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø®ÙˆØ§Ù†Ø¯Ù† FeatureCollection
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def read_feature_collection(geojson):
    """Ø®ÙˆØ§Ù†Ø¯Ù† Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§ Ø§Ø² FeatureCollection"""
    geometries = []
    for feature in geojson["features"]:
        geom = shape(feature["geometry"])
        props = feature.get("properties", {})
        geometries.append((geom, props))
    return geometries

# Ø®ÙˆØ§Ù†Ø¯Ù†
geoms_with_props = read_feature_collection(fc)
for geom, props in geoms_with_props:
    print(f"{props.get('name')}: {geom}")</code></pre>
                </div>
            </div>

            <h3>ğŸ“„ Ø°Ø®ÛŒØ±Ù‡ Ùˆ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙØ§ÛŒÙ„</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>file_io.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, Polygon
from shapely.geometry import shape, mapping
from shapely.wkt import loads as wkt_loads, dumps as wkt_dumps
from shapely.wkb import loads as wkb_loads, dumps as wkb_dumps
import json

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø°Ø®ÛŒØ±Ù‡ Ø¨Ù‡ ÙØ§ÛŒÙ„ GeoJSON
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = Polygon([(0, 0), (4, 0), (4, 4), (0, 4)])

# Ø°Ø®ÛŒØ±Ù‡ geometry
with open('polygon.geojson', 'w', encoding='utf-8') as f:
    json.dump(mapping(polygon), f, indent=2)

# Ø°Ø®ÛŒØ±Ù‡ Feature
feature = {
    "type": "Feature",
    "geometry": mapping(polygon),
    "properties": {"name": "Ù…Ù†Ø·Ù‚Ù‡ Ù†Ù…ÙˆÙ†Ù‡", "area": polygon.area}
}

with open('feature.geojson', 'w', encoding='utf-8') as f:
    json.dump(feature, f, indent=2, ensure_ascii=False)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø² ÙØ§ÛŒÙ„ GeoJSON
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

with open('polygon.geojson', 'r') as f:
    geojson_data = json.load(f)
    polygon_loaded = shape(geojson_data)
    print(f"Loaded polygon area: {polygon_loaded.area}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø°Ø®ÛŒØ±Ù‡ Ø¨Ù‡ ÙØ§ÛŒÙ„ WKT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

geometries = [
    Point(0, 0),
    Point(1, 1),
    Polygon([(0, 0), (2, 0), (2, 2), (0, 2)])
]

with open('geometries.wkt', 'w') as f:
    for geom in geometries:
        f.write(geom.wkt + '\n')

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø² ÙØ§ÛŒÙ„ WKT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

loaded_geoms = []
with open('geometries.wkt', 'r') as f:
    for line in f:
        line = line.strip()
        if line:
            geom = wkt_loads(line)
            loaded_geoms.append(geom)

print(f"Loaded {len(loaded_geoms)} geometries")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø°Ø®ÛŒØ±Ù‡ Ø¨Ù‡ ÙØ§ÛŒÙ„ WKB (Ø¨Ø§ÛŒÙ†Ø±ÛŒ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = Polygon([(0, 0), (4, 0), (4, 4), (0, 4)])

with open('polygon.wkb', 'wb') as f:
    f.write(polygon.wkb)

# Ø®ÙˆØ§Ù†Ø¯Ù†
with open('polygon.wkb', 'rb') as f:
    wkb_data = f.read()
    polygon_from_wkb = wkb_loads(wkb_data)
    print(f"From WKB: {polygon_from_wkb.area}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ú©Ù„Ø§Ø³ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ I/O
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class GeometryIO:
    @staticmethod
    def save_geojson(geometry, filepath, properties=None):
        """Ø°Ø®ÛŒØ±Ù‡ Ù‡Ù†Ø¯Ø³Ù‡ Ø¨Ù‡ GeoJSON"""
        data = {
            "type": "Feature",
            "geometry": mapping(geometry),
            "properties": properties or {}
        }
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    
    @staticmethod
    def load_geojson(filepath):
        """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù‡Ù†Ø¯Ø³Ù‡ Ø§Ø² GeoJSON"""
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        if data.get('type') == 'Feature':
            return shape(data['geometry']), data.get('properties', {})
        else:
            return shape(data), {}
    
    @staticmethod
    def save_wkt(geometries, filepath):
        """Ø°Ø®ÛŒØ±Ù‡ Ù„ÛŒØ³Øª Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§ Ø¨Ù‡ WKT"""
        with open(filepath, 'w') as f:
            for geom in geometries:
                f.write(geom.wkt + '\n')
    
    @staticmethod
    def load_wkt(filepath):
        """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§ Ø§Ø² WKT"""
        geometries = []
        with open(filepath, 'r') as f:
            for line in f:
                line = line.strip()
                if line:
                    geometries.append(wkt_loads(line))
        return geometries

# Ø§Ø³ØªÙØ§Ø¯Ù‡
GeometryIO.save_geojson(polygon, 'test.geojson', {'name': 'ØªØ³Øª'})
geom, props = GeometryIO.load_geojson('test.geojson')
print(f"Loaded: {geom.area}, props: {props}")</code></pre>
                </div>
            </div>
        </section>

        <!-- Section 9: Advanced -->
        <section class="section" id="advanced">
            <div class="section-header">
                <div class="section-icon">ğŸš€</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ù†Ù‡Ù…</div>
                    <h2 class="section-title">Ù…ÙˆØ¶ÙˆØ¹Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡</h2>
                    <p class="section-subtitle">STRtreeØŒ Vectorized Operations Ùˆ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ</p>
                </div>
            </div>

            <h3>ğŸŒ³ STRtree (Ø§ÛŒÙ†Ø¯Ú©Ø³ Ù…Ú©Ø§Ù†ÛŒ)</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>strtree.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, Polygon
from shapely.geometry import box
from shapely.strtree import STRtree
import random

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ STRtree
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ø²Ø§Ø±Ø§Ù† polygon ØªØµØ§Ø¯ÙÛŒ
polygons = []
for i in range(10000):
    x = random.uniform(0, 100)
    y = random.uniform(0, 100)
    size = random.uniform(0.5, 2)
    poly = box(x, y, x + size, y + size)
    polygons.append(poly)

# Ø§ÛŒØ¬Ø§Ø¯ Ø§ÛŒÙ†Ø¯Ú©Ø³ Ù…Ú©Ø§Ù†ÛŒ
tree = STRtree(polygons)
print(f"STRtree Ø¨Ø§ {len(polygons)} Ù‡Ù†Ø¯Ø³Ù‡ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¬Ø³ØªØ¬ÙˆÛŒ Ø³Ø±ÛŒØ¹
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø¬Ø³ØªØ¬Ùˆ
search_area = box(45, 45, 55, 55)

# ÛŒØ§ÙØªÙ† Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ØªÙ‚Ø§Ø·Ø¹ (Ø³Ø±ÛŒØ¹)
import time

start = time.time()
candidates = tree.query(search_area)
query_time = time.time() - start
print(f"Query time: {query_time*1000:.2f} ms")
print(f"Candidates: {len(candidates)}")

# ÙÛŒÙ„ØªØ± Ø¯Ù‚ÛŒÙ‚
start = time.time()
intersecting = [
    polygons[i] for i in candidates 
    if polygons[i].intersects(search_area)
]
filter_time = time.time() - start
print(f"Filter time: {filter_time*1000:.2f} ms")
print(f"Actually intersecting: {len(intersecting)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Ø±ÙˆØ´ Ø³Ø§Ø¯Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

start = time.time()
simple_result = [p for p in polygons if p.intersects(search_area)]
simple_time = time.time() - start
print(f"Simple method time: {simple_time*1000:.2f} ms")
print(f"Speedup: {simple_time/query_time:.1f}x")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù‡Ù†Ø¯Ø³Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

query_point = Point(50, 50)

# ÛŒØ§ÙØªÙ† Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ†
nearest_idx = tree.nearest(query_point)
nearest_geom = polygons[nearest_idx]
print(f"Nearest geometry index: {nearest_idx}")
print(f"Distance: {query_point.distance(nearest_geom):.4f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¬Ø³ØªØ¬Ùˆ Ø¨Ø§ geometry Ø¯Ù„Ø®ÙˆØ§Ù‡
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø®Ø· Ø¬Ø³ØªØ¬Ùˆ
search_line = LineString([(0, 50), (100, 50)])
line_candidates = tree.query(search_line)
print(f"Geometries near line: {len(line_candidates)}")

# Ø¯Ø§ÛŒØ±Ù‡ Ø¬Ø³ØªØ¬Ùˆ
search_circle = Point(50, 50).buffer(10)
circle_candidates = tree.query(search_circle)
print(f"Geometries in circle: {len(circle_candidates)}")</code></pre>
                </div>
            </div>

            <h3>âš¡ Vectorized Operations (Shapely 2.0)</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>vectorized.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">import numpy as np
import shapely
from shapely import Point, Polygon, LineString
from shapely.geometry import box

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§ÛŒØ¬Ø§Ø¯ Ø¢Ø±Ø§ÛŒÙ‡ Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø§ÛŒØ¬Ø§Ø¯ Ø¢Ø±Ø§ÛŒÙ‡ NumPy Ø§Ø² Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§
points = np.array([
    Point(x, y) 
    for x, y in zip(np.random.rand(1000) * 100, np.random.rand(1000) * 100)
])

polygons = np.array([
    box(x, y, x + 2, y + 2)
    for x, y in zip(np.random.rand(100) * 98, np.random.rand(100) * 98)
])

print(f"Points shape: {points.shape}")
print(f"Polygons shape: {polygons.shape}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¹Ù…Ù„ÛŒØ§Øª vectorized
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø³Ø§Ø­Øª Ù‡Ù…Ù‡ polygonâ€ŒÙ‡Ø§
areas = shapely.area(polygons)
print(f"Areas: {areas[:5]}")

# Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø·ÙˆÙ„ Ù‡Ù…Ù‡ Ø®Ø·ÙˆØ·
lines = np.array([
    LineString([(0, 0), (x, y)])
    for x, y in zip(np.random.rand(1000) * 100, np.random.rand(1000) * 100)
])
lengths = shapely.length(lines)
print(f"Mean length: {np.mean(lengths):.2f}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Buffer vectorized
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# buffer Ù‡Ù…Ù‡ Ù†Ù‚Ø§Ø·
buffered_points = shapely.buffer(points, 1.0)
print(f"Buffered type: {type(buffered_points)}")
print(f"First buffer area: {shapely.area(buffered_points[0]):.4f}")

# buffer Ø¨Ø§ Ù…Ù‚Ø§Ø¯ÛŒØ± Ù…Ø®ØªÙ„Ù
radii = np.random.rand(len(points)) * 2 + 0.5
buffered_varied = shapely.buffer(points, radii)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø±ÙˆØ§Ø¨Ø· Ù…Ú©Ø§Ù†ÛŒ vectorized
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

search_area = box(40, 40, 60, 60)

# Ø¨Ø±Ø±Ø³ÛŒ ØªÙ‚Ø§Ø·Ø¹ Ù‡Ù…Ù‡ Ù†Ù‚Ø§Ø· Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯Ù‡
intersects_mask = shapely.intersects(points, search_area)
points_inside = points[intersects_mask]
print(f"Points inside: {len(points_inside)}")

# Ø¨Ø±Ø±Ø³ÛŒ contains
contains_mask = shapely.contains(polygons, Point(50, 50))
print(f"Polygons containing point: {np.sum(contains_mask)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ÙØ§ØµÙ„Ù‡ vectorized
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

target = Point(50, 50)

# ÙØ§ØµÙ„Ù‡ Ù‡Ù…Ù‡ Ù†Ù‚Ø§Ø· ØªØ§ Ù‡Ø¯Ù
distances = shapely.distance(points, target)
print(f"Min distance: {np.min(distances):.4f}")
print(f"Max distance: {np.max(distances):.4f}")

# Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡
nearest_idx = np.argmin(distances)
print(f"Nearest point: {points[nearest_idx]}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø¹Ù…Ù„ÛŒØ§Øª Ù…Ø¬Ù…ÙˆØ¹Ù‡â€ŒØ§ÛŒ vectorized
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

poly1 = np.array([box(0, 0, 2, 2), box(1, 1, 3, 3), box(2, 2, 4, 4)])
poly2 = np.array([box(1, 0, 3, 2), box(2, 1, 4, 3), box(3, 2, 5, 4)])

# Ø§Ø´ØªØ±Ø§Ú©
intersections = shapely.intersection(poly1, poly2)
print(f"Intersection areas: {shapely.area(intersections)}")

# Ø§Ø¬ØªÙ…Ø§Ø¹
unions = shapely.union(poly1, poly2)
print(f"Union areas: {shapely.area(unions)}")

# ØªÙØ§Ø¶Ù„
differences = shapely.difference(poly1, poly2)
print(f"Difference areas: {shapely.area(differences)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø®ØªØµØ§Øª vectorized
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ø¯Ø±ÛŒØ§ÙØª Ù…Ø®ØªØµØ§Øª x, y
x_coords = shapely.get_x(points)
y_coords = shapely.get_y(points)
print(f"X range: {np.min(x_coords):.2f} - {np.max(x_coords):.2f}")

# Ø¯Ø±ÛŒØ§ÙØª bounds
bounds = shapely.bounds(polygons)
print(f"Bounds shape: {bounds.shape}")  # (n, 4)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø³Ø±Ø¹Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import time

n = 10000
points_large = np.array([Point(x, y) for x, y in np.random.rand(n, 2) * 100])

# Ø±ÙˆØ´ vectorized
start = time.time()
areas_vec = shapely.area(shapely.buffer(points_large, 1.0))
vec_time = time.time() - start

# Ø±ÙˆØ´ loop
start = time.time()
areas_loop = np.array([p.buffer(1.0).area for p in points_large])
loop_time = time.time() - start

print(f"Vectorized: {vec_time*1000:.2f} ms")
print(f"Loop: {loop_time*1000:.2f} ms")
print(f"Speedup: {loop_time/vec_time:.1f}x")</code></pre>
                </div>
            </div>

            <h3>ğŸ”§ ØªØ¨Ø¯ÛŒÙ„ Ù…Ø®ØªØµØ§Øª</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>coordinate_transform.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from shapely import Point, Polygon
from shapely.ops import transform
import math

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ¨Ø¯ÛŒÙ„ Ù…Ø®ØªØµØ§Øª Ø¨Ø§ ØªØ§Ø¨Ø¹
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polygon = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])

# ØªØ§Ø¨Ø¹ ØªØ¨Ø¯ÛŒÙ„ Ø³Ø§Ø¯Ù‡ (Ù…Ù‚ÛŒØ§Ø³)
def scale_coords(x, y, factor=2):
    return x * factor, y * factor

# Ø§Ø¹Ù…Ø§Ù„ ØªØ¨Ø¯ÛŒÙ„
scaled = transform(lambda x, y: scale_coords(x, y, 2), polygon)
print(f"Original area: {polygon.area}")
print(f"Scaled area: {scaled.area}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ø§ pyproj (ØªØºÛŒÛŒØ± CRS)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from pyproj import Transformer
    
    # ØªØ¨Ø¯ÛŒÙ„ Ø§Ø² WGS84 Ø¨Ù‡ UTM Zone 39N
    transformer = Transformer.from_crs("EPSG:4326", "EPSG:32639", always_xy=True)
    
    # Ù†Ù‚Ø·Ù‡ Ø¯Ø± ØªÙ‡Ø±Ø§Ù† (WGS84)
    point_wgs84 = Point(51.3890, 35.6892)
    
    # ØªØ¨Ø¯ÛŒÙ„
    point_utm = transform(transformer.transform, point_wgs84)
    print(f"WGS84: {point_wgs84}")
    print(f"UTM: {point_utm}")
    
    # ØªØ¨Ø¯ÛŒÙ„ polygon
    iran_bounds = Polygon([
        (44, 25), (63, 25), (63, 40), (44, 40)
    ])
    iran_utm = transform(transformer.transform, iran_bounds)
    print(f"Iran bounds area (UTM): {iran_utm.area / 1e6:.0f} kmÂ²")
    
except ImportError:
    print("pyproj not installed. Install with: pip install pyproj")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ¨Ø¯ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø±Ø§ÛŒØ¬
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ØªØ¨Ø¯ÛŒÙ„ Ø¯Ø±Ø¬Ù‡ Ø¨Ù‡ Ø±Ø§Ø¯ÛŒØ§Ù†
def degrees_to_radians(x, y):
    return math.radians(x), math.radians(y)

# ØªØ¨Ø¯ÛŒÙ„ Ù…ØªØ± Ø¨Ù‡ Ú©ÛŒÙ„ÙˆÙ…ØªØ±
def meters_to_km(x, y):
    return x / 1000, y / 1000

# Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ
def translate_coords(x, y, dx=10, dy=20):
    return x + dx, y + dy

# Ú†Ø±Ø®Ø´ Ø­ÙˆÙ„ Ù…Ø¨Ø¯Ø£
def rotate_coords(x, y, angle_deg):
    angle_rad = math.radians(angle_deg)
    cos_a = math.cos(angle_rad)
    sin_a = math.sin(angle_rad)
    return x * cos_a - y * sin_a, x * sin_a + y * cos_a

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ØªØ¨Ø¯ÛŒÙ„ Ø¨Ø§ NumPy (Ø³Ø±ÛŒØ¹â€ŒØªØ±)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import numpy as np

def transform_with_numpy(geometry, transform_func):
    """ØªØ¨Ø¯ÛŒÙ„ Ù…Ø®ØªØµØ§Øª Ø¨Ø§ NumPy"""
    coords = np.array(geometry.exterior.coords)
    transformed = transform_func(coords)
    return Polygon(transformed)

def numpy_scale(coords, factor=2):
    return coords * factor

def numpy_rotate(coords, angle_deg):
    angle_rad = np.radians(angle_deg)
    rotation_matrix = np.array([
        [np.cos(angle_rad), -np.sin(angle_rad)],
        [np.sin(angle_rad), np.cos(angle_rad)]
    ])
    return coords @ rotation_matrix.T

# Ù…Ø«Ø§Ù„
polygon = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])
rotated = transform_with_numpy(polygon, lambda c: numpy_rotate(c, 45))
print(f"Rotated polygon: {rotated}")</code></pre>
                </div>
            </div>

            <h3>ğŸ“Š Ø§Ø¯ØºØ§Ù… Ø¨Ø§ GeoPandas</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>geopandas_integration.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">try:
    import geopandas as gpd
    from shapely import Point, Polygon
    from shapely.geometry import box
    import pandas as pd
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø§ÛŒØ¬Ø§Ø¯ GeoDataFrame Ø§Ø² Shapely
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    # Ù„ÛŒØ³Øª Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§
    geometries = [
        Point(51.3890, 35.6892),
        Point(51.6680, 32.6546),
        Point(52.5837, 29.5918)
    ]
    
    # Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªÙˆØµÛŒÙÛŒ
    data = {
        'name': ['ØªÙ‡Ø±Ø§Ù†', 'Ø§ØµÙÙ‡Ø§Ù†', 'Ø´ÛŒØ±Ø§Ø²'],
        'population': [8700000, 2000000, 1500000]
    }
    
    # Ø§ÛŒØ¬Ø§Ø¯ GeoDataFrame
    gdf = gpd.GeoDataFrame(data, geometry=geometries, crs="EPSG:4326")
    print(gdf)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªÙˆØ§Ø¨Ø¹ Shapely Ø¯Ø± GeoPandas
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    # Buffer
    gdf['buffer_5km'] = gdf.geometry.buffer(0.05)  # ØªÙ‚Ø±ÛŒØ¨ÛŒ
    
    # Ù…Ø³Ø§Ø­Øª (Ù†ÛŒØ§Ø² Ø¨Ù‡ CRS Ù…ØªØ±ÛŒ)
    gdf_utm = gdf.to_crs("EPSG:32639")
    gdf_utm['area_km2'] = gdf_utm.geometry.buffer(5000).area / 1e6
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø¹Ù…Ù„ÛŒØ§Øª Ù…Ú©Ø§Ù†ÛŒ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    # Ø§ÛŒØ¬Ø§Ø¯ polygonâ€ŒÙ‡Ø§ÛŒ Ù…Ù†Ø·Ù‚Ù‡
    regions = gpd.GeoDataFrame({
        'region': ['Ø´Ù…Ø§Ù„', 'Ø¬Ù†ÙˆØ¨'],
        'geometry': [
            box(50, 34, 53, 37),
            box(50, 28, 53, 34)
        ]
    }, crs="EPSG:4326")
    
    # Spatial Join
    joined = gpd.sjoin(gdf, regions, how='left', predicate='within')
    print(joined[['name', 'region']])
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ØªØ¨Ø¯ÛŒÙ„ Ø¨ÛŒÙ† Shapely Ùˆ GeoPandas
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    # Ø§Ø² GeoDataFrame Ø¨Ù‡ Shapely
    all_points = gdf.geometry.unary_union  # MultiPoint
    
    # Ø§Ø² Shapely Ø¨Ù‡ GeoDataFrame
    polygon = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])
    gdf_single = gpd.GeoDataFrame(
        {'id': [1], 'name': ['Ù…Ø±Ø¨Ø¹']},
        geometry=[polygon],
        crs="EPSG:4326"
    )
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø°Ø®ÛŒØ±Ù‡ Ùˆ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
# Ø°Ø®ÛŒØ±Ù‡ Ø¨Ù‡ GeoJSON
    gdf.to_file('cities.geojson', driver='GeoJSON')
    
    # Ø°Ø®ÛŒØ±Ù‡ Ø¨Ù‡ Shapefile
    gdf.to_file('cities.shp')
    
    # Ø°Ø®ÛŒØ±Ù‡ Ø¨Ù‡ GeoPackage
    gdf.to_file('cities.gpkg', driver='GPKG')
    
    # Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ
    gdf_loaded = gpd.read_file('cities.geojson')
    print(f"Loaded {len(gdf_loaded)} features")
    
except ImportError:
    print("GeoPandas not installed. Install with: pip install geopandas")</code></pre>
                </div>
            </div>
        </section>

        <!-- Section 10: Projects -->
        <section class="section" id="projects">
            <div class="section-header">
                <div class="section-icon">ğŸ¯</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ø¯Ù‡Ù…</div>
                    <h2 class="section-title">Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ</h2>
                    <p class="section-subtitle">Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±Ø¯ÛŒ Ø¨Ø§ Shapely</p>
                </div>
            </div>

            <h3>ğŸ¥ Ù¾Ø±ÙˆÚ˜Ù‡ Û±: ØªØ­Ù„ÛŒÙ„ Ù¾ÙˆØ´Ø´ Ø®Ø¯Ù…Ø§Øª Ø¨Ù‡Ø¯Ø§Ø´ØªÛŒ</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>healthcare_coverage.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">"""
Ù¾Ø±ÙˆÚ˜Ù‡ ØªØ­Ù„ÛŒÙ„ Ù¾ÙˆØ´Ø´ Ø®Ø¯Ù…Ø§Øª Ø¨Ù‡Ø¯Ø§Ø´ØªÛŒ
- ØªØ¹ÛŒÛŒÙ† Ø­ÙˆØ²Ù‡ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†â€ŒÙ‡Ø§
- Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù…Ù†Ø§Ø·Ù‚ Ú©Ù…â€ŒØ¨Ø±Ø®ÙˆØ±Ø¯Ø§Ø±
- Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù† Ø¬Ø¯ÛŒØ¯
"""

from shapely import Point, Polygon
from shapely.geometry import box, MultiPoint
from shapely.ops import unary_union, voronoi_diagram, nearest_points
from shapely.strtree import STRtree
import json

class HealthcareCoverageAnalyzer:
    def __init__(self, study_area: Polygon):
        """
        ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø± Ù¾ÙˆØ´Ø´ Ø®Ø¯Ù…Ø§Øª Ø¨Ù‡Ø¯Ø§Ø´ØªÛŒ
        
        Args:
            study_area: Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ø·Ø§Ù„Ø¹Ù‡
        """
        self.study_area = study_area
        self.hospitals = []
        self.population_points = []
    
    def add_hospital(self, location: Point, name: str, beds: int):
        """Ø§ÙØ²ÙˆØ¯Ù† Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†"""
        self.hospitals.append({
            'geometry': location,
            'name': name,
            'beds': beds
        })
    
    def add_population_point(self, location: Point, population: int, name: str = None):
        """Ø§ÙØ²ÙˆØ¯Ù† Ù†Ù‚Ø·Ù‡ Ø¬Ù…Ø¹ÛŒØªÛŒ"""
        self.population_points.append({
            'geometry': location,
            'population': population,
            'name': name
        })
    
    def create_service_areas(self, radius: float) -> list:
        """
        Ø§ÛŒØ¬Ø§Ø¯ Ù…Ù†Ø§Ø·Ù‚ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ Ø¨Ø§ buffer
        
        Args:
            radius: Ø´Ø¹Ø§Ø¹ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ
            
        Returns:
            Ù„ÛŒØ³Øª buffer Ù‡Ø§ÛŒ Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†â€ŒÙ‡Ø§
        """
        service_areas = []
        for hospital in self.hospitals:
            buffer = hospital['geometry'].buffer(radius)
            # Ø¨Ø±Ø´ Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ø·Ø§Ù„Ø¹Ù‡
            clipped = buffer.intersection(self.study_area)
            service_areas.append({
                'geometry': clipped,
                'hospital': hospital['name'],
                'area': clipped.area
            })
        return service_areas
    
    def create_voronoi_catchments(self) -> list:
        """
        Ø§ÛŒØ¬Ø§Ø¯ Ø­ÙˆØ²Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ Ø¨Ø§ Voronoi
        
        Returns:
            Ù„ÛŒØ³Øª Ø­ÙˆØ²Ù‡â€ŒÙ‡Ø§ÛŒ Voronoi
        """
        if len(self.hospitals) < 2:
            return []
        
        # Ù†Ù‚Ø§Ø· Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†â€ŒÙ‡Ø§
        hospital_points = MultiPoint([h['geometry'] for h in self.hospitals])
        
        # Ù†Ù…ÙˆØ¯Ø§Ø± Voronoi
        voronoi = voronoi_diagram(hospital_points, envelope=self.study_area)
        
        catchments = []
        for i, cell in enumerate(voronoi.geoms):
            # Ø¨Ø±Ø´ Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ø·Ø§Ù„Ø¹Ù‡
            clipped = cell.intersection(self.study_area)
            if not clipped.is_empty:
                catchments.append({
                    'geometry': clipped,
                    'hospital': self.hospitals[i]['name'],
                    'area': clipped.area
                })
        
        return catchments
    
    def calculate_coverage(self, service_radius: float) -> dict:
        """
        Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø±ØµØ¯ Ù¾ÙˆØ´Ø´
        
        Args:
            service_radius: Ø´Ø¹Ø§Ø¹ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ
            
        Returns:
            Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¢Ù…Ø§Ø± Ù¾ÙˆØ´Ø´
        """
        # Ø§Ø¬ØªÙ…Ø§Ø¹ Ù‡Ù…Ù‡ Ù…Ù†Ø§Ø·Ù‚ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ
        all_buffers = [h['geometry'].buffer(service_radius) for h in self.hospitals]
        combined_coverage = unary_union(all_buffers)
        
        # Ø¨Ø±Ø´ Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ø·Ø§Ù„Ø¹Ù‡
        coverage_in_area = combined_coverage.intersection(self.study_area)
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø±ØµØ¯
        total_area = self.study_area.area
        covered_area = coverage_in_area.area
        coverage_percent = (covered_area / total_area) * 100
        
        return {
            'total_area': total_area,
            'covered_area': covered_area,
            'uncovered_area': total_area - covered_area,
            'coverage_percent': round(coverage_percent, 2),
            'coverage_geometry': coverage_in_area
        }
    
    def find_underserved_areas(self, service_radius: float) -> Polygon:
        """
        ÛŒØ§ÙØªÙ† Ù…Ù†Ø§Ø·Ù‚ Ú©Ù…â€ŒØ¨Ø±Ø®ÙˆØ±Ø¯Ø§Ø±
        
        Args:
            service_radius: Ø´Ø¹Ø§Ø¹ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ
            
        Returns:
            Ù‡Ù†Ø¯Ø³Ù‡ Ù…Ù†Ø§Ø·Ù‚ Ú©Ù…â€ŒØ¨Ø±Ø®ÙˆØ±Ø¯Ø§Ø±
        """
        coverage = self.calculate_coverage(service_radius)
        underserved = self.study_area.difference(coverage['coverage_geometry'])
        return underserved
    
    def analyze_population_access(self, service_radius: float) -> dict:
        """
        ØªØ­Ù„ÛŒÙ„ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¬Ù…Ø¹ÛŒØª Ø¨Ù‡ Ø®Ø¯Ù…Ø§Øª
        
        Args:
            service_radius: Ø´Ø¹Ø§Ø¹ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ
            
        Returns:
            Ø¢Ù…Ø§Ø± Ø¯Ø³ØªØ±Ø³ÛŒ Ø¬Ù…Ø¹ÛŒØª
        """
        coverage = self.calculate_coverage(service_radius)
        coverage_geom = coverage['coverage_geometry']
        
        covered_population = 0
        uncovered_population = 0
        covered_points = []
        uncovered_points = []
        
        for pop in self.population_points:
            if coverage_geom.contains(pop['geometry']):
                covered_population += pop['population']
                covered_points.append(pop)
            else:
                uncovered_population += pop['population']
                uncovered_points.append(pop)
        
        total_population = covered_population + uncovered_population
        
        return {
            'total_population': total_population,
            'covered_population': covered_population,
            'uncovered_population': uncovered_population,
            'coverage_percent': round((covered_population / total_population) * 100, 2) if total_population > 0 else 0,
            'covered_points': covered_points,
            'uncovered_points': uncovered_points
        }
    
    def find_nearest_hospital(self, location: Point) -> dict:
        """
        ÛŒØ§ÙØªÙ† Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†
        
        Args:
            location: Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø±
            
        Returns:
            Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†
        """
        min_dist = float('inf')
        nearest = None
        
        for hospital in self.hospitals:
            dist = location.distance(hospital['geometry'])
            if dist < min_dist:
                min_dist = dist
                nearest = hospital
        
        return {
            'hospital': nearest,
            'distance': min_dist
        }
    
    def suggest_new_hospital_location(self, service_radius: float) -> Point:
        """
        Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù† Ø¬Ø¯ÛŒØ¯
        
        Args:
            service_radius: Ø´Ø¹Ø§Ø¹ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ
            
        Returns:
            Ù†Ù‚Ø·Ù‡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ
        """
        underserved = self.find_underserved_areas(service_radius)
        
        if underserved.is_empty:
            return None
        
        # Ù…Ø±Ú©Ø² ÙˆØ²Ù†â€ŒØ¯Ø§Ø± Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¬Ù…Ø¹ÛŒØª Ú©Ù…â€ŒØ¨Ø±Ø®ÙˆØ±Ø¯Ø§Ø±
        pop_access = self.analyze_population_access(service_radius)
        uncovered = pop_access['uncovered_points']
        
        if not uncovered:
            # Ø§Ú¯Ø± Ù†Ù‚Ø·Ù‡ Ø¬Ù…Ø¹ÛŒØªÛŒ Ú©Ù…â€ŒØ¨Ø±Ø®ÙˆØ±Ø¯Ø§Ø± Ù†Ø¨ÙˆØ¯ØŒ Ù…Ø±Ú©Ø² Ù…Ù†Ø·Ù‚Ù‡ Ú©Ù…â€ŒØ¨Ø±Ø®ÙˆØ±Ø¯Ø§Ø±
            return underserved.centroid
        
        # Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ÙˆØ²Ù†â€ŒØ¯Ø§Ø±
        total_weight = sum(p['population'] for p in uncovered)
        weighted_x = sum(p['geometry'].x * p['population'] for p in uncovered) / total_weight
        weighted_y = sum(p['geometry'].y * p['population'] for p in uncovered) / total_weight
        
        suggested = Point(weighted_x, weighted_y)
        
        # Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØªÙ† Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ø·Ø§Ù„Ø¹Ù‡
        if not self.study_area.contains(suggested):
            suggested = underserved.representative_point()
        
        return suggested
    
    def generate_report(self, service_radius: float) -> dict:
        """
        ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ú©Ø§Ù…Ù„
        
        Args:
            service_radius: Ø´Ø¹Ø§Ø¹ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ
            
        Returns:
            Ú¯Ø²Ø§Ø±Ø´ Ú©Ø§Ù…Ù„ ØªØ­Ù„ÛŒÙ„
        """
        coverage = self.calculate_coverage(service_radius)
        pop_access = self.analyze_population_access(service_radius)
        suggestion = self.suggest_new_hospital_location(service_radius)
        
        return {
            'summary': {
                'total_hospitals': len(self.hospitals),
                'total_beds': sum(h['beds'] for h in self.hospitals),
                'service_radius': service_radius,
                'area_coverage_percent': coverage['coverage_percent'],
                'population_coverage_percent': pop_access['coverage_percent']
            },
            'coverage': coverage,
            'population_access': pop_access,
            'suggested_location': {
                'geometry': suggestion,
                'coordinates': (suggestion.x, suggestion.y) if suggestion else None
            }
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©Ù„Ø§Ø³
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    # Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ø·Ø§Ù„Ø¹Ù‡ (ÛŒÚ© Ø´Ù‡Ø± ÙØ±Ø¶ÛŒ)
    city_bounds = box(0, 0, 20, 20)
    
    # Ø§ÛŒØ¬Ø§Ø¯ ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø±
    analyzer = HealthcareCoverageAnalyzer(city_bounds)
    
    # Ø§ÙØ²ÙˆØ¯Ù† Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†â€ŒÙ‡Ø§
    analyzer.add_hospital(Point(3, 3), "Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù† Ø§Ù…Ø§Ù…", 200)
    analyzer.add_hospital(Point(15, 5), "Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù† Ø´Ø±ÛŒØ¹ØªÛŒ", 150)
    analyzer.add_hospital(Point(10, 15), "Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù† Ù…ÛŒÙ„Ø§Ø¯", 300)
    
    # Ø§ÙØ²ÙˆØ¯Ù† Ù†Ù‚Ø§Ø· Ø¬Ù…Ø¹ÛŒØªÛŒ
    population_data = [
        (2, 2, 5000, "Ù…Ø­Ù„Ù‡ Û±"),
        (5, 5, 8000, "Ù…Ø­Ù„Ù‡ Û²"),
        (10, 3, 6000, "Ù…Ø­Ù„Ù‡ Û³"),
        (15, 10, 4000, "Ù…Ø­Ù„Ù‡ Û´"),
        (18, 18, 7000, "Ù…Ø­Ù„Ù‡ Ûµ"),
        (3, 15, 3000, "Ù…Ø­Ù„Ù‡ Û¶"),
        (8, 8, 9000, "Ù…Ø­Ù„Ù‡ Û·"),
    ]
    
    for x, y, pop, name in population_data:
        analyzer.add_population_point(Point(x, y), pop, name)
    
    # ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´
    report = analyzer.generate_report(service_radius=5)
    
    print("=" * 60)
    print("Ú¯Ø²Ø§Ø±Ø´ ØªØ­Ù„ÛŒÙ„ Ù¾ÙˆØ´Ø´ Ø®Ø¯Ù…Ø§Øª Ø¨Ù‡Ø¯Ø§Ø´ØªÛŒ")
    print("=" * 60)
    print(f"\nğŸ“Š Ø®Ù„Ø§ØµÙ‡:")
    print(f"  ØªØ¹Ø¯Ø§Ø¯ Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†: {report['summary']['total_hospitals']}")
    print(f"  Ù…Ø¬Ù…ÙˆØ¹ ØªØ®Øª: {report['summary']['total_beds']}")
    print(f"  Ø´Ø¹Ø§Ø¹ Ø®Ø¯Ù…Ø§Øªâ€ŒØ±Ø³Ø§Ù†ÛŒ: {report['summary']['service_radius']} ÙˆØ§Ø­Ø¯")
    print(f"  Ù¾ÙˆØ´Ø´ Ù…Ø³Ø§Ø­ØªÛŒ: {report['summary']['area_coverage_percent']}%")
    print(f"  Ù¾ÙˆØ´Ø´ Ø¬Ù…Ø¹ÛŒØªÛŒ: {report['summary']['population_coverage_percent']}%")
    
    print(f"\nğŸ¥ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù† Ø¬Ø¯ÛŒØ¯:")
    if report['suggested_location']['coordinates']:
        x, y = report['suggested_location']['coordinates']
        print(f"  Ù…Ø®ØªØµØ§Øª: ({x:.2f}, {y:.2f})")
    else:
        print("  Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù† Ø¬Ø¯ÛŒØ¯ Ù†ÛŒØ³Øª")</code></pre>
                </div>
            </div>

            <h3>ğŸ—ºï¸ Ù¾Ø±ÙˆÚ˜Ù‡ Û²: ØªØ­Ù„ÛŒÙ„ Ø²Ù…ÛŒÙ† Ø´Ù‡Ø±ÛŒ</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>land_use_analysis.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">"""
Ù¾Ø±ÙˆÚ˜Ù‡ ØªØ­Ù„ÛŒÙ„ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø²Ù…ÛŒÙ† Ø´Ù‡Ø±ÛŒ
- Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø³Ø§Ø­Øª Ú©Ø§Ø±Ø¨Ø±ÛŒâ€ŒÙ‡Ø§
- ØªØ­Ù„ÛŒÙ„ Ù‡Ù…Ø³Ø§ÛŒÚ¯ÛŒ
- ÛŒØ§ÙØªÙ† Ù‚Ø·Ø¹Ø§Øª Ù…Ù†Ø§Ø³Ø¨ Ø¨Ø±Ø§ÛŒ ØªÙˆØ³Ø¹Ù‡
"""

from shapely import Point, Polygon, LineString
from shapely.geometry import box, MultiPolygon
from shapely.ops import unary_union
from shapely.strtree import STRtree
from typing import List, Dict, Optional
from dataclasses import dataclass
from enum import Enum

class LandUseType(Enum):
    RESIDENTIAL = "Ù…Ø³Ú©ÙˆÙ†ÛŒ"
    COMMERCIAL = "ØªØ¬Ø§Ø±ÛŒ"
    INDUSTRIAL = "ØµÙ†Ø¹ØªÛŒ"
    GREEN_SPACE = "ÙØ¶Ø§ÛŒ Ø³Ø¨Ø²"
    EDUCATIONAL = "Ø¢Ù…ÙˆØ²Ø´ÛŒ"
    HEALTHCARE = "Ø¨Ù‡Ø¯Ø§Ø´ØªÛŒ"
    VACANT = "Ø¨Ø§ÛŒØ±"
    ROAD = "Ù…Ø¹Ø¨Ø±"

@dataclass
class Parcel:
    """Ù‚Ø·Ø¹Ù‡ Ø²Ù…ÛŒÙ†"""
    id: int
    geometry: Polygon
    land_use: LandUseType
    owner: Optional[str] = None
    
    @property
    def area(self) -> float:
        return self.geometry.area
    
    @property
    def perimeter(self) -> float:
        return self.geometry.length
    
    @property
    def centroid(self) -> Point:
        return self.geometry.centroid

class LandUseAnalyzer:
    def __init__(self, boundary: Polygon):
        """
        ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø± Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø²Ù…ÛŒÙ†
        
        Args:
            boundary: Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø´Ù‡Ø±
        """
        self.boundary = boundary
        self.parcels: List[Parcel] = []
        self._tree: Optional[STRtree] = None
    
    def add_parcel(self, parcel: Parcel):
        """Ø§ÙØ²ÙˆØ¯Ù† Ù‚Ø·Ø¹Ù‡"""
        self.parcels.append(parcel)
        self._tree = None  # Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ø§ÛŒÙ†Ø¯Ú©Ø³
    
    def _build_tree(self):
        """Ø³Ø§Ø®Øª Ø§ÛŒÙ†Ø¯Ú©Ø³ Ù…Ú©Ø§Ù†ÛŒ"""
        if self._tree is None:
            geometries = [p.geometry for p in self.parcels]
            self._tree = STRtree(geometries)
    
    def get_land_use_statistics(self) -> Dict:
        """
        Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±ÛŒâ€ŒÙ‡Ø§
        
        Returns:
            Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¢Ù…Ø§Ø± Ù‡Ø± Ú©Ø§Ø±Ø¨Ø±ÛŒ
        """
        stats = {}
        total_area = sum(p.area for p in self.parcels)
        
        for land_use in LandUseType:
            parcels_of_type = [p for p in self.parcels if p.land_use == land_use]
            area = sum(p.area for p in parcels_of_type)
            
            stats[land_use.value] = {
                'count': len(parcels_of_type),
                'total_area': area,
                'percentage': (area / total_area * 100) if total_area > 0 else 0,
                'average_area': area / len(parcels_of_type) if parcels_of_type else 0
            }
        
        return stats
    
    def find_neighbors(self, parcel: Parcel, buffer_distance: float = 0) -> List[Parcel]:
        """
        ÛŒØ§ÙØªÙ† Ù‡Ù…Ø³Ø§ÛŒÚ¯Ø§Ù† ÛŒÚ© Ù‚Ø·Ø¹Ù‡
        
        Args:
            parcel: Ù‚Ø·Ø¹Ù‡ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø±
            buffer_distance: ÙØ§ØµÙ„Ù‡ buffer Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ø³Ø§ÛŒÚ¯ÛŒ
            
        Returns:
            Ù„ÛŒØ³Øª Ù‚Ø·Ø¹Ø§Øª Ù‡Ù…Ø³Ø§ÛŒÙ‡
        """
        self._build_tree()
        
        search_geom = parcel.geometry.buffer(buffer_distance) if buffer_distance > 0 else parcel.geometry
        
        # Ø¬Ø³ØªØ¬ÙˆÛŒ Ø³Ø±ÛŒØ¹
        candidate_indices = self._tree.query(search_geom)
        
        neighbors = []
        for idx in candidate_indices:
            candidate = self.parcels[idx]
            if candidate.id != parcel.id:
                if buffer_distance > 0:
                    if candidate.geometry.intersects(search_geom):
                        neighbors.append(candidate)
                else:
                    if candidate.geometry.touches(parcel.geometry) or candidate.geometry.intersects(parcel.geometry):
                        neighbors.append(candidate)
        
        return neighbors
    
    def find_parcels_by_land_use(self, land_use: LandUseType) -> List[Parcel]:
        """ÛŒØ§ÙØªÙ† Ù‚Ø·Ø¹Ø§Øª Ø¨Ø§ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ù…Ø´Ø®Øµ"""
        return [p for p in self.parcels if p.land_use == land_use]
    
    def find_vacant_for_development(
        self, 
        min_area: float,
        required_neighbors: List[LandUseType] = None,
        forbidden_neighbors: List[LandUseType] = None
    ) -> List[Parcel]:
        """
        ÛŒØ§ÙØªÙ† Ù‚Ø·Ø¹Ø§Øª Ø¨Ø§ÛŒØ± Ù…Ù†Ø§Ø³Ø¨ Ø¨Ø±Ø§ÛŒ ØªÙˆØ³Ø¹Ù‡
        
        Args:
            min_area: Ø­Ø¯Ø§Ù‚Ù„ Ù…Ø³Ø§Ø­Øª
            required_neighbors: Ú©Ø§Ø±Ø¨Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ù‡Ù…Ø³Ø§ÛŒÙ‡ Ø§Ù„Ø²Ø§Ù…ÛŒ
            forbidden_neighbors: Ú©Ø§Ø±Ø¨Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ù‡Ù…Ø³Ø§ÛŒÙ‡ Ù…Ù…Ù†ÙˆØ¹
            
        Returns:
            Ù„ÛŒØ³Øª Ù‚Ø·Ø¹Ø§Øª Ù…Ù†Ø§Ø³Ø¨
        """
        vacant_parcels = self.find_parcels_by_land_use(LandUseType.VACANT)
        suitable = []
        
        for parcel in vacant_parcels:
            # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø³Ø§Ø­Øª
            if parcel.area < min_area:
                continue
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ù‡Ù…Ø³Ø§ÛŒÚ¯Ø§Ù†
            neighbors = self.find_neighbors(parcel, buffer_distance=1)
            neighbor_types = {n.land_use for n in neighbors}
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ù‡Ù…Ø³Ø§ÛŒÚ¯Ø§Ù† Ø§Ù„Ø²Ø§Ù…ÛŒ
            if required_neighbors:
                if not all(req in neighbor_types for req in required_neighbors):
                    continue
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ù‡Ù…Ø³Ø§ÛŒÚ¯Ø§Ù† Ù…Ù…Ù†ÙˆØ¹
            if forbidden_neighbors:
                if any(forb in neighbor_types for forb in forbidden_neighbors):
                    continue
            
            suitable.append(parcel)
        
        return suitable
    
    def calculate_green_space_per_capita(self, population: int) -> float:
        """
        Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø±Ø§Ù†Ù‡ ÙØ¶Ø§ÛŒ Ø³Ø¨Ø²
        
        Args:
            population: Ø¬Ù…Ø¹ÛŒØª
            
        Returns:
            Ø³Ø±Ø§Ù†Ù‡ ÙØ¶Ø§ÛŒ Ø³Ø¨Ø² (Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø¨Ù‡ Ø§Ø²Ø§ÛŒ Ù‡Ø± Ù†ÙØ±)
        """
        green_spaces = self.find_parcels_by_land_use(LandUseType.GREEN_SPACE)
        total_green = sum(p.area for p in green_spaces)
        return total_green / population if population > 0 else 0
    
    def find_parcels_near_road(self, max_distance: float) -> List[Parcel]:
        """
        ÛŒØ§ÙØªÙ† Ù‚Ø·Ø¹Ø§Øª Ù†Ø²Ø¯ÛŒÚ© Ø¨Ù‡ Ù…Ø¹Ø¨Ø±
        
        Args:
            max_distance: Ø­Ø¯Ø§Ú©Ø«Ø± ÙØ§ØµÙ„Ù‡ Ø§Ø² Ù…Ø¹Ø¨Ø±
            
        Returns:
            Ù„ÛŒØ³Øª Ù‚Ø·Ø¹Ø§Øª Ù†Ø²Ø¯ÛŒÚ© Ù…Ø¹Ø¨Ø±
        """
        roads = self.find_parcels_by_land_use(LandUseType.ROAD)
        if not roads:
            return []
        
        # Ø§Ø¬ØªÙ…Ø§Ø¹ Ù‡Ù…Ù‡ Ù…Ø¹Ø§Ø¨Ø±
        all_roads = unary_union([r.geometry for r in roads])
        road_buffer = all_roads.buffer(max_distance)
        
        near_road = []
        for parcel in self.parcels:
            if parcel.land_use != LandUseType.ROAD:
                if parcel.geometry.intersects(road_buffer):
                    near_road.append(parcel)
        
        return near_road
    
    def merge_adjacent_parcels(self, parcels: List[Parcel]) -> Polygon:
        """
        Ø§Ø¯ØºØ§Ù… Ù‚Ø·Ø¹Ø§Øª Ù…Ø¬Ø§ÙˆØ±
        
        Args:
            parcels: Ù„ÛŒØ³Øª Ù‚Ø·Ø¹Ø§Øª
            
        Returns:
            Ù‡Ù†Ø¯Ø³Ù‡ Ø§Ø¯ØºØ§Ù… Ø´Ø¯Ù‡
        """
        geometries = [p.geometry for p in parcels]
        return unary_union(geometries)
    
    def generate_report(self, population: int) -> Dict:
        """
        ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ú©Ø§Ù…Ù„
        
        Args:
            population: Ø¬Ù…Ø¹ÛŒØª
            
        Returns:
            Ú¯Ø²Ø§Ø±Ø´ Ú©Ø§Ù…Ù„
        """
        stats = self.get_land_use_statistics()
        green_per_capita = self.calculate_green_space_per_capita(population)
        
        vacant_for_residential = self.find_vacant_for_development(
            min_area=500,
            forbidden_neighbors=[LandUseType.INDUSTRIAL]
        )
        
        return {
            'total_parcels': len(self.parcels),
            'total_area': sum(p.area for p in self.parcels),
            'land_use_statistics': stats,
            'green_space_per_capita': green_per_capita,
            'vacant_suitable_for_residential': len(vacant_for_residential),
            'population': population
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©Ù„Ø§Ø³
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    # Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø´Ù‡Ø±
    city = box(0, 0, 100, 100)
    
    # Ø§ÛŒØ¬Ø§Ø¯ ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø±
    analyzer = LandUseAnalyzer(city)
    
    # Ø§ÙØ²ÙˆØ¯Ù† Ù‚Ø·Ø¹Ø§Øª Ù†Ù…ÙˆÙ†Ù‡
    sample_parcels = [
        Parcel(1, box(0, 0, 20, 20), LandUseType.RESIDENTIAL),
        Parcel(2, box(20, 0, 40, 20), LandUseType.COMMERCIAL),
        Parcel(3, box(40, 0, 60, 20), LandUseType.INDUSTRIAL),
        Parcel(4, box(60, 0, 80, 20), LandUseType.VACANT),
        Parcel(5, box(80, 0, 100, 20), LandUseType.GREEN_SPACE),
        Parcel(6, box(0, 20, 30, 50), LandUseType.RESIDENTIAL),
        Parcel(7, box(30, 20, 60, 50), LandUseType.EDUCATIONAL),
        Parcel(8, box(60, 20, 100, 50), LandUseType.HEALTHCARE),
        Parcel(9, box(0, 50, 50, 80), LandUseType.GREEN_SPACE),
        Parcel(10, box(50, 50, 100, 80), LandUseType.VACANT),
        Parcel(11, box(0, 80, 100, 85), LandUseType.ROAD),
        Parcel(12, box(0, 85, 100, 100), LandUseType.RESIDENTIAL),
    ]
    
    for parcel in sample_parcels:
        analyzer.add_parcel(parcel)
    
    # ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´
    report = analyzer.generate_report(population=50000)
    
    print("=" * 60)
    print("Ú¯Ø²Ø§Ø±Ø´ ØªØ­Ù„ÛŒÙ„ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø²Ù…ÛŒÙ†")
    print("=" * 60)
    print(f"\nğŸ“Š Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ:")
    print(f"  ØªØ¹Ø¯Ø§Ø¯ Ù‚Ø·Ø¹Ø§Øª: {report['total_parcels']}")
    print(f"  Ù…Ø³Ø§Ø­Øª Ú©Ù„: {report['total_area']} ÙˆØ§Ø­Ø¯ Ù…Ø±Ø¨Ø¹")
    print(f"  Ø³Ø±Ø§Ù†Ù‡ ÙØ¶Ø§ÛŒ Ø³Ø¨Ø²: {report['green_space_per_capita']:.2f} ÙˆØ§Ø­Ø¯/Ù†ÙØ±")
    
    print(f"\nğŸ“ˆ Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±ÛŒâ€ŒÙ‡Ø§:")
    for land_use, stats in report['land_use_statistics'].items():
        if stats['count'] > 0:
            print(f"  {land_use}:")
            print(f"    ØªØ¹Ø¯Ø§Ø¯: {stats['count']}, Ù…Ø³Ø§Ø­Øª: {stats['total_area']:.0f}, Ø¯Ø±ØµØ¯: {stats['percentage']:.1f}%")</code></pre>
                </div>
            </div>

            <h3>ğŸš— Ù¾Ø±ÙˆÚ˜Ù‡ Û³: ØªØ­Ù„ÛŒÙ„ Ø´Ø¨Ú©Ù‡ Ù…Ø¹Ø§Ø¨Ø±</h3>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">PY</div>
                        <span>road_network.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">"""
Ù¾Ø±ÙˆÚ˜Ù‡ ØªØ­Ù„ÛŒÙ„ Ø´Ø¨Ú©Ù‡ Ù…Ø¹Ø§Ø¨Ø±
- Ø§ÛŒØ¬Ø§Ø¯ Ú¯Ø±Ø§Ù Ø´Ø¨Ú©Ù‡
- ÛŒØ§ÙØªÙ† Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø´Ø¨Ú©Ù‡
- ØªØ­Ù„ÛŒÙ„ Ø§ØªØµØ§Ù„â€ŒÙ¾Ø°ÛŒØ±ÛŒ
"""

from shapely import Point, LineString
from shapely.geometry import MultiLineString
from shapely.ops import unary_union, linemerge, nearest_points
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass
import math

@dataclass
class RoadSegment:
    """Ù‚Ø·Ø¹Ù‡ Ø¬Ø§Ø¯Ù‡"""
    id: int
    geometry: LineString
    name: str
    road_type: str  # highway, primary, secondary, residential
    speed_limit: float  # km/h
    
    @property
    def length(self) -> float:
        return self.geometry.length
    
    @property
    def travel_time(self) -> float:
        """Ø²Ù…Ø§Ù† Ø³ÙØ± Ø¨Ø± Ø­Ø³Ø¨ Ø¯Ù‚ÛŒÙ‚Ù‡"""
        return (self.length / 1000) / self.speed_limit * 60

class RoadNetworkAnalyzer:
    def __init__(self):
        """ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø± Ø´Ø¨Ú©Ù‡ Ù…Ø¹Ø§Ø¨Ø±"""
        self.segments: List[RoadSegment] = []
        self.nodes: Dict[Tuple[float, float], int] = {}
        self.edges: List[Dict] = []
    
    def add_segment(self, segment: RoadSegment):
        """Ø§ÙØ²ÙˆØ¯Ù† Ù‚Ø·Ø¹Ù‡ Ø¬Ø§Ø¯Ù‡"""
        self.segments.append(segment)
    
    def build_network(self):
        """Ø³Ø§Ø®Øª Ú¯Ø±Ø§Ù Ø´Ø¨Ú©Ù‡"""
        self.nodes = {}
        self.edges = []
        node_id = 0
        
        for segment in self.segments:
            coords = list(segment.geometry.coords)
            start = coords[0]
            end = coords[-1]
            
            # Ø§ÙØ²ÙˆØ¯Ù† Ú¯Ø±Ù‡â€ŒÙ‡Ø§
            if start not in self.nodes:
                self.nodes[start] = node_id
                node_id += 1
            
            if end not in self.nodes:
                self.nodes[end] = node_id
                node_id += 1
            
            # Ø§ÙØ²ÙˆØ¯Ù† ÛŒØ§Ù„
            self.edges.append({
                'start_node': self.nodes[start],
                'end_node': self.nodes[end],
                'segment': segment,
                'length': segment.length,
                'travel_time': segment.travel_time
            })
    
    def get_network_statistics(self) -> Dict:
        """Ø¢Ù…Ø§Ø± Ø´Ø¨Ú©Ù‡"""
        if not self.edges:
            self.build_network()
        
        total_length = sum(e['length'] for e in self.edges)
        
        # ØªØ¹Ø¯Ø§Ø¯ ÛŒØ§Ù„â€ŒÙ‡Ø§ÛŒ Ù‡Ø± Ú¯Ø±Ù‡ (Ø¯Ø±Ø¬Ù‡)
        node_degrees = {}
        for edge in self.edges:
            node_degrees[edge['start_node']] = node_degrees.get(edge['start_node'], 0) + 1
            node_degrees[edge['end_node']] = node_degrees.get(edge['end_node'], 0) + 1
        
        # Ú¯Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªÙ‡Ø§ÛŒÛŒ (Ø¯Ø±Ø¬Ù‡ Û±)
        dead_ends = sum(1 for d in node_degrees.values() if d == 1)
        
        # ØªÙ‚Ø§Ø·Ø¹â€ŒÙ‡Ø§ (Ø¯Ø±Ø¬Ù‡ > 2)
        intersections = sum(1 for d in node_degrees.values() if d > 2)
        
        return {
            'total_nodes': len(self.nodes),
            'total_edges': len(self.edges),
            'total_length': total_length,
            'dead_ends': dead_ends,
            'intersections': intersections,
            'average_segment_length': total_length / len(self.edges) if self.edges else 0
        }
    
    def snap_to_network(self, point: Point) -> Tuple[Point, RoadSegment, float]:
        """
        ÛŒØ§ÙØªÙ† Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø´Ø¨Ú©Ù‡
        
        Args:
            point: Ù†Ù‚Ø·Ù‡ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø±
            
        Returns:
            Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø´Ø¨Ú©Ù‡ØŒ Ù‚Ø·Ø¹Ù‡ØŒ ÙØ§ØµÙ„Ù‡
        """
        min_dist = float('inf')
        nearest_point = None
        nearest_segment = None
        
        for segment in self.segments:
            # Ù¾Ø±ÙˆØ¬Ú©Ø´Ù† Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø®Ø·
            dist = point.distance(segment.geometry)
            
            if dist < min_dist:
                min_dist = dist
                # Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø®Ø·
                proj_dist = segment.geometry.project(point)
                nearest_point = segment.geometry.interpolate(proj_dist)
                nearest_segment = segment
        
        return nearest_point, nearest_segment, min_dist
    
    def find_segments_in_buffer(self, point: Point, radius: float) -> List[RoadSegment]:
        """
        ÛŒØ§ÙØªÙ† Ù‚Ø·Ø¹Ø§Øª Ø¯Ø± Ø´Ø¹Ø§Ø¹ Ù…Ø´Ø®Øµ
        
        Args:
            point: Ù†Ù‚Ø·Ù‡ Ù…Ø±Ú©Ø²
            radius: Ø´Ø¹Ø§Ø¹ Ø¬Ø³ØªØ¬Ùˆ
            
        Returns:
            Ù„ÛŒØ³Øª Ù‚Ø·Ø¹Ø§Øª
        """
        buffer = point.buffer(radius)
        return [s for s in self.segments if s.geometry.intersects(buffer)]
    
    def calculate_accessibility(self, point: Point, max_distance: float) -> Dict:
        """
        Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Ø§Ø² ÛŒÚ© Ù†Ù‚Ø·Ù‡
        
        Args:
            point: Ù†Ù‚Ø·Ù‡ Ø´Ø±ÙˆØ¹
            max_distance: Ø­Ø¯Ø§Ú©Ø«Ø± ÙØ§ØµÙ„Ù‡
            
        Returns:
            Ø¢Ù…Ø§Ø± Ø¯Ø³ØªØ±Ø³ÛŒ
        """
        snapped, _, snap_dist = self.snap_to_network(point)
        
        if snap_dist > max_distance:
            return {
                'accessible': False,
                'snap_distance': snap_dist,
                'reachable_length': 0
            }
        
        # Ù‚Ø·Ø¹Ø§Øª Ø¯Ø± Ø¯Ø³ØªØ±Ø³ (Ø³Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡)
        reachable = self.find_segments_in_buffer(point, max_distance)
        reachable_length = sum(s.length for s in reachable)
        
        return {
            'accessible': True,
            'snap_distance': snap_dist,
            'reachable_segments': len(reachable),
            'reachable_length': reachable_length
        }
    
    def find_disconnected_components(self) -> List[List[int]]:
        """
        ÛŒØ§ÙØªÙ† Ø§Ø¬Ø²Ø§ÛŒ Ù†Ø§Ù¾ÛŒÙˆØ³ØªÙ‡ Ø´Ø¨Ú©Ù‡
        
        Returns:
            Ù„ÛŒØ³Øª Ø§Ø¬Ø²Ø§ÛŒ Ù†Ø§Ù¾ÛŒÙˆØ³ØªÙ‡
        """
        if not self.edges:
            self.build_network()
        
        # Ø³Ø§Ø®Øª Ù„ÛŒØ³Øª Ù…Ø¬Ø§ÙˆØ±Øª
        adjacency = {i: set() for i in range(len(self.nodes))}
        for edge in self.edges:
            adjacency[edge['start_node']].add(edge['end_node'])
            adjacency[edge['end_node']].add(edge['start_node'])
        
        # ÛŒØ§ÙØªÙ† Ø§Ø¬Ø²Ø§ Ø¨Ø§ BFS
        visited = set()
        components = []
        
        for start_node in adjacency:
            if start_node in visited:
                continue
            
            component = []
            queue = [start_node]
            
            while queue:
                node = queue.pop(0)
                if node in visited:
                    continue
                
                visited.add(node)
                component.append(node)
                
                for neighbor in adjacency[node]:
                    if neighbor not in visited:
                        queue.append(neighbor)
            
            components.append(component)
        
        return components
    
    def generate_report(self) -> Dict:
        """ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ú©Ø§Ù…Ù„"""
        stats = self.get_network_statistics()
        components = self.find_disconnected_components()
        
        return {
            'statistics': stats,
            'connectivity': {
                'components': len(components),
                'is_connected': len(components) == 1,
                'largest_component_nodes': max(len(c) for c in components) if components else 0
            }
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©Ù„Ø§Ø³
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    # Ø§ÛŒØ¬Ø§Ø¯ ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø±
    analyzer = RoadNetworkAnalyzer()
    
    # Ø§ÙØ²ÙˆØ¯Ù† Ù‚Ø·Ø¹Ø§Øª Ø¬Ø§Ø¯Ù‡
    roads = [
        RoadSegment(1, LineString([(0, 0), (10, 0)]), "Ø®ÛŒØ§Ø¨Ø§Ù† Ø§ØµÙ„ÛŒ", "primary", 50),
        RoadSegment(2, LineString([(10, 0), (20, 0)]), "Ø®ÛŒØ§Ø¨Ø§Ù† Ø§ØµÙ„ÛŒ", "primary", 50),
        RoadSegment(3, LineString([(0, 0), (0, 10)]), "Ø®ÛŒØ§Ø¨Ø§Ù† ÙØ±Ø¹ÛŒ Û±", "secondary", 40),
        RoadSegment(4, LineString([(10, 0), (10, 10)]), "Ø®ÛŒØ§Ø¨Ø§Ù† ÙØ±Ø¹ÛŒ Û²", "secondary", 40),
        RoadSegment(5, LineString([(20, 0), (20, 10)]), "Ø®ÛŒØ§Ø¨Ø§Ù† ÙØ±Ø¹ÛŒ Û³", "secondary", 40),
        RoadSegment(6, LineString([(0, 10), (10, 10)]), "Ø®ÛŒØ§Ø¨Ø§Ù† Ø´Ù…Ø§Ù„ÛŒ Û±", "residential", 30),
        RoadSegment(7, LineString([(10, 10), (20, 10)]), "Ø®ÛŒØ§Ø¨Ø§Ù† Ø´Ù…Ø§Ù„ÛŒ Û²", "residential", 30),
    ]
    
    for road in roads:
        analyzer.add_segment(road)
    
    # Ø³Ø§Ø®Øª Ø´Ø¨Ú©Ù‡
    analyzer.build_network()
    
    # ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´
    report = analyzer.generate_report()
    
    print("=" * 60)
    print("Ú¯Ø²Ø§Ø±Ø´ ØªØ­Ù„ÛŒÙ„ Ø´Ø¨Ú©Ù‡ Ù…Ø¹Ø§Ø¨Ø±")
    print("=" * 60)
    print(f"\nğŸ“Š Ø¢Ù…Ø§Ø± Ø´Ø¨Ú©Ù‡:")
    print(f"  ØªØ¹Ø¯Ø§Ø¯ Ú¯Ø±Ù‡: {report['statistics']['total_nodes']}")
    print(f"  ØªØ¹Ø¯Ø§Ø¯ ÛŒØ§Ù„: {report['statistics']['total_edges']}")
    print(f"  Ø·ÙˆÙ„ Ú©Ù„: {report['statistics']['total_length']:.2f} ÙˆØ§Ø­Ø¯")
    print(f"  Ø¨Ù†â€ŒØ¨Ø³Øªâ€ŒÙ‡Ø§: {report['statistics']['dead_ends']}")
    print(f"  ØªÙ‚Ø§Ø·Ø¹â€ŒÙ‡Ø§: {report['statistics']['intersections']}")
    
    print(f"\nğŸ”— Ø§ØªØµØ§Ù„â€ŒÙ¾Ø°ÛŒØ±ÛŒ:")
    print(f"  ØªØ¹Ø¯Ø§Ø¯ Ø§Ø¬Ø²Ø§: {report['connectivity']['components']}")
    print(f"  Ø´Ø¨Ú©Ù‡ Ù¾ÛŒÙˆØ³ØªÙ‡: {'Ø¨Ù„Ù‡' if report['connectivity']['is_connected'] else 'Ø®ÛŒØ±'}")
    
    # ØªØ³Øª snap to network
    test_point = Point(5, 5)
    snapped, segment, dist = analyzer.snap_to_network(test_point)
    print(f"\nğŸ“ Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø´Ø¨Ú©Ù‡:")
    print(f"  Ù†Ù‚Ø·Ù‡ Ø§ØµÙ„ÛŒ: {test_point}")
    print(f"  Ù†Ù‚Ø·Ù‡ Ø±ÙˆÛŒ Ø´Ø¨Ú©Ù‡: {snapped}")
    print(f"  ÙØ§ØµÙ„Ù‡: {dist:.2f}")</code></pre>
                </div>
            </div>
        </section>

        <!-- Resources Section -->
        <section class="section" id="resources">
            <div class="section-header">
                <div class="section-icon">ğŸ“š</div>
                <div class="section-title-group">
                    <div class="section-number">Ù…Ù†Ø§Ø¨Ø¹</div>
                    <h2 class="section-title">Ù…Ù†Ø§Ø¨Ø¹ Ùˆ Ù…Ø±Ø§Ø¬Ø¹</h2>
                    <p class="section-subtitle">Ù…Ù†Ø§Ø¨Ø¹ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ø¨ÛŒØ´ØªØ±</p>
                </div>
            </div>

            <div class="resources-grid">
                <div class="resource-card">
                    <div class="resource-icon">ğŸ“–</div>
                    <h4>Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø±Ø³Ù…ÛŒ</h4>
                    <p>Ù…Ø³ØªÙ†Ø¯Ø§Øª Ú©Ø§Ù…Ù„ Shapely</p>
                    <a href="https://shapely.readthedocs.io" target="_blank">Ù…Ø´Ø§Ù‡Ø¯Ù‡</a>
                </div>
                
                <div class="resource-card">
                    <div class="resource-icon">ğŸ’»</div>
                    <h4>GitHub</h4>
                    <p>Ú©Ø¯ Ù…Ù†Ø¨Ø¹ Ùˆ Ù…Ø«Ø§Ù„â€ŒÙ‡Ø§</p>
                    <a href="https://github.com/shapely/shapely" target="_blank">Ù…Ø´Ø§Ù‡Ø¯Ù‡</a>
                </div>
                
                <div class="resource-card">
                    <div class="resource-icon">ğŸ¼</div>
                    <h4>GeoPandas</h4>
                    <p>ØªØ­Ù„ÛŒÙ„ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ</p>
                    <a href="https://geopandas.org" target="_blank">Ù…Ø´Ø§Ù‡Ø¯Ù‡</a>
                </div>
                
                <div class="resource-card">
                    <div class="resource-icon">ğŸ—ºï¸</div>
                    <h4>Fiona</h4>
                    <p>Ø®ÙˆØ§Ù†Ø¯Ù†/Ù†ÙˆØ´ØªÙ† ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ GIS</p>
                    <a href="https://fiona.readthedocs.io" target="_blank">Ù…Ø´Ø§Ù‡Ø¯Ù‡</a>
                </div>
                
                <div class="resource-card">
                    <div class="resource-icon">ğŸ¨</div>
                    <h4>Matplotlib</h4>
                    <p>Ù…ØµÙˆØ±Ø³Ø§Ø²ÛŒ Ù‡Ù†Ø¯Ø³Ù‡â€ŒÙ‡Ø§</p>
                    <a href="https://matplotlib.org" target="_blank">Ù…Ø´Ø§Ù‡Ø¯Ù‡</a>
                </div>
                
                <div class="resource-card">
                    <div class="resource-icon">ğŸŒ</div>
                    <h4>PyProj</h4>
                    <p>ØªØ¨Ø¯ÛŒÙ„ Ø³ÛŒØ³ØªÙ… Ù…Ø®ØªØµØ§Øª</p>
                    <a href="https://pyproj4.github.io/pyproj" target="_blank">Ù…Ø´Ø§Ù‡Ø¯Ù‡</a>
                </div>
            </div>

            <div class="info-box tip">
                <div class="info-icon">ğŸ’¡</div>
                <div class="info-content">
                    <h4>Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ù…Ù„</h4>
                    <ul>
                        <li><strong>GeoPandas:</strong> Ú©Ø§Ø± Ø¨Ø§ DataFrame Ù‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ</li>
                        <li><strong>Fiona:</strong> Ø®ÙˆØ§Ù†Ø¯Ù†/Ù†ÙˆØ´ØªÙ† Shapefile Ùˆ GeoJSON</li>
                        <li><strong>Rasterio:</strong> Ú©Ø§Ø± Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø±Ø³ØªØ±ÛŒ</li>
                        <li><strong>PyProj:</strong> ØªØ¨Ø¯ÛŒÙ„ Ø¨ÛŒÙ† Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªØµØ§Øª</li>
                        <li><strong>Folium:</strong> Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù‚Ø´Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ¹Ø§Ù…Ù„ÛŒ</li>
                        <li><strong>NetworkX:</strong> ØªØ­Ù„ÛŒÙ„ Ú¯Ø±Ø§Ù Ø´Ø¨Ú©Ù‡</li>
                    </ul>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-logo">
                <div class="logo-icon">ğŸ“</div>
                <span class="logo-text">Shapely Tutorial</span>
            </div>
            <p>Ø¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹ ØªØ­Ù„ÛŒÙ„ Ù‡Ù†Ø¯Ø³ÛŒ Ø¯Ø± Ù¾Ø§ÛŒØªÙˆÙ†</p>
            <div class="footer-links">
                <a href="https://shapely.readthedocs.io" target="_blank">Shapely Docs</a>
                <a href="https://geopandas.org" target="_blank">GeoPandas</a>
                <a href="https://pypi.org/project/shapely/" target="_blank">PyPI</a>
                <a href="https://github.com/shapely/shapely" target="_blank">GitHub</a>
            </div>
            <p class="copyright">
                Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡ Ø¨Ø§ â¤ï¸ Ø¨Ø±Ø§ÛŒ Ø¬Ø§Ù…Ø¹Ù‡ ØªÙˆØ³Ø¹Ù‡â€ŒØ¯Ù‡Ù†Ø¯Ú¯Ø§Ù† GIS Ø§ÛŒØ±Ø§Ù†
                <br>
                Â© 2024 - ØªÙ…Ø§Ù…ÛŒ Ø­Ù‚ÙˆÙ‚ Ù…Ø­ÙÙˆØ¸ Ø§Ø³Øª
            </p>
        </div>
    </footer>

    <!-- Highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    
    <script>
        // Initialize Highlight.js
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });

        // Copy code function
        function copyCode(button) {
            const codeBlock = button.closest('.code-block');
            const code = codeBlock.querySelector('code').textContent;
            
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.innerHTML;
                button.innerHTML = '<span>âœ“</span> Ú©Ù¾ÛŒ Ø´Ø¯!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ú©Ù¾ÛŒ:', err);
            });
        }

        // Smooth scroll for navigation
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Active navigation link
        const sections = document.querySelectorAll('.section');
        const navLinks = document.querySelectorAll('.nav-link');

        window.addEventListener('scroll', () => {
            let current = '';
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                
                if (scrollY >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });

        // Navbar background on scroll
        const nav = document.querySelector('.nav');
        window.addEventListener('scroll', () => {
            if (window.scrollY > 100) {
                nav.style.background = 'rgba(15, 23, 42, 0.98)';
            } else {
                nav.style.background = 'rgba(15, 23, 42, 0.95)';
            }
        });
    </script>
</body>
</html>