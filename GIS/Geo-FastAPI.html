<!DOCTYPE html>
<html lang="fa" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI + GeoSpatial + AI | Ø¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;600;700;800;900&display=swap"
        rel="stylesheet">

    <!-- Highlight.js -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>

    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ROOT VARIABLES & THEME
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        :root {
            /* Primary Colors - Geo Theme */
            --primary: #10b981;
            --primary-dark: #059669;
            --primary-light: #34d399;
            --primary-glow: rgba(16, 185, 129, 0.4);

            /* AI Accent Colors */
            --ai-purple: #8b5cf6;
            --ai-blue: #3b82f6;
            --ai-cyan: #06b6d4;
            --ai-pink: #ec4899;

            /* FastAPI Orange */
            --fastapi: #009688;
            --fastapi-light: #4db6ac;

            /* Status Colors */
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;

            /* Dark Theme */
            --bg-primary: #0a0f1a;
            --bg-secondary: #111827;
            --bg-tertiary: #1f2937;
            --bg-card: #1a2332;
            --bg-code: #0d1117;

            /* Text Colors */
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;

            /* Border Colors */
            --border-color: #2d3748;
            --border-light: #374151;

            /* Gradients */
            --gradient-geo: linear-gradient(135deg, #10b981 0%, #06b6d4 100%);
            --gradient-ai: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
            --gradient-fast: linear-gradient(135deg, #009688 0%, #4db6ac 100%);
            --gradient-hero: linear-gradient(135deg, #10b981 0%, #8b5cf6 50%, #06b6d4 100%);
            --gradient-dark: linear-gradient(180deg, #0a0f1a 0%, #111827 100%);

            /* Shadows */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
            --shadow-glow: 0 0 40px var(--primary-glow);
            --shadow-ai: 0 0 40px rgba(139, 92, 246, 0.3);

            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --radius-full: 9999px;

            /* Font */
            --font-main: 'Vazirmatn', system-ui, sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESET & BASE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            font-size: 16px;
        }

        body {
            font-family: var(--font-main);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.8;
            overflow-x: hidden;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SCROLLBAR
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gradient-geo);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SELECTION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        ::selection {
            background: var(--primary);
            color: white;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HEADER & NAVIGATION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(10, 15, 26, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 0;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 24px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.4rem;
            font-weight: 800;
            text-decoration: none;
            color: var(--text-primary);
        }

        .logo-icon {
            width: 42px;
            height: 42px;
            background: var(--gradient-geo);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
        }

        .logo-text {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }

        .logo-text span:first-child {
            background: var(--gradient-hero);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .logo-text span:last-child {
            font-size: 0.7rem;
            font-weight: 400;
            color: var(--text-muted);
        }

        .nav {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 8px 16px;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-link:hover {
            background: rgba(16, 185, 129, 0.1);
            color: var(--primary-light);
        }

        .nav-link.active {
            background: rgba(16, 185, 129, 0.2);
            color: var(--primary);
        }

        .nav-link .nav-icon {
            font-size: 1rem;
        }

        /* Mobile Menu */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HERO SECTION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .hero {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 120px 24px 80px;
            position: relative;
            overflow: hidden;
        }

        .hero-bg {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(circle at 20% 30%, rgba(16, 185, 129, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(139, 92, 246, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(6, 182, 212, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Animated Grid */
        .hero-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                linear-gradient(rgba(16, 185, 129, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(16, 185, 129, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
        }

        .hero-content {
            position: relative;
            z-index: 1;
            max-width: 1000px;
            text-align: center;
        }

        .hero-badges {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 32px;
        }

        .hero-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: var(--radius-full);
            font-size: 0.85rem;
            font-weight: 600;
        }

        .hero-badge.geo {
            background: rgba(16, 185, 129, 0.15);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--primary-light);
        }

        .hero-badge.ai {
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #a78bfa;
        }

        .hero-badge.fast {
            background: rgba(0, 150, 136, 0.15);
            border: 1px solid rgba(0, 150, 136, 0.3);
            color: var(--fastapi-light);
        }

        .hero h1 {
            font-size: clamp(2.5rem, 7vw, 4.5rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 24px;
        }

        .hero h1 .gradient-text {
            background: var(--gradient-hero);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero-subtitle {
            font-size: 1.3rem;
            color: var(--text-secondary);
            max-width: 700px;
            margin: 0 auto 40px;
            line-height: 1.7;
        }

        .hero-cta {
            display: flex;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
            margin-bottom: 60px;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 14px 28px;
            border-radius: var(--radius-md);
            font-size: 1rem;
            font-weight: 600;
            font-family: var(--font-main);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .btn-primary {
            background: var(--gradient-geo);
            color: white;
            box-shadow: 0 4px 20px var(--primary-glow);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px var(--primary-glow);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-card);
            border-color: var(--primary);
        }

        /* Hero Stats */
        .hero-stats {
            display: flex;
            justify-content: center;
            gap: 48px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 900;
            background: var(--gradient-geo);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MAIN CONTENT
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px 80px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SECTION STYLES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .section {
            margin-bottom: 64px;
            padding: 48px;
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-geo);
        }

        .section.ai-section::before {
            background: var(--gradient-ai);
        }

        .section.fast-section::before {
            background: var(--gradient-fast);
        }

        .section-header {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 32px;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-icon {
            width: 64px;
            height: 64px;
            background: var(--gradient-geo);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            flex-shrink: 0;
            box-shadow: var(--shadow-glow);
        }

        .section.ai-section .section-icon {
            background: var(--gradient-ai);
            box-shadow: var(--shadow-ai);
        }

        .section.fast-section .section-icon {
            background: var(--gradient-fast);
        }

        .section-title-group {
            flex: 1;
        }

        .section-number {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 4px;
        }

        .section.ai-section .section-number {
            color: var(--ai-purple);
        }

        .section-title {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .section-subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TYPOGRAPHY
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        h3 {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 40px 0 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        h3::before {
            content: '';
            width: 4px;
            height: 24px;
            background: var(--gradient-geo);
            border-radius: 2px;
        }

        h4 {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--primary-light);
            margin: 28px 0 12px;
        }

        p {
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        a {
            color: var(--primary);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        a:hover {
            color: var(--primary-light);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CODE BLOCKS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .code-block {
            margin: 24px 0;
            border-radius: var(--radius-lg);
            overflow: hidden;
            background: var(--bg-code);
            border: 1px solid var(--border-color);
        }

        .code-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .code-lang {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .code-lang-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 700;
        }

        .code-lang-icon.python {
            background: linear-gradient(135deg, #3776ab 0%, #ffd43b 100%);
            color: white;
        }

        .code-lang-icon.bash {
            background: #4eaa25;
            color: white;
        }

        .code-lang-icon.json {
            background: #f59e0b;
            color: white;
        }

        .code-lang-icon.sql {
            background: #336791;
            color: white;
        }

        .code-filename {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .code-actions {
            display: flex;
            gap: 8px;
        }

        .code-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            font-family: var(--font-main);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .code-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }

        .code-btn.copied {
            background: rgba(16, 185, 129, 0.3);
            color: var(--primary);
        }

        .code-body {
            padding: 20px;
            overflow-x: auto;
        }

        .code-body pre {
            margin: 0;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.7;
            direction: ltr;
            text-align: left;
        }

        .code-body code {
            font-family: var(--font-mono);
        }

        /* Inline Code */
        code:not([class*="language-"]) {
            background: rgba(16, 185, 129, 0.15);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.85em;
            color: var(--primary-light);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CARDS & GRIDS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 24px;
            margin: 24px 0;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 20px;
            margin: 24px 0;
        }

        .grid-4 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 24px 0;
        }

        .card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 24px;
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--primary);
            transform: translateY(-4px);
            box-shadow: var(--shadow-glow);
        }

        .card.ai-card:hover {
            border-color: var(--ai-purple);
            box-shadow: var(--shadow-ai);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .card-icon {
            width: 48px;
            height: 48px;
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            flex-shrink: 0;
        }

        .card-icon.geo {
            background: rgba(16, 185, 129, 0.2);
        }

        .card-icon.ai {
            background: rgba(139, 92, 246, 0.2);
        }

        .card-icon.fast {
            background: rgba(0, 150, 136, 0.2);
        }

        .card-icon.blue {
            background: rgba(59, 130, 246, 0.2);
        }

        .card-icon.orange {
            background: rgba(245, 158, 11, 0.2);
        }

        .card-icon.pink {
            background: rgba(236, 72, 153, 0.2);
        }

        .card-icon.cyan {
            background: rgba(6, 182, 212, 0.2);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .card-content {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .card-content ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .card-content li {
            padding: 8px 0;
            padding-right: 20px;
            position: relative;
            border-bottom: 1px solid var(--border-color);
        }

        .card-content li:last-child {
            border-bottom: none;
        }

        .card-content li::before {
            content: 'â†’';
            position: absolute;
            right: 0;
            color: var(--primary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           INFO BOXES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .info-box {
            padding: 20px 24px;
            border-radius: var(--radius-lg);
            margin: 24px 0;
            border-right: 4px solid;
        }

        .info-box.tip {
            background: rgba(16, 185, 129, 0.1);
            border-right-color: var(--primary);
        }

        .info-box.warning {
            background: rgba(245, 158, 11, 0.1);
            border-right-color: var(--warning);
        }

        .info-box.danger {
            background: rgba(239, 68, 68, 0.1);
            border-right-color: var(--danger);
        }

        .info-box.info {
            background: rgba(59, 130, 246, 0.1);
            border-right-color: var(--info);
        }

        .info-box.ai {
            background: rgba(139, 92, 246, 0.1);
            border-right-color: var(--ai-purple);
        }

        .info-box-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .info-box-content {
            color: var(--text-secondary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ARCHITECTURE DIAGRAM
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .architecture-box {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 32px;
            margin: 24px 0;
            overflow-x: auto;
        }

        .architecture-title {
            text-align: center;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 24px;
            font-size: 1.1rem;
        }

        .architecture-diagram {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--text-secondary);
            white-space: pre;
            direction: ltr;
            text-align: center;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TABLES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .table-container {
            overflow-x: auto;
            margin: 24px 0;
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        th,
        td {
            padding: 14px 18px;
            text-align: right;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            font-weight: 700;
            color: var(--primary);
            white-space: nowrap;
        }

        tr:hover {
            background: rgba(16, 185, 129, 0.05);
        }

        tr:last-child td {
            border-bottom: none;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FILE TREE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .file-tree {
            background: var(--bg-code);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 24px;
            margin: 24px 0;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            direction: ltr;
            text-align: left;
        }

        .file-tree-title {
            color: var(--primary);
            font-weight: 700;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .file-tree pre {
            margin: 0;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .file-tree .folder {
            color: var(--ai-purple);
        }

        .file-tree .file-py {
            color: var(--primary);
        }

        .file-tree .file-json {
            color: var(--warning);
        }

        .file-tree .file-sql {
            color: var(--info);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           API ENDPOINT CARDS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .endpoint-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            margin: 20px 0;
            overflow: hidden;
        }

        .endpoint-header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: var(--bg-code);
            border-bottom: 1px solid var(--border-color);
        }

        .endpoint-method {
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            font-weight: 700;
            font-family: var(--font-mono);
        }

        .endpoint-method.get {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .endpoint-method.post {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .endpoint-method.put {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .endpoint-method.delete {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .endpoint-path {
            font-family: var(--font-mono);
            font-size: 0.95rem;
            color: var(--text-primary);
            direction: ltr;
        }

        .endpoint-body {
            padding: 20px;
        }

        .endpoint-desc {
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FEATURE LIST
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .feature-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        .feature-list li {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .feature-list li:last-child {
            border-bottom: none;
        }

        .feature-icon {
            width: 24px;
            height: 24px;
            background: var(--gradient-geo);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .feature-text {
            color: var(--text-secondary);
        }

        .feature-text strong {
            color: var(--text-primary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CHAPTER NAVIGATION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .chapter-nav {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin: 48px 0;
        }

        .chapter-link {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .chapter-link:hover {
            border-color: var(--primary);
            transform: translateX(-8px);
            box-shadow: var(--shadow-glow);
        }

        .chapter-link.ai-link:hover {
            border-color: var(--ai-purple);
            box-shadow: var(--shadow-ai);
        }

        .chapter-num {
            width: 48px;
            height: 48px;
            background: var(--gradient-geo);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 1.2rem;
            color: white;
            flex-shrink: 0;
        }

        .chapter-link.ai-link .chapter-num {
            background: var(--gradient-ai);
        }

        .chapter-info {
            flex: 1;
        }

        .chapter-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .chapter-desc {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STEPS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .steps {
            margin: 24px 0;
        }

        .step {
            display: flex;
            gap: 20px;
            padding: 24px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }

        .step:hover {
            border-color: var(--primary);
        }

        .step-number {
            width: 48px;
            height: 48px;
            background: var(--gradient-geo);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 1.2rem;
            color: white;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .step-desc {
            color: var(--text-secondary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FOOTER
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 48px 24px;
            margin-top: 64px;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        .footer-logo {
            font-size: 1.5rem;
            font-weight: 800;
            background: var(--gradient-hero);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 16px;
        }

        .footer-text {
            color: var(--text-muted);
            font-size: 0.95rem;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-top: 24px;
            flex-wrap: wrap;
        }

        .footer-links a {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (max-width: 1024px) {
            .nav {
                display: none;
            }

            .menu-toggle {
                display: block;
            }
        }

        @media (max-width: 768px) {
            .hero {
                padding: 100px 16px 60px;
            }

            .hero h1 {
                font-size: 2rem;
            }

            .hero-subtitle {
                font-size: 1.1rem;
            }

            .section {
                padding: 24px;
                margin-bottom: 32px;
            }

            .section-header {
                flex-direction: column;
                text-align: center;
            }

            .section-icon {
                margin: 0 auto;
            }

            h3 {
                font-size: 1.2rem;
            }

            .grid-2,
            .grid-3,
            .grid-4 {
                grid-template-columns: 1fr;
            }

            .step {
                flex-direction: column;
                text-align: center;
            }

            .hero-stats {
                gap: 24px;
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ANIMATIONS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        .section {
            animation: fadeInUp 0.6s ease-out;
        }

        /* AI Glow Animation */
        @keyframes aiGlow {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
            }

            50% {
                box-shadow: 0 0 40px rgba(139, 92, 246, 0.5);
            }
        }

        .ai-glow {
            animation: aiGlow 2s ease-in-out infinite;
        }
    </style>
</head>

<body>
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         HEADER
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <header class="header">
        <div class="header-content">
            <a href="#" class="logo">
                <div class="logo-icon">ğŸŒ</div>
                <div class="logo-text">
                    <span>GeoAI FastAPI</span>
                    <span>Ø¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹</span>
                </div>
            </a>

            <nav class="nav">
                <a href="#intro" class="nav-link">
                    <span class="nav-icon">ğŸš€</span>
                    <span>Ù…Ø¹Ø±ÙÛŒ</span>
                </a>
                <a href="#setup" class="nav-link">
                    <span class="nav-icon">âš™ï¸</span>
                    <span>Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ</span>
                </a>
                <a href="#geo-basics" class="nav-link">
                    <span class="nav-icon">ğŸ—ºï¸</span>
                    <span>GeoSpatial</span>
                </a>
                <a href="#ai-integration" class="nav-link">
                    <span class="nav-icon">ğŸ¤–</span>
                    <span>AI</span>
                </a>
                <a href="#projects" class="nav-link">
                    <span class="nav-icon">ğŸ“¦</span>
                    <span>Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§</span>
                </a>
            </nav>

            <button class="menu-toggle">â˜°</button>
        </div>
    </header>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         HERO
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <section class="hero">
        <div class="hero-bg"></div>
        <div class="hero-grid"></div>

        <div class="hero-content">
            <div class="hero-badges">
                <span class="hero-badge fast">âš¡ FastAPI</span>
                <span class="hero-badge geo">ğŸŒ GeoSpatial</span>
                <span class="hero-badge ai">ğŸ¤– AI/ML</span>
            </div>

            <h1>
                <span class="gradient-text">FastAPI + GeoSpatial</span>
                <br>
                Ø¨Ø§ Ù‚Ø¯Ø±Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ
            </h1>

            <p class="hero-subtitle">
                Ø³Ø§Ø®Øª API Ù‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¨Ø§ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ú©Ø§Ø±Ø§ÛŒÛŒ
                <br>
                Ø§Ø² ØªØ­Ù„ÛŒÙ„ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ ØªØ§ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ø§ AI
            </p>

            <div class="hero-cta">
                <a href="#intro" class="btn btn-primary">
                    <span>ğŸš€</span>
                    <span>Ø´Ø±ÙˆØ¹ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ</span>
                </a>
                <a href="#projects" class="btn btn-secondary">
                    <span>ğŸ“¦</span>
                    <span>Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ</span>
                </a>
            </div>

            <div class="hero-stats">
                <div class="stat-item">
                    <div class="stat-value">Û±Û²</div>
                    <div class="stat-label">ÙØµÙ„ Ø¢Ù…ÙˆØ²Ø´ÛŒ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">ÛµÛ°+</div>
                    <div class="stat-label">Ù†Ù…ÙˆÙ†Ù‡ Ú©Ø¯</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">Ûµ</div>
                    <div class="stat-label">Ù¾Ø±ÙˆÚ˜Ù‡ Ø¹Ù…Ù„ÛŒ</div>
                </div>
            </div>
        </div>
    </section>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         MAIN CONTENT
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <main class="main-content">

        <!-- Chapter Navigation -->
        <div class="chapter-nav">
            <a href="#intro" class="chapter-link">
                <div class="chapter-num">Û±</div>
                <div class="chapter-info">
                    <div class="chapter-title">Ù…Ø¹Ø±ÙÛŒ Ùˆ Ù…ÙØ§Ù‡ÛŒÙ…</div>
                    <div class="chapter-desc">FastAPIØŒ GeoSpatialØŒ AI</div>
                </div>
            </a>
            <a href="#setup" class="chapter-link">
                <div class="chapter-num">Û²</div>
                <div class="chapter-info">
                    <div class="chapter-title">Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡</div>
                    <div class="chapter-desc">Ù…Ø­ÛŒØ· ØªÙˆØ³Ø¹Ù‡ Ùˆ Ø³Ø§Ø®ØªØ§Ø±</div>
                </div>
            </a>
            <a href="#geo-basics" class="chapter-link">
                <div class="chapter-num">Û³</div>
                <div class="chapter-info">
                    <div class="chapter-title">Ù…Ø¨Ø§Ù†ÛŒ GeoSpatial</div>
                    <div class="chapter-desc">PostGIS, Shapely, GeoJSON</div>
                </div>
            </a>
            <a href="#ai-integration" class="chapter-link ai-link">
                <div class="chapter-num">Û´</div>
                <div class="chapter-info">
                    <div class="chapter-title">ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡â€ŒØ³Ø§Ø²ÛŒ AI</div>
                    <div class="chapter-desc">ML, Computer Vision, LLM</div>
                </div>
            </a>
            <a href="#satellite" class="chapter-link ai-link">
                <div class="chapter-num">Ûµ</div>
                <div class="chapter-info">
                    <div class="chapter-title">ØªØ­Ù„ÛŒÙ„ Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</div>
                    <div class="chapter-desc">ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ Ø¨Ø§ AI</div>
                </div>
            </a>
            <a href="#projects" class="chapter-link">
                <div class="chapter-num">Û¶</div>
                <div class="chapter-info">
                    <div class="chapter-title">Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ</div>
                    <div class="chapter-desc">Ú©Ø§Ø±Ø¨Ø±Ø¯Ù‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ</div>
                </div>
            </a>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 1: INTRODUCTION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="intro">
            <div class="section-header">
                <div class="section-icon">ğŸš€</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û±</div>
                    <h2 class="section-title">Ù…Ø¹Ø±ÙÛŒ Ùˆ Ù…ÙØ§Ù‡ÛŒÙ… Ù¾Ø§ÛŒÙ‡</h2>
                    <p class="section-subtitle">Ø¢Ø´Ù†Ø§ÛŒÛŒ Ø¨Ø§ FastAPIØŒ GeoSpatial Ùˆ AI</p>
                </div>
            </div>

            <h3>Ú†Ø±Ø§ FastAPI Ø¨Ø±Ø§ÛŒ GeoSpatial AIØŸ</h3>

            <p>
                <strong>FastAPI</strong> ÛŒÚ© ÙØ±ÛŒÙ…â€ŒÙˆØ±Ú© Ù…Ø¯Ø±Ù† Ùˆ Ø¨Ø³ÛŒØ§Ø± Ø³Ø±ÛŒØ¹ Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø®Øª API Ø¨Ø§ Python Ø§Ø³Øª.
                ØªØ±Ú©ÛŒØ¨ Ø¢Ù† Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ùˆ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒØŒ Ø§Ù…Ú©Ø§Ù† Ø³Ø§Ø®Øª Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ù‚Ø¯Ø±ØªÙ…Ù†Ø¯ GeoAI Ø±Ø§ ÙØ±Ø§Ù‡Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
            </p>

            <div class="grid-3">
                <div class="card">
                    <div class="card-header">
                        <div class="card-icon fast">âš¡</div>
                        <div class="card-title">FastAPI</div>
                    </div>
                    <div class="card-content">
                        <ul>
                            <li>Ø³Ø±Ø¹Øª Ø¨Ø³ÛŒØ§Ø± Ø¨Ø§Ù„Ø§ (Starlette + Pydantic)</li>
                            <li>Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø®ÙˆØ¯Ú©Ø§Ø± OpenAPI</li>
                            <li>Type Hints Ùˆ Validation</li>
                            <li>Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² Async/Await</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <div class="card-icon geo">ğŸŒ</div>
                        <div class="card-title">GeoSpatial</div>
                    </div>
                    <div class="card-content">
                        <ul>
                            <li>Ú©Ø§Ø± Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ</li>
                            <li>ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ</li>
                            <li>PostGIS Ùˆ GeoDjango</li>
                            <li>ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</li>
                        </ul>
                    </div>
                </div>

                <div class="card ai-card">
                    <div class="card-header">
                        <div class="card-icon ai">ğŸ¤–</div>
                        <div class="card-title">AI/ML</div>
                    </div>
                    <div class="card-content">
                        <ul>
                            <li>ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§ Ø¯Ø± ØªØµØ§ÙˆÛŒØ±</li>
                            <li>Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…Ú©Ø§Ù†ÛŒ</li>
                            <li>ØªØ­Ù„ÛŒÙ„ Ø³Ø±ÛŒ Ø²Ù…Ø§Ù†ÛŒ</li>
                            <li>LLM Ø¨Ø±Ø§ÛŒ Geo Query</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3>Ù…Ø¹Ù…Ø§Ø±ÛŒ Ú©Ù„ÛŒ Ø³ÛŒØ³ØªÙ…</h3>

            <div class="architecture-box">
                <div class="architecture-title">ğŸ—ï¸ Ù…Ø¹Ù…Ø§Ø±ÛŒ GeoAI API</div>
                <div class="architecture-diagram">
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ CLIENT LAYER â”‚
                    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                    â”‚ â”‚ Web App â”‚ â”‚ Mobile â”‚ â”‚ QGIS â”‚ â”‚ Other â”‚ â”‚
                    â”‚ â”‚ (React) â”‚ â”‚ App â”‚ â”‚ Plugin â”‚ â”‚ GIS â”‚ â”‚
                    â”‚ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â”‚
                    â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ â”‚ â”‚ â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ API Gateway â”‚
                    â”‚ (FastAPI) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ â”‚ â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ GeoSpatial â”‚ â”‚ AI/ML â”‚ â”‚ Auth & â”‚
                    â”‚ Services â”‚ â”‚ Services â”‚ â”‚ Cache â”‚
                    â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
                    â”‚ â€¢ Buffer â”‚ â”‚ â€¢ Object Det. â”‚ â”‚ â€¢ JWT Auth â”‚
                    â”‚ â€¢ Intersect â”‚ â”‚ â€¢ Prediction â”‚ â”‚ â€¢ Redis â”‚
                    â”‚ â€¢ Routing â”‚ â”‚ â€¢ Classificationâ”‚ â”‚ â€¢ Rate Limit â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ â”‚ â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ â”‚ â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚ PostGIS â”‚ â”‚ Object â”‚ â”‚ Tile â”‚
                    â”‚ Database â”‚ â”‚ Storage â”‚ â”‚ Server â”‚
                    â”‚ â”‚ â”‚ (MinIO) â”‚ â”‚ (Martin) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                </div>
            </div>

            <h3>Ù¾Ø´ØªÙ‡ ÙÙ†Ø§ÙˆØ±ÛŒ (Tech Stack)</h3>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Ù„Ø§ÛŒÙ‡</th>
                            <th>ØªÚ©Ù†ÙˆÙ„ÙˆÚ˜ÛŒ</th>
                            <th>ØªÙˆØ¶ÛŒØ­Ø§Øª</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>API Framework</strong></td>
                            <td>FastAPI</td>
                            <td>ÙØ±ÛŒÙ…â€ŒÙˆØ±Ú© Ø§ØµÙ„ÛŒ Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Async</td>
                        </tr>
                        <tr>
                            <td><strong>Validation</strong></td>
                            <td>Pydantic v2</td>
                            <td>Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ùˆ GeoJSON</td>
                        </tr>
                        <tr>
                            <td><strong>Database</strong></td>
                            <td>PostgreSQL + PostGIS</td>
                            <td>Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ</td>
                        </tr>
                        <tr>
                            <td><strong>ORM</strong></td>
                            <td>SQLAlchemy + GeoAlchemy2</td>
                            <td>Ú©Ø§Ø± Ø¨Ø§ Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ</td>
                        </tr>
                        <tr>
                            <td><strong>Geo Libraries</strong></td>
                            <td>Shapely, GeoPandas, Rasterio</td>
                            <td>Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø¯Ø§Ø±ÛŒ Ùˆ Ø±Ø³ØªØ±ÛŒ</td>
                        </tr>
                        <tr>
                            <td><strong>AI/ML</strong></td>
                            <td>PyTorch, TensorFlow, Scikit-learn</td>
                            <td>Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†</td>
                        </tr>
                        <tr>
                            <td><strong>Computer Vision</strong></td>
                            <td>OpenCV, Detectron2, YOLO</td>
                            <td>Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµÙˆÛŒØ± Ùˆ ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§</td>
                        </tr>
                        <tr>
                            <td><strong>LLM</strong></td>
                            <td>LangChain, OpenAI, Ollama</td>
                            <td>Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø²Ø¨Ø§Ù† Ø·Ø¨ÛŒØ¹ÛŒ Ø¨Ø±Ø§ÛŒ Geo</td>
                        </tr>
                        <tr>
                            <td><strong>Cache</strong></td>
                            <td>Redis</td>
                            <td>Ú©Ø´ Ùˆ ØµÙ Ù¾ÛŒØ§Ù…</td>
                        </tr>
                        <tr>
                            <td><strong>Task Queue</strong></td>
                            <td>Celery</td>
                            <td>Ù¾Ø±Ø¯Ø§Ø²Ø´â€ŒÙ‡Ø§ÛŒ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 2: PROJECT SETUP
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="setup">
            <div class="section-header">
                <div class="section-icon">âš™ï¸</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û²</div>
                    <h2 class="section-title">Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡</h2>
                    <p class="section-subtitle">Ù…Ø­ÛŒØ· ØªÙˆØ³Ø¹Ù‡ Ùˆ Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡</p>
                </div>
            </div>

            <h3>Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡</h3>

            <div class="file-tree">
                <div class="file-tree-title">ğŸ“ geoai-fastapi/</div>
                <pre>
<span class="folder">â”œâ”€â”€ app/</span>
â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   <span class="file-py">â”œâ”€â”€ main.py</span>                 # Entry point
â”‚   <span class="file-py">â”œâ”€â”€ config.py</span>               # Settings
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ api/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ deps.py</span>             # Dependencies
â”‚   â”‚   <span class="folder">â”œâ”€â”€ v1/</span>
â”‚   â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   â”‚   <span class="file-py">â”œâ”€â”€ router.py</span>
â”‚   â”‚   â”‚   <span class="file-py">â”œâ”€â”€ geo.py</span>          # Geo endpoints
â”‚   â”‚   â”‚   <span class="file-py">â”œâ”€â”€ ai.py</span>           # AI endpoints
â”‚   â”‚   â”‚   <span class="file-py">â””â”€â”€ analysis.py</span>     # Analysis endpoints
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ models/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ geo.py</span>              # Geo models
â”‚   â”‚   <span class="file-py">â””â”€â”€ prediction.py</span>       # ML models
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ schemas/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ geo.py</span>              # Pydantic schemas
â”‚   â”‚   <span class="file-py">â””â”€â”€ ai.py</span>               # AI schemas
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ services/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ geo_service.py</span>      # Geo operations
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ ai_service.py</span>       # AI inference
â”‚   â”‚   <span class="file-py">â””â”€â”€ satellite.py</span>        # Satellite imagery
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ ml/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ object_detection.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ segmentation.py</span>
â”‚   â”‚   <span class="file-py">â””â”€â”€ prediction.py</span>
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ db/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ session.py</span>
â”‚   â”‚   <span class="file-py">â””â”€â”€ base.py</span>
â”‚   â”‚
â”‚   <span class="folder">â””â”€â”€ core/</span>
â”‚       <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚       <span class="file-py">â”œâ”€â”€ security.py</span>
â”‚       <span class="file-py">â””â”€â”€ middleware.py</span>
â”‚
<span class="folder">â”œâ”€â”€ ml_models/</span>                  # Trained ML models
â”‚   â”œâ”€â”€ object_detection/
â”‚   â”œâ”€â”€ segmentation/
â”‚   â””â”€â”€ prediction/
â”‚
<span class="folder">â”œâ”€â”€ tests/</span>
â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   <span class="file-py">â”œâ”€â”€ test_geo.py</span>
â”‚   <span class="file-py">â””â”€â”€ test_ai.py</span>
â”‚
<span class="folder">â”œâ”€â”€ docker/</span>
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ Dockerfile.ml
â”‚   â””â”€â”€ docker-compose.yml
â”‚
<span class="file-json">â”œâ”€â”€ pyproject.toml</span>
<span class="file-json">â”œâ”€â”€ requirements.txt</span>
<span class="file-json">â”œâ”€â”€ .env.example</span>
<span class="file-json">â””â”€â”€ README.md</span>
</pre>
            </div>

            <h3>Ù†ØµØ¨ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒâ€ŒÙ‡Ø§</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon bash">$</div>
                        <span class="code-filename">requirements.txt</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-bash"># FastAPI Core
fastapi==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.3
pydantic-settings==2.1.0

# Database
sqlalchemy==2.0.25
asyncpg==0.29.0
geoalchemy2==0.14.3
alembic==1.13.1

# GeoSpatial
shapely==2.0.2
geopandas==0.14.2
pyproj==3.6.1
rasterio==1.3.9
fiona==1.9.5
geojson==3.1.0

# AI/ML
torch==2.1.2
torchvision==0.16.2
tensorflow==2.15.0
scikit-learn==1.4.0
numpy==1.26.3
pandas==2.1.4

# Computer Vision
opencv-python==4.9.0.80
Pillow==10.2.0
ultralytics==8.1.0  # YOLOv8

# LLM
langchain==0.1.0
openai==1.8.0
ollama==0.1.6

# Utilities
httpx==0.26.0
python-multipart==0.0.6
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
redis==5.0.1
celery==5.3.4

# Testing
pytest==7.4.4
pytest-asyncio==0.23.3</code></pre>
                </div>
            </div>

            <h3>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾Ø±ÙˆÚ˜Ù‡ (Config)</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/config.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from pydantic_settings import BaseSettings
from functools import lru_cache
from typing import Optional


class Settings(BaseSettings):
    """Application settings with environment variables."""
    
    # App
    APP_NAME: str = "GeoAI FastAPI"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = False
    
    # Server
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # Database
    DATABASE_URL: str = "postgresql+asyncpg://user:pass@localhost:5432/geoai"
    
    # Redis
    REDIS_URL: str = "redis://localhost:6379/0"
    
    # Security
    SECRET_KEY: str = "your-super-secret-key-change-in-production"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # AI/ML
    ML_MODELS_PATH: str = "./ml_models"
    OBJECT_DETECTION_MODEL: str = "yolov8n.pt"
    SEGMENTATION_MODEL: str = "sam_vit_h.pth"
    
    # OpenAI
    OPENAI_API_KEY: Optional[str] = None
    
    # Ollama (Local LLM)
    OLLAMA_BASE_URL: str = "http://localhost:11434"
    OLLAMA_MODEL: str = "llama2"
    
    # GeoSpatial
    DEFAULT_SRID: int = 4326
    DEFAULT_BUFFER_DISTANCE: float = 1000.0  # meters
    
    # File Storage
    UPLOAD_DIR: str = "./uploads"
    MAX_UPLOAD_SIZE: int = 100 * 1024 * 1024  # 100MB
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()


settings = get_settings()</code></pre>
                </div>
            </div>

            <h3>ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ FastAPI</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/main.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
import logging

from app.config import settings
from app.api.v1.router import api_router
from app.db.session import engine
from app.core.middleware import RequestLoggingMiddleware
from app.ml.object_detection import ObjectDetector

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Global ML models (loaded once at startup)
ml_models = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Application lifespan manager.
    Load resources at startup, cleanup at shutdown.
    """
    # Startup
    logger.info("ğŸš€ Starting GeoAI FastAPI...")
    
    # Load ML models
    logger.info("ğŸ“¦ Loading ML models...")
    try:
        ml_models["object_detector"] = ObjectDetector(
            model_path=f"{settings.ML_MODELS_PATH}/{settings.OBJECT_DETECTION_MODEL}"
        )
        logger.info("âœ… Object detection model loaded")
    except Exception as e:
        logger.warning(f"âš ï¸ Could not load object detection model: {e}")
    
    logger.info("âœ… Application started successfully!")
    
    yield
    
    # Shutdown
    logger.info("ğŸ›‘ Shutting down GeoAI FastAPI...")
    ml_models.clear()


# Create FastAPI app
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="""
    ğŸŒ **GeoAI FastAPI** - Geospatial API with AI capabilities
    
    ## Features
    
    * ğŸ—ºï¸ **GeoSpatial Operations** - Buffer, Intersect, Union, etc.
    * ğŸ¤– **AI/ML Integration** - Object detection, segmentation
    * ğŸ“¡ **Satellite Imagery** - Process and analyze satellite data
    * ğŸ” **Spatial Queries** - PostGIS powered queries
    * ğŸ’¬ **Natural Language** - Query geo data with LLM
    """,
    lifespan=lifespan,
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json"
)

# CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Custom Middleware
app.add_middleware(RequestLoggingMiddleware)

# Include routers
app.include_router(api_router, prefix="/api/v1")


@app.get("/", tags=["Root"])
async def root():
    """Root endpoint with API info."""
    return {
        "name": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "docs": "/docs",
        "health": "/health"
    }


@app.get("/health", tags=["Health"])
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "models_loaded": list(ml_models.keys()),
        "database": "connected"
    }


# Get ML models in routes
def get_ml_models():
    return ml_models


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG
    )</code></pre>
                </div>
            </div>

            <h3>Docker Compose</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon json">yml</div>
                        <span class="code-filename">docker/docker-compose.yml</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-yaml">version: '3.9'

services:
  # FastAPI Application
  api:
    build:
      context: ..
      dockerfile: docker/Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://geoai:geoai@db:5432/geoai
      - REDIS_URL=redis://redis:6379/0
      - OLLAMA_BASE_URL=http://ollama:11434
    volumes:
      - ../ml_models:/app/ml_models
      - ../uploads:/app/uploads
    depends_on:
      - db
      - redis
    restart: unless-stopped

  # PostgreSQL + PostGIS
  db:
    image: postgis/postgis:16-3.4
    environment:
      - POSTGRES_USER=geoai
      - POSTGRES_PASSWORD=geoai
      - POSTGRES_DB=geoai
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  # Ollama (Local LLM)
  ollama:
    image: ollama/ollama:latest
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama
    restart: unless-stopped

  # Martin (Vector Tiles Server)
  martin:
    image: ghcr.io/maplibre/martin:latest
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://geoai:geoai@db:5432/geoai
    depends_on:
      - db
    restart: unless-stopped

  # Celery Worker
  celery:
    build:
      context: ..
      dockerfile: docker/Dockerfile
    command: celery -A app.worker worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql+asyncpg://geoai:geoai@db:5432/geoai
      - REDIS_URL=redis://redis:6379/0
    volumes:
      - ../ml_models:/app/ml_models
    depends_on:
      - db
      - redis
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  ollama_data:</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 3: GEOSPATIAL BASICS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="geo-basics">
            <div class="section-header">
                <div class="section-icon">ğŸ—ºï¸</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û³</div>
                    <h2 class="section-title">Ù…Ø¨Ø§Ù†ÛŒ GeoSpatial Ø¯Ø± FastAPI</h2>
                    <p class="section-subtitle">PostGIS, Shapely, GeoJSON Ùˆ Pydantic</p>
                </div>
            </div>

            <h3>Schema Ù‡Ø§ÛŒ GeoJSON Ø¨Ø§ Pydantic</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/schemas/geo.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Union, Literal, Any
from enum import Enum


class GeometryType(str, Enum):
    """GeoJSON geometry types."""
    POINT = "Point"
    LINE_STRING = "LineString"
    POLYGON = "Polygon"
    MULTI_POINT = "MultiPoint"
    MULTI_LINE_STRING = "MultiLineString"
    MULTI_POLYGON = "MultiPolygon"
    GEOMETRY_COLLECTION = "GeometryCollection"


class PointCoordinates(BaseModel):
    """Point coordinates [lon, lat] or [lon, lat, elevation]."""
    coordinates: List[float] = Field(..., min_length=2, max_length=3)
    
    @field_validator('coordinates')
    @classmethod
    def validate_coordinates(cls, v):
        lon, lat = v[0], v[1]
        if not (-180 <= lon <= 180):
            raise ValueError(f"Longitude must be between -180 and 180, got {lon}")
        if not (-90 <= lat <= 90):
            raise ValueError(f"Latitude must be between -90 and 90, got {lat}")
        return v


class GeoJSONPoint(BaseModel):
    """GeoJSON Point geometry."""
    type: Literal["Point"] = "Point"
    coordinates: List[float] = Field(..., min_length=2, max_length=3)
    
    class Config:
        json_schema_extra = {
            "example": {
                "type": "Point",
                "coordinates": [51.389, 35.689]
            }
        }


class GeoJSONLineString(BaseModel):
    """GeoJSON LineString geometry."""
    type: Literal["LineString"] = "LineString"
    coordinates: List[List[float]]
    
    @field_validator('coordinates')
    @classmethod
    def validate_line(cls, v):
        if len(v) < 2:
            raise ValueError("LineString must have at least 2 points")
        return v


class GeoJSONPolygon(BaseModel):
    """GeoJSON Polygon geometry."""
    type: Literal["Polygon"] = "Polygon"
    coordinates: List[List[List[float]]]
    
    @field_validator('coordinates')
    @classmethod
    def validate_polygon(cls, v):
        for ring in v:
            if len(ring) < 4:
                raise ValueError("Polygon ring must have at least 4 points")
            if ring[0] != ring[-1]:
                raise ValueError("Polygon ring must be closed")
        return v
    
    class Config:
        json_schema_extra = {
            "example": {
                "type": "Polygon",
                "coordinates": [[[51.0, 35.0], [52.0, 35.0], [52.0, 36.0], [51.0, 36.0], [51.0, 35.0]]]
            }
        }


# Union of all geometry types
GeoJSONGeometry = Union[GeoJSONPoint, GeoJSONLineString, GeoJSONPolygon]


class GeoJSONFeature(BaseModel):
    """GeoJSON Feature."""
    type: Literal["Feature"] = "Feature"
    geometry: GeoJSONGeometry
    properties: Optional[dict] = {}
    id: Optional[Union[str, int]] = None


class GeoJSONFeatureCollection(BaseModel):
    """GeoJSON FeatureCollection."""
    type: Literal["FeatureCollection"] = "FeatureCollection"
    features: List[GeoJSONFeature]
    
    class Config:
        json_schema_extra = {
            "example": {
                "type": "FeatureCollection",
                "features": [
                    {
                        "type": "Feature",
                        "geometry": {"type": "Point", "coordinates": [51.389, 35.689]},
                        "properties": {"name": "Tehran"}
                    }
                ]
            }
        }


# Request/Response schemas
class BufferRequest(BaseModel):
    """Buffer operation request."""
    geometry: GeoJSONGeometry
    distance: float = Field(..., gt=0, description="Buffer distance in meters")
    srid: int = Field(default=4326, description="Spatial Reference ID")


class BufferResponse(BaseModel):
    """Buffer operation response."""
    original: GeoJSONGeometry
    buffered: GeoJSONPolygon
    distance: float
    area_sqm: float


class SpatialQueryRequest(BaseModel):
    """Spatial query request."""
    geometry: GeoJSONGeometry
    operation: Literal["intersects", "contains", "within", "touches"] = "intersects"
    layer: str
    limit: int = Field(default=100, le=1000)


class DistanceRequest(BaseModel):
    """Distance calculation request."""
    from_point: GeoJSONPoint
    to_point: GeoJSONPoint
    unit: Literal["meters", "kilometers", "miles"] = "meters"


class DistanceResponse(BaseModel):
    """Distance calculation response."""
    distance: float
    unit: str
    from_point: GeoJSONPoint
    to_point: GeoJSONPoint</code></pre>
                </div>
            </div>

            <h3>Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Database Ø¨Ø§ GeoAlchemy2</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/models/geo.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from geoalchemy2 import Geometry
from geoalchemy2.shape import to_shape, from_shape
from datetime import datetime
import json

from app.db.base import Base


class SpatialLayer(Base):
    """Base model for spatial layers."""
    __tablename__ = "spatial_layers"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), unique=True, index=True)
    description = Column(Text, nullable=True)
    geometry_type = Column(String(50))  # Point, LineString, Polygon, etc.
    srid = Column(Integer, default=4326)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    features = relationship("SpatialFeature", back_populates="layer", cascade="all, delete-orphan")


class SpatialFeature(Base):
    """Model for spatial features."""
    __tablename__ = "spatial_features"
    
    id = Column(Integer, primary_key=True, index=True)
    layer_id = Column(Integer, ForeignKey("spatial_layers.id"), index=True)
    
    # Geometry column with spatial index
    geom = Column(
        Geometry(geometry_type="GEOMETRY", srid=4326, spatial_index=True),
        nullable=False
    )
    
    # Properties stored as JSON
    properties = Column(Text, default="{}")
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    layer = relationship("SpatialLayer", back_populates="features")
    
    @property
    def shapely_geom(self):
        """Convert to Shapely geometry."""
        return to_shape(self.geom)
    
    @shapely_geom.setter
    def shapely_geom(self, shape):
        """Set from Shapely geometry."""
        self.geom = from_shape(shape, srid=4326)
    
    @property
    def props(self) -> dict:
        """Get properties as dict."""
        return json.loads(self.properties) if self.properties else {}
    
    @props.setter
    def props(self, value: dict):
        """Set properties from dict."""
        self.properties = json.dumps(value)
    
    def to_geojson_feature(self) -> dict:
        """Convert to GeoJSON Feature."""
        from shapely.geometry import mapping
        return {
            "type": "Feature",
            "id": self.id,
            "geometry": mapping(self.shapely_geom),
            "properties": {
                **self.props,
                "layer_id": self.layer_id,
                "created_at": self.created_at.isoformat() if self.created_at else None
            }
        }


class POI(Base):
    """Points of Interest model."""
    __tablename__ = "pois"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), index=True)
    category = Column(String(100), index=True)
    description = Column(Text, nullable=True)
    
    # Point geometry
    location = Column(
        Geometry(geometry_type="POINT", srid=4326, spatial_index=True),
        nullable=False
    )
    
    # Additional fields
    address = Column(String(500), nullable=True)
    phone = Column(String(50), nullable=True)
    website = Column(String(255), nullable=True)
    rating = Column(Float, nullable=True)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    @property
    def coordinates(self) -> tuple:
        """Get (lon, lat) tuple."""
        point = to_shape(self.location)
        return (point.x, point.y)


class Road(Base):
    """Road network model."""
    __tablename__ = "roads"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=True)
    road_type = Column(String(50), index=True)  # highway, primary, secondary, etc.
    
    # LineString geometry
    geom = Column(
        Geometry(geometry_type="LINESTRING", srid=4326, spatial_index=True),
        nullable=False
    )
    
    # Road properties
    length_m = Column(Float)  # Length in meters
    speed_limit = Column(Integer, nullable=True)
    one_way = Column(String(10), default="no")
    
    @property
    def length_km(self) -> float:
        """Get length in kilometers."""
        return self.length_m / 1000 if self.length_m else 0</code></pre>
                </div>
            </div>

            <h3>Ø³Ø±ÙˆÛŒØ³ GeoSpatial</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/services/geo_service.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from typing import List, Optional, Dict, Any
from shapely.geometry import shape, mapping, Point, LineString, Polygon
from shapely.ops import transform, unary_union
from shapely import wkt, wkb
import pyproj
from functools import partial
import json

from geoalchemy2 import functions as func
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.geo import SpatialFeature, SpatialLayer, POI
from app.schemas.geo import GeoJSONGeometry, GeoJSONFeatureCollection


class GeoService:
    """Service for geospatial operations."""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # GEOMETRY OPERATIONS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    @staticmethod
    def geojson_to_shapely(geojson: dict) -> Any:
        """Convert GeoJSON to Shapely geometry."""
        return shape(geojson)
    
    @staticmethod
    def shapely_to_geojson(geom) -> dict:
        """Convert Shapely geometry to GeoJSON."""
        return mapping(geom)
    
    @staticmethod
    def reproject(geom, from_srid: int = 4326, to_srid: int = 32640):
        """
        Reproject geometry between coordinate systems.
        Default: WGS84 (4326) to UTM 40N (32640) for Iran
        """
        project = pyproj.Transformer.from_crs(
            f"EPSG:{from_srid}",
            f"EPSG:{to_srid}",
            always_xy=True
        ).transform
        return transform(project, geom)
    
    def buffer(
        self,
        geojson: dict,
        distance: float,
        srid: int = 4326,
        cap_style: int = 1,
        join_style: int = 1
    ) -> dict:
        """
        Create buffer around geometry.
        
        Args:
            geojson: Input GeoJSON geometry
            distance: Buffer distance in meters
            srid: Spatial Reference ID
            cap_style: 1=round, 2=flat, 3=square
            join_style: 1=round, 2=mitre, 3=bevel
        
        Returns:
            Buffered geometry as GeoJSON
        """
        # Convert to Shapely
        geom = self.geojson_to_shapely(geojson)
        
        # Reproject to UTM for accurate distance calculation
        geom_utm = self.reproject(geom, from_srid=srid, to_srid=32640)
        
        # Create buffer
        buffered_utm = geom_utm.buffer(
            distance,
            cap_style=cap_style,
            join_style=join_style
        )
        
        # Reproject back to original CRS
        buffered = self.reproject(buffered_utm, from_srid=32640, to_srid=srid)
        
        return self.shapely_to_geojson(buffered)
    
    def calculate_area(self, geojson: dict, srid: int = 4326) -> float:
        """Calculate area in square meters."""
        geom = self.geojson_to_shapely(geojson)
        geom_utm = self.reproject(geom, from_srid=srid, to_srid=32640)
        return geom_utm.area
    
    def calculate_length(self, geojson: dict, srid: int = 4326) -> float:
        """Calculate length in meters (for lines)."""
        geom = self.geojson_to_shapely(geojson)
        geom_utm = self.reproject(geom, from_srid=srid, to_srid=32640)
        return geom_utm.length
    
    def calculate_distance(
        self,
        point1: dict,
        point2: dict,
        srid: int = 4326
    ) -> float:
        """Calculate distance between two points in meters."""
        geom1 = self.geojson_to_shapely(point1)
        geom2 = self.geojson_to_shapely(point2)
        
        geom1_utm = self.reproject(geom1, from_srid=srid, to_srid=32640)
        geom2_utm = self.reproject(geom2, from_srid=srid, to_srid=32640)
        
        return geom1_utm.distance(geom2_utm)
    
    def intersection(self, geojson1: dict, geojson2: dict) -> Optional[dict]:
        """Get intersection of two geometries."""
        geom1 = self.geojson_to_shapely(geojson1)
        geom2 = self.geojson_to_shapely(geojson2)
        
        result = geom1.intersection(geom2)
        
        if result.is_empty:
            return None
        
        return self.shapely_to_geojson(result)
    
    def union(self, geometries: List[dict]) -> dict:
        """Union multiple geometries."""
        shapes = [self.geojson_to_shapely(g) for g in geometries]
        result = unary_union(shapes)
        return self.shapely_to_geojson(result)
    
    def centroid(self, geojson: dict) -> dict:
        """Get centroid of geometry."""
        geom = self.geojson_to_shapely(geojson)
        return self.shapely_to_geojson(geom.centroid)
    
    def convex_hull(self, geojson: dict) -> dict:
        """Get convex hull of geometry."""
        geom = self.geojson_to_shapely(geojson)
        return self.shapely_to_geojson(geom.convex_hull)
    
    def simplify(self, geojson: dict, tolerance: float = 0.001) -> dict:
        """Simplify geometry."""
        geom = self.geojson_to_shapely(geojson)
        simplified = geom.simplify(tolerance, preserve_topology=True)
        return self.shapely_to_geojson(simplified)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DATABASE OPERATIONS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def spatial_query(
        self,
        geojson: dict,
        layer_name: str,
        operation: str = "intersects",
        limit: int = 100
    ) -> List[dict]:
        """
        Perform spatial query on a layer.
        
        Args:
            geojson: Query geometry
            layer_name: Target layer name
            operation: intersects, contains, within, touches
            limit: Max results
        
        Returns:
            List of GeoJSON features
        """
        # Convert GeoJSON to WKT
        geom = self.geojson_to_shapely(geojson)
        geom_wkt = geom.wkt
        
        # Get layer
        layer_query = select(SpatialLayer).where(SpatialLayer.name == layer_name)
        result = await self.db.execute(layer_query)
        layer = result.scalar_one_or_none()
        
        if not layer:
            raise ValueError(f"Layer '{layer_name}' not found")
        
        # Build spatial query
        query_geom = func.ST_GeomFromText(geom_wkt, 4326)
        
        if operation == "intersects":
            spatial_filter = func.ST_Intersects(SpatialFeature.geom, query_geom)
        elif operation == "contains":
            spatial_filter = func.ST_Contains(SpatialFeature.geom, query_geom)
        elif operation == "within":
            spatial_filter = func.ST_Within(SpatialFeature.geom, query_geom)
        elif operation == "touches":
            spatial_filter = func.ST_Touches(SpatialFeature.geom, query_geom)
        else:
            raise ValueError(f"Unknown operation: {operation}")
        
        query = (
            select(SpatialFeature)
            .where(and_(
                SpatialFeature.layer_id == layer.id,
                spatial_filter
            ))
            .limit(limit)
        )
        
        result = await self.db.execute(query)
        features = result.scalars().all()
        
        return [f.to_geojson_feature() for f in features]
    
    async def find_nearest(
        self,
        point: dict,
        layer_name: str,
        limit: int = 10,
        max_distance: float = None
    ) -> List[dict]:
        """Find nearest features to a point."""
        geom = self.geojson_to_shapely(point)
        point_wkt = geom.wkt
        
        # Get layer
        layer_query = select(SpatialLayer).where(SpatialLayer.name == layer_name)
        result = await self.db.execute(layer_query)
        layer = result.scalar_one_or_none()
        
        if not layer:
            raise ValueError(f"Layer '{layer_name}' not found")
        
        query_point = func.ST_GeomFromText(point_wkt, 4326)
        
        # Query with distance
        query = (
            select(
                SpatialFeature,
                func.ST_Distance(
                    func.ST_Transform(SpatialFeature.geom, 32640),
                    func.ST_Transform(query_point, 32640)
                ).label('distance')
            )
            .where(SpatialFeature.layer_id == layer.id)
            .order_by('distance')
            .limit(limit)
        )
        
        if max_distance:
            query = query.where(
                func.ST_DWithin(
                    func.ST_Transform(SpatialFeature.geom, 32640),
                    func.ST_Transform(query_point, 32640),
                    max_distance
                )
            )
        
        result = await self.db.execute(query)
        rows = result.all()
        
        features = []
        for feature, distance in rows:
            geojson = feature.to_geojson_feature()
            geojson['properties']['distance_m'] = distance
            features.append(geojson)
        
        return features
    
    async def create_feature(
        self,
        layer_name: str,
        geojson: dict,
        properties: dict = None
    ) -> dict:
        """Create a new feature in a layer."""
        # Get layer
        layer_query = select(SpatialLayer).where(SpatialLayer.name == layer_name)
        result = await self.db.execute(layer_query)
        layer = result.scalar_one_or_none()
        
        if not layer:
            raise ValueError(f"Layer '{layer_name}' not found")
        
        # Create feature
        geom = self.geojson_to_shapely(geojson)
        
        feature = SpatialFeature(
            layer_id=layer.id,
            properties=json.dumps(properties or {})
        )
        feature.shapely_geom = geom
        
        self.db.add(feature)
        await self.db.commit()
        await self.db.refresh(feature)
        
        return feature.to_geojson_feature()</code></pre>
                </div>
            </div>

            <h3>API Endpoints Ø¨Ø±Ø§ÛŒ GeoSpatial</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/api/v1/geo.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Optional

from app.api.deps import get_db
from app.services.geo_service import GeoService
from app.schemas.geo import (
    GeoJSONGeometry,
    GeoJSONFeatureCollection,
    BufferRequest,
    BufferResponse,
    SpatialQueryRequest,
    DistanceRequest,
    DistanceResponse
)

router = APIRouter(prefix="/geo", tags=["GeoSpatial"])


@router.post("/buffer", response_model=BufferResponse)
async def create_buffer(
    request: BufferRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Create a buffer around a geometry.
    
    - **geometry**: Input GeoJSON geometry
    - **distance**: Buffer distance in meters
    - **srid**: Spatial Reference ID (default: 4326)
    """
    geo_service = GeoService(db)
    
    buffered = geo_service.buffer(
        geojson=request.geometry.model_dump(),
        distance=request.distance,
        srid=request.srid
    )
    
    area = geo_service.calculate_area(buffered, srid=request.srid)
    
    return BufferResponse(
        original=request.geometry,
        buffered=buffered,
        distance=request.distance,
        area_sqm=area
    )


@router.post("/distance", response_model=DistanceResponse)
async def calculate_distance(
    request: DistanceRequest,
    db: AsyncSession = Depends(get_db)
):
    """Calculate distance between two points."""
    geo_service = GeoService(db)
    
    distance = geo_service.calculate_distance(
        point1=request.from_point.model_dump(),
        point2=request.to_point.model_dump()
    )
    
    # Convert units
    if request.unit == "kilometers":
        distance = distance / 1000
    elif request.unit == "miles":
        distance = distance / 1609.344
    
    return DistanceResponse(
        distance=round(distance, 2),
        unit=request.unit,
        from_point=request.from_point,
        to_point=request.to_point
    )


@router.post("/area")
async def calculate_area(
    geometry: GeoJSONGeometry,
    db: AsyncSession = Depends(get_db)
):
    """Calculate area of a polygon in square meters."""
    geo_service = GeoService(db)
    
    if geometry.type not in ["Polygon", "MultiPolygon"]:
        raise HTTPException(
            status_code=400,
            detail="Area can only be calculated for Polygon or MultiPolygon"
        )
    
    area = geo_service.calculate_area(geometry.model_dump())
    
    return {
        "area_sqm": round(area, 2),
        "area_hectares": round(area / 10000, 4),
        "area_sqkm": round(area / 1000000, 6)
    }


@router.post("/centroid")
async def get_centroid(
    geometry: GeoJSONGeometry,
    db: AsyncSession = Depends(get_db)
):
    """Get centroid of a geometry."""
    geo_service = GeoService(db)
    centroid = geo_service.centroid(geometry.model_dump())
    
    return {
        "type": "Feature",
        "geometry": centroid,
        "properties": {"type": "centroid"}
    }


@router.post("/intersection")
async def get_intersection(
    geometry1: GeoJSONGeometry,
    geometry2: GeoJSONGeometry,
    db: AsyncSession = Depends(get_db)
):
    """Get intersection of two geometries."""
    geo_service = GeoService(db)
    
    result = geo_service.intersection(
        geometry1.model_dump(),
        geometry2.model_dump()
    )
    
    if result is None:
        return {"intersects": False, "geometry": None}
    
    return {
        "intersects": True,
        "geometry": result,
        "area_sqm": geo_service.calculate_area(result) if result.get("type") in ["Polygon", "MultiPolygon"] else None
    }


@router.post("/union")
async def union_geometries(
    geometries: List[GeoJSONGeometry],
    db: AsyncSession = Depends(get_db)
):
    """Union multiple geometries."""
    if len(geometries) < 2:
        raise HTTPException(
            status_code=400,
            detail="At least 2 geometries required for union"
        )
    
    geo_service = GeoService(db)
    result = geo_service.union([g.model_dump() for g in geometries])
    
    return {
        "type": "Feature",
        "geometry": result,
        "properties": {"operation": "union", "input_count": len(geometries)}
    }


@router.post("/simplify")
async def simplify_geometry(
    geometry: GeoJSONGeometry,
    tolerance: float = Query(default=0.001, ge=0.0001, le=1.0),
    db: AsyncSession = Depends(get_db)
):
    """Simplify a geometry."""
    geo_service = GeoService(db)
    simplified = geo_service.simplify(geometry.model_dump(), tolerance)
    
    return {
        "type": "Feature",
        "geometry": simplified,
        "properties": {"tolerance": tolerance}
    }


@router.post("/query")
async def spatial_query(
    request: SpatialQueryRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Perform spatial query on a layer.
    
    Operations: intersects, contains, within, touches
    """
    geo_service = GeoService(db)
    
    try:
        features = await geo_service.spatial_query(
            geojson=request.geometry.model_dump(),
            layer_name=request.layer,
            operation=request.operation,
            limit=request.limit
        )
        
        return {
            "type": "FeatureCollection",
            "features": features,
            "count": len(features),
            "query": {
                "layer": request.layer,
                "operation": request.operation
            }
        }
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.post("/nearest")
async def find_nearest(
    point: GeoJSONGeometry,
    layer: str,
    limit: int = Query(default=10, le=100),
    max_distance: Optional[float] = Query(default=None, description="Max distance in meters"),
    db: AsyncSession = Depends(get_db)
):
    """Find nearest features to a point."""
    if point.type != "Point":
        raise HTTPException(status_code=400, detail="Input must be a Point geometry")
    
    geo_service = GeoService(db)
    
    try:
        features = await geo_service.find_nearest(
            point=point.model_dump(),
            layer_name=layer,
            limit=limit,
            max_distance=max_distance
        )
        
        return {
            "type": "FeatureCollection",
            "features": features,
            "count": len(features)
        }
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))</code></pre>
                </div>
            </div>

            <div class="info-box tip">
                <div class="info-box-title">
                    <span>ğŸ’¡</span>
                    Ù†Ú©ØªÙ‡ Ù…Ù‡Ù…
                </div>
                <div class="info-box-content">
                    <p>
                        Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ø¯Ù‚ÛŒÙ‚ Ù…Ø³Ø§Ø­Øª Ùˆ ÙØ§ØµÙ„Ù‡ Ø¯Ø± Ø§ÛŒØ±Ø§Ù†ØŒ Ø§Ø² <code>EPSG:32640</code> (UTM Zone 40N) Ø§Ø³ØªÙØ§Ø¯Ù‡
                        Ú©Ù†ÛŒØ¯.
                        Ø§ÛŒÙ† Ø³ÛŒØ³ØªÙ… Ù…Ø®ØªØµØ§Øª Ø¨Ø±Ø§ÛŒ Ù…Ù†Ø§Ø·Ù‚ Ø¨ÛŒÙ† Ø·ÙˆÙ„ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ ÛµÛ´ ØªØ§ Û¶Û° Ø¯Ø±Ø¬Ù‡ Ø´Ø±Ù‚ÛŒ Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³Øª.
                    </p>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 4: AI INTEGRATION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="ai-integration">
            <div class="section-header">
                <div class="section-icon">ğŸ¤–</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ú†Ù‡Ø§Ø±Ù…</div>
                    <h2 class="section-title">ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h2>
                    <p class="section-subtitle">AI Integration Ø¯Ø± GeoSpatial Applications</p>
                </div>
            </div>

            <p>
                Ø¯Ø± Ø§ÛŒÙ† ÙØµÙ„ØŒ Ù†Ø­ÙˆÙ‡ ØªØ±Ú©ÛŒØ¨ Ù‚Ø¯Ø±Øª <strong>Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</strong> Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø±Ø§ ÛŒØ§Ø¯ Ù…ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ….
                Ø§Ø² ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§Ø¡ Ø¯Ø± ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ Ú¯Ø±ÙØªÙ‡ ØªØ§ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ùˆ
                Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø²Ø¨Ø§Ù† Ø·Ø¨ÛŒØ¹ÛŒ Ø¨Ø±Ø§ÛŒ Ú©ÙˆØ¦Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ.
            </p>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.1: OVERVIEW
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û± Ù…Ø¹Ø±ÙÛŒ GeoAI</h3>

            <p>
                <strong>GeoAI</strong> ØªØ±Ú©ÛŒØ¨ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¨Ø§ Ø¹Ù„ÙˆÙ… Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ø§Ø³Øª Ú©Ù‡ Ø§Ù…Ú©Ø§Ù† ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ
                Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø±ÙˆÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø±Ø§ ÙØ±Ø§Ù‡Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
            </p>

            <div class="technique-grid">
                <div class="technique-card">
                    <div class="technique-icon">ğŸ›°ï¸</div>
                    <div class="technique-name">ØªØ­Ù„ÛŒÙ„ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</div>
                    <div class="technique-desc">
                        ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§Ø¡ØŒ Ø·Ø¨Ù‚Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø²Ù…ÛŒÙ†ØŒ ØªØºÛŒÛŒØ±Ø§Øª Ù…Ø­ÛŒØ·ÛŒ
                    </div>
                </div>

                <div class="technique-card">
                    <div class="technique-icon">ğŸ“</div>
                    <div class="technique-name">Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…Ú©Ø§Ù†ÛŒ</div>
                    <div class="technique-desc">
                        Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ ØªØ±Ø§ÙÛŒÚ©ØŒ ØªÙ‚Ø§Ø¶Ø§ØŒ Ú¯Ø³ØªØ±Ø´ Ø´Ù‡Ø±ÛŒ
                    </div>
                </div>

                <div class="technique-card">
                    <div class="technique-icon">ğŸ’¬</div>
                    <div class="technique-name">NLP Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ</div>
                    <div class="technique-desc">
                        Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§Ø² Ù…ØªÙ†ØŒ Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ú©Ø§Ù†ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯
                    </div>
                </div>

                <div class="technique-card">
                    <div class="technique-icon">ğŸ¯</div>
                    <div class="technique-name">Ø®ÙˆØ´Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ú©Ø§Ù†ÛŒ</div>
                    <div class="technique-desc">
                        Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø§Ù„Ú¯ÙˆÙ‡Ø§ØŒ Ù†Ù‚Ø§Ø· Ø¯Ø§ØºØŒ Ø¢Ù†ÙˆÙ…Ø§Ù„ÛŒâ€ŒÙ‡Ø§
                    </div>
                </div>
            </div>

            <div class="info-box info">
                <div class="info-box-title">
                    <span>ğŸ“š</span>
                    Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²
                </div>
                <div class="info-box-content">
                    <pre style="direction: ltr; text-align: left; margin: 0;">
pip install fastapi uvicorn
pip install sqlalchemy geoalchemy2
pip install shapely geojson
pip install openai langchain
pip install torch torchvision
pip install transformers
pip install scikit-learn
pip install rasterio
pip install opencv-python
pip install numpy pandas
</pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.2: PROJECT STRUCTURE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û² Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ“</span>
                        <span>Project Structure</span>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-plaintext">geoai_fastapi/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ config.py
â”‚   â”‚
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ database.py
â”‚   â”‚   â”œâ”€â”€ spatial.py
â”‚   â”‚   â””â”€â”€ predictions.py
â”‚   â”‚
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ geometry.py
â”‚   â”‚   â”œâ”€â”€ analysis.py
â”‚   â”‚   â””â”€â”€ ai_requests.py
â”‚   â”‚
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ spatial.py
â”‚   â”‚   â”‚   â”œâ”€â”€ analysis.py
â”‚   â”‚   â”‚   â”œâ”€â”€ prediction.py
â”‚   â”‚   â”‚   â””â”€â”€ nlp.py
â”‚   â”‚   â””â”€â”€ router.py
â”‚   â”‚
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ ai_service.py
â”‚   â”‚   â”œâ”€â”€ spatial_service.py
â”‚   â”‚   â”œâ”€â”€ image_service.py
â”‚   â”‚   â”œâ”€â”€ nlp_service.py
â”‚   â”‚   â””â”€â”€ prediction_service.py
â”‚   â”‚
â”‚   â”œâ”€â”€ ml/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ satellite_classifier.py
â”‚   â”‚   â”‚   â”œâ”€â”€ object_detector.py
â”‚   â”‚   â”‚   â””â”€â”€ spatial_predictor.py
â”‚   â”‚   â”œâ”€â”€ preprocessing.py
â”‚   â”‚   â””â”€â”€ inference.py
â”‚   â”‚
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ geo_utils.py
â”‚       â””â”€â”€ ai_utils.py
â”‚
â”œâ”€â”€ ml_models/
â”‚   â”œâ”€â”€ land_use_classifier.pt
â”‚   â”œâ”€â”€ object_detector.pt
â”‚   â””â”€â”€ embeddings/
â”‚
â”œâ”€â”€ tests/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â””â”€â”€ requirements.txt</code></pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.3: CONFIGURATION
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û³ Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ</span>
                        <span>app/config.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn copy-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from pydantic_settings import BaseSettings
from functools import lru_cache
from typing import Optional
import os


class Settings(BaseSettings):
    """Application Settings"""
    
    # App
    APP_NAME: str = "GeoAI FastAPI"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = False
    
    # Database
    DATABASE_URL: str = "postgresql://user:pass@localhost:5432/geoai_db"
    
    # Redis (for caching)
    REDIS_URL: str = "redis://localhost:6379/0"
    
    # OpenAI
    OPENAI_API_KEY: str = ""
    OPENAI_MODEL: str = "gpt-4"
    
    # ML Models
    ML_MODELS_PATH: str = "./ml_models"
    SATELLITE_MODEL_PATH: str = "./ml_models/land_use_classifier.pt"
    OBJECT_DETECTOR_PATH: str = "./ml_models/object_detector.pt"
    
    # Image Processing
    MAX_IMAGE_SIZE: int = 10 * 1024 * 1024  # 10MB
    SUPPORTED_IMAGE_FORMATS: list = ["jpg", "jpeg", "png", "tif", "tiff"]
    
    # Spatial Settings
    DEFAULT_SRID: int = 4326
    DEFAULT_BUFFER_DISTANCE: float = 1000  # meters
    
    # Rate Limiting
    RATE_LIMIT_PER_MINUTE: int = 60
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """Get cached settings instance"""
    return Settings()


settings = get_settings()</code></pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.4: SCHEMAS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û´ ØªØ¹Ø±ÛŒÙ Schemas</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ</span>
                        <span>app/schemas/ai_requests.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn copy-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from pydantic import BaseModel, Field, validator
from typing import Optional, List, Dict, Any, Literal
from enum import Enum
from datetime import datetime


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Enums
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class LandUseType(str, Enum):
    """Land use classification types"""
    RESIDENTIAL = "residential"
    COMMERCIAL = "commercial"
    INDUSTRIAL = "industrial"
    AGRICULTURAL = "agricultural"
    FOREST = "forest"
    WATER = "water"
    BARREN = "barren"
    URBAN = "urban"


class AnalysisType(str, Enum):
    """Types of spatial analysis"""
    CLUSTERING = "clustering"
    HOTSPOT = "hotspot"
    INTERPOLATION = "interpolation"
    PREDICTION = "prediction"
    CLASSIFICATION = "classification"


class ObjectType(str, Enum):
    """Detectable object types in satellite imagery"""
    BUILDING = "building"
    ROAD = "road"
    VEHICLE = "vehicle"
    VEGETATION = "vegetation"
    WATER_BODY = "water_body"
    SOLAR_PANEL = "solar_panel"
    SWIMMING_POOL = "swimming_pool"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Geometry Schemas
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PointGeometry(BaseModel):
    """Point geometry schema"""
    type: Literal["Point"] = "Point"
    coordinates: List[float] = Field(..., min_items=2, max_items=3)
    
    @validator('coordinates')
    def validate_coordinates(cls, v):
        if len(v) < 2:
            raise ValueError('Coordinates must have at least 2 values (lon, lat)')
        lon, lat = v[0], v[1]
        if not (-180 <= lon <= 180):
            raise ValueError('Longitude must be between -180 and 180')
        if not (-90 <= lat <= 90):
            raise ValueError('Latitude must be between -90 and 90')
        return v


class PolygonGeometry(BaseModel):
    """Polygon geometry schema"""
    type: Literal["Polygon"] = "Polygon"
    coordinates: List[List[List[float]]]


class BoundingBox(BaseModel):
    """Bounding box schema"""
    min_lon: float = Field(..., ge=-180, le=180)
    min_lat: float = Field(..., ge=-90, le=90)
    max_lon: float = Field(..., ge=-180, le=180)
    max_lat: float = Field(..., ge=-90, le=90)
    
    @validator('max_lon')
    def validate_lon(cls, v, values):
        if 'min_lon' in values and v <= values['min_lon']:
            raise ValueError('max_lon must be greater than min_lon')
        return v
    
    @validator('max_lat')
    def validate_lat(cls, v, values):
        if 'min_lat' in values and v <= values['min_lat']:
            raise ValueError('max_lat must be greater than min_lat')
        return v


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AI Request Schemas
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ImageClassificationRequest(BaseModel):
    """Request for satellite image classification"""
    image_url: Optional[str] = None
    image_base64: Optional[str] = None
    bounding_box: Optional[BoundingBox] = None
    classification_type: LandUseType = LandUseType.URBAN
    confidence_threshold: float = Field(default=0.7, ge=0.0, le=1.0)
    
    @validator('image_base64')
    def validate_image(cls, v, values):
        if not v and not values.get('image_url'):
            raise ValueError('Either image_url or image_base64 must be provided')
        return v


class ObjectDetectionRequest(BaseModel):
    """Request for object detection in imagery"""
    image_url: Optional[str] = None
    image_base64: Optional[str] = None
    bounding_box: Optional[BoundingBox] = None
    object_types: List[ObjectType] = Field(default=[ObjectType.BUILDING])
    confidence_threshold: float = Field(default=0.5, ge=0.0, le=1.0)
    max_detections: int = Field(default=100, ge=1, le=1000)


class SpatialPredictionRequest(BaseModel):
    """Request for spatial prediction"""
    geometry: PolygonGeometry
    prediction_type: AnalysisType = AnalysisType.PREDICTION
    features: List[str] = Field(default=["population", "distance_to_road"])
    time_horizon: Optional[int] = Field(default=None, description="Prediction horizon in days")
    include_uncertainty: bool = False


class NaturalLanguageQueryRequest(BaseModel):
    """Request for natural language spatial query"""
    query: str = Field(..., min_length=3, max_length=500)
    context: Optional[str] = None
    location_hint: Optional[PointGeometry] = None
    search_radius_km: float = Field(default=10.0, ge=0.1, le=1000)
    max_results: int = Field(default=10, ge=1, le=100)
    language: str = Field(default="fa")


class GeocodingRequest(BaseModel):
    """Request for AI-powered geocoding"""
    address: str = Field(..., min_length=3, max_length=500)
    country_hint: Optional[str] = "IR"
    fuzzy_match: bool = True
    max_results: int = Field(default=5, ge=1, le=20)


class SpatialClusteringRequest(BaseModel):
    """Request for spatial clustering analysis"""
    points: List[PointGeometry]
    algorithm: Literal["kmeans", "dbscan", "hdbscan"] = "dbscan"
    n_clusters: Optional[int] = None  # For kmeans
    eps: Optional[float] = None  # For DBSCAN (in meters)
    min_samples: int = Field(default=5, ge=1)
    include_outliers: bool = True


class RouteOptimizationRequest(BaseModel):
    """Request for AI-powered route optimization"""
    origin: PointGeometry
    destination: PointGeometry
    waypoints: Optional[List[PointGeometry]] = None
    optimization_criteria: Literal["distance", "time", "cost", "eco"] = "time"
    avoid: Optional[List[str]] = None  # ["tolls", "highways", "ferries"]
    departure_time: Optional[datetime] = None
    traffic_model: Literal["best_guess", "pessimistic", "optimistic"] = "best_guess"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AI Response Schemas
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ClassificationResult(BaseModel):
    """Result of image classification"""
    class_name: str
    confidence: float
    area_percentage: Optional[float] = None


class ImageClassificationResponse(BaseModel):
    """Response for image classification"""
    success: bool
    classifications: List[ClassificationResult]
    dominant_class: str
    processing_time_ms: float
    image_metadata: Optional[Dict[str, Any]] = None


class DetectedObject(BaseModel):
    """Single detected object"""
    object_type: ObjectType
    confidence: float
    bounding_box: Dict[str, float]  # x_min, y_min, x_max, y_max
    center_point: PointGeometry
    area_sqm: Optional[float] = None
    attributes: Optional[Dict[str, Any]] = None


class ObjectDetectionResponse(BaseModel):
    """Response for object detection"""
    success: bool
    total_objects: int
    detections: List[DetectedObject]
    processing_time_ms: float
    coverage_area_sqkm: Optional[float] = None


class PredictionResult(BaseModel):
    """Spatial prediction result"""
    location: PointGeometry
    predicted_value: float
    uncertainty: Optional[float] = None
    confidence_interval: Optional[Dict[str, float]] = None


class SpatialPredictionResponse(BaseModel):
    """Response for spatial prediction"""
    success: bool
    prediction_type: str
    results: List[PredictionResult]
    model_accuracy: Optional[float] = None
    processing_time_ms: float


class NLPQueryResult(BaseModel):
    """Result of NLP spatial query"""
    name: str
    location: PointGeometry
    relevance_score: float
    category: Optional[str] = None
    distance_km: Optional[float] = None
    description: Optional[str] = None


class NaturalLanguageQueryResponse(BaseModel):
    """Response for NLP query"""
    success: bool
    interpreted_query: str
    extracted_entities: Dict[str, Any]
    results: List[NLPQueryResult]
    suggestions: Optional[List[str]] = None
    processing_time_ms: float


class ClusterResult(BaseModel):
    """Single cluster result"""
    cluster_id: int
    centroid: PointGeometry
    point_count: int
    radius_meters: float
    density: float
    is_outlier: bool = False


class SpatialClusteringResponse(BaseModel):
    """Response for spatial clustering"""
    success: bool
    algorithm: str
    n_clusters: int
    clusters: List[ClusterResult]
    silhouette_score: Optional[float] = None
    processing_time_ms: float</code></pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.5: AI SERVICE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Ûµ Ø³Ø±ÙˆÛŒØ³ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø§ØµÙ„ÛŒ</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ</span>
                        <span>app/services/ai_service.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn copy-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from openai import AsyncOpenAI
from typing import Optional, Dict, Any, List
import json
import logging
from app.config import settings

logger = logging.getLogger(__name__)


class GeoAIService:
    """
    Main AI Service for Geospatial Operations
    Integrates with OpenAI GPT-4 for spatial reasoning
    """
    
    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        self.model = settings.OPENAI_MODEL
        
        # System prompt for spatial reasoning
        self.spatial_system_prompt = """
        ØªÙˆ ÛŒÚ© Ù…ØªØ®ØµØµ GIS Ùˆ ØªØ­Ù„ÛŒÙ„ Ù…Ú©Ø§Ù†ÛŒ Ù‡Ø³ØªÛŒ. ÙˆØ¸Ø§ÛŒÙ ØªÙˆ:
        
        1. ØªÙØ³ÛŒØ± Ú©ÙˆØ¦Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ù‡ Ø²Ø¨Ø§Ù† Ø·Ø¨ÛŒØ¹ÛŒ
        2. Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ÙˆØ¬ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ø§Ø² Ù…ØªÙ†
        3. ØªØ¨Ø¯ÛŒÙ„ Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ú©ÙˆØ¦Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ
        4. Ø§Ø±Ø§Ø¦Ù‡ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ
        
        Ù‡Ù…ÛŒØ´Ù‡ Ù¾Ø§Ø³Ø® Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª JSON Ø³Ø§Ø®ØªØ§Ø±ÛŒØ§ÙØªÙ‡ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†.
        Ù…Ø®ØªØµØ§Øª Ø±Ø§ Ø¯Ø± Ø³ÛŒØ³ØªÙ… WGS84 (EPSG:4326) Ø§Ø±Ø§Ø¦Ù‡ Ø¨Ø¯Ù‡.
        """
    
    async def interpret_spatial_query(
        self,
        query: str,
        context: Optional[str] = None,
        location_hint: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Interpret natural language spatial query
        
        Args:
            query: User's natural language query
            context: Additional context
            location_hint: Optional location context
            
        Returns:
            Structured interpretation of the query
        """
        
        user_prompt = f"""
        Ú©ÙˆØ¦Ø±ÛŒ Ú©Ø§Ø±Ø¨Ø±: {query}
        
        {"Ø²Ù…ÛŒÙ†Ù‡: " + context if context else ""}
        {"Ù…ÙˆÙ‚Ø¹ÛŒØª Ú©Ø§Ø±Ø¨Ø±: " + json.dumps(location_hint) if location_hint else ""}
        
        Ù„Ø·ÙØ§Ù‹ Ø§ÛŒÙ† Ú©ÙˆØ¦Ø±ÛŒ Ø±Ø§ ØªÙØ³ÛŒØ± Ú©Ù† Ùˆ Ø®Ø±ÙˆØ¬ÛŒ JSON Ø¨Ø§ Ø³Ø§Ø®ØªØ§Ø± Ø²ÛŒØ± Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†:
        {{
            "query_type": "search|routing|analysis|info",
            "entities": {{
                "locations": ["Ù†Ø§Ù… Ù…Ú©Ø§Ù†â€ŒÙ‡Ø§"],
                "spatial_relations": ["Ù†Ø²Ø¯ÛŒÚ©", "Ø¯Ø§Ø®Ù„", "Ø¨ÛŒÙ†"],
                "attributes": ["ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ø¬Ø³ØªØ¬Ùˆ"]
            }},
            "interpreted_intent": "ØªÙˆØ¶ÛŒØ­ Ù‡Ø¯Ù Ú©Ø§Ø±Ø¨Ø±",
            "suggested_operations": ["Ø¹Ù…Ù„ÛŒØ§Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ"],
            "sql_hint": "Ú©ÙˆØ¦Ø±ÛŒ SQL/PostGIS Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)"
        }}
        """
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.spatial_system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.3,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            return {
                "success": True,
                "interpretation": result,
                "tokens_used": response.usage.total_tokens
            }
            
        except Exception as e:
            logger.error(f"Error interpreting query: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def extract_locations_from_text(
        self,
        text: str,
        language: str = "fa"
    ) -> Dict[str, Any]:
        """
        Extract geographic locations from text (NER for locations)
        
        Args:
            text: Input text
            language: Text language
            
        Returns:
            Extracted locations with coordinates if possible
        """
        
        user_prompt = f"""
        Ù…ØªÙ† Ø²ÛŒØ± Ø±Ø§ ØªØ­Ù„ÛŒÙ„ Ú©Ù† Ùˆ ØªÙ…Ø§Ù… Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ø±Ø§ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ú©Ù†:
        
        Ù…ØªÙ†: {text}
        
        Ø®Ø±ÙˆØ¬ÛŒ JSON Ø¨Ø§ Ø³Ø§Ø®ØªØ§Ø± Ø²ÛŒØ±:
        {{
            "locations": [
                {{
                    "name": "Ù†Ø§Ù… Ù…Ú©Ø§Ù†",
                    "type": "city|country|region|poi|address",
                    "coordinates": [lon, lat] ÛŒØ§ null,
                    "confidence": 0.0-1.0,
                    "context": "Ù…ØªÙ† Ø§Ø·Ø±Ø§Ù"
                }}
            ],
            "spatial_relations": [
                {{
                    "relation": "Ù†ÙˆØ¹ Ø±Ø§Ø¨Ø·Ù‡",
                    "from": "Ù…Ú©Ø§Ù† Ù…Ø¨Ø¯Ø§",
                    "to": "Ù…Ú©Ø§Ù† Ù…Ù‚ØµØ¯"
                }}
            ]
        }}
        """
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.spatial_system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.2,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            return {
                "success": True,
                "extracted_data": result,
                "tokens_used": response.usage.total_tokens
            }
            
        except Exception as e:
            logger.error(f"Error extracting locations: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def generate_spatial_analysis_plan(
        self,
        objective: str,
        available_data: List[str],
        constraints: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Generate a spatial analysis plan using AI
        
        Args:
            objective: Analysis objective
            available_data: List of available datasets
            constraints: Analysis constraints
            
        Returns:
            Detailed analysis plan
        """
        
        user_prompt = f"""
        Ù‡Ø¯Ù ØªØ­Ù„ÛŒÙ„: {objective}
        
        Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯: {json.dumps(available_data, ensure_ascii=False)}
        
        {"Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§: " + json.dumps(constraints, ensure_ascii=False) if constraints else ""}
        
        ÛŒÚ© Ø¨Ø±Ù†Ø§Ù…Ù‡ ØªØ­Ù„ÛŒÙ„ Ù…Ú©Ø§Ù†ÛŒ Ú©Ø§Ù…Ù„ Ø·Ø±Ø§Ø­ÛŒ Ú©Ù†:
        {{
            "analysis_steps": [
                {{
                    "step": 1,
                    "name": "Ù†Ø§Ù… Ù…Ø±Ø­Ù„Ù‡",
                    "description": "ØªÙˆØ¶ÛŒØ­Ø§Øª",
                    "input_data": ["Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ"],
                    "operations": ["Ø¹Ù…Ù„ÛŒØ§Øª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²"],
                    "output": "Ø®Ø±ÙˆØ¬ÛŒ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±",
                    "tools": ["Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ"]
                }}
            ],
            "expected_outputs": ["Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ù†Ù‡Ø§ÛŒÛŒ"],
            "potential_challenges": ["Ú†Ø§Ù„Ø´â€ŒÙ‡Ø§ÛŒ Ø§Ø­ØªÙ…Ø§Ù„ÛŒ"],
            "recommendations": ["ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§"]
        }}
        """
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.spatial_system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.5,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            return {
                "success": True,
                "analysis_plan": result,
                "tokens_used": response.usage.total_tokens
            }
            
        except Exception as e:
            logger.error(f"Error generating analysis plan: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def describe_spatial_pattern(
        self,
        pattern_data: Dict[str, Any],
        context: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Generate natural language description of spatial patterns
        
        Args:
            pattern_data: Statistical/spatial pattern data
            context: Additional context
            
        Returns:
            Human-readable description
        """
        
        user_prompt = f"""
        Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ù„Ú¯ÙˆÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø²ÛŒØ± Ø±Ø§ ØªØ­Ù„ÛŒÙ„ Ú©Ù† Ùˆ ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù‡:
        
        Ø¯Ø§Ø¯Ù‡: {json.dumps(pattern_data, ensure_ascii=False)}
        
        {"Ø²Ù…ÛŒÙ†Ù‡: " + context if context else ""}
        
        Ø®Ø±ÙˆØ¬ÛŒ JSON:
        {{
            "summary": "Ø®Ù„Ø§ØµÙ‡ ÛŒÚ© Ø¬Ù…Ù„Ù‡â€ŒØ§ÛŒ",
            "detailed_description": "ØªÙˆØ¶ÛŒØ­ Ú©Ø§Ù…Ù„ Ø§Ù„Ú¯Ùˆ",
            "key_findings": ["ÛŒØ§ÙØªÙ‡â€ŒÙ‡Ø§ÛŒ Ú©Ù„ÛŒØ¯ÛŒ"],
            "spatial_interpretation": "ØªÙØ³ÛŒØ± Ù…Ú©Ø§Ù†ÛŒ",
            "recommendations": ["Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª"],
            "confidence_level": "high|medium|low"
        }}
        """
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.spatial_system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.4,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            return {
                "success": True,
                "description": result,
                "tokens_used": response.usage.total_tokens
            }
            
        except Exception as e:
            logger.error(f"Error describing pattern: {e}")
            return {
                "success": False,
                "error": str(e)
            }


# Singleton instance
geo_ai_service = GeoAIService()</code></pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.6: IMAGE ANALYSIS SERVICE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û¶ Ø³Ø±ÙˆÛŒØ³ ØªØ­Ù„ÛŒÙ„ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ</span>
                        <span>app/services/image_service.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn copy-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">import torch
import torch.nn as nn
from torchvision import transforms, models
from PIL import Image
import numpy as np
import cv2
import base64
import io
import aiohttp
from typing import Optional, List, Dict, Any, Tuple
import logging
from dataclasses import dataclass
from enum import Enum

from app.config import settings

logger = logging.getLogger(__name__)


class LandUseClass(Enum):
    """Land use classification classes"""
    RESIDENTIAL = 0
    COMMERCIAL = 1
    INDUSTRIAL = 2
    AGRICULTURAL = 3
    FOREST = 4
    WATER = 5
    BARREN = 6
    URBAN = 7


@dataclass
class DetectionResult:
    """Object detection result"""
    class_name: str
    confidence: float
    bbox: Tuple[float, float, float, float]  # x1, y1, x2, y2
    center: Tuple[float, float]
    area: float


class SatelliteImageClassifier:
    """
    CNN-based satellite image classifier for land use classification
    """
    
    def __init__(self, model_path: Optional[str] = None):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model = self._load_model(model_path)
        self.transform = self._get_transforms()
        self.class_names = [e.name.lower() for e in LandUseClass]
        
    def _load_model(self, model_path: Optional[str]) -> nn.Module:
        """Load pre-trained model"""
        # Use ResNet50 as base model
        model = models.resnet50(pretrained=True)
        
        # Modify final layer for our classes
        num_classes = len(LandUseClass)
        model.fc = nn.Sequential(
            nn.Dropout(0.5),
            nn.Linear(model.fc.in_features, 512),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(512, num_classes)
        )
        
        # Load custom weights if provided
        if model_path:
            try:
                state_dict = torch.load(model_path, map_location=self.device)
                model.load_state_dict(state_dict)
                logger.info(f"Loaded model from {model_path}")
            except Exception as e:
                logger.warning(f"Could not load custom weights: {e}")
        
        model = model.to(self.device)
        model.eval()
        return model
    
    def _get_transforms(self) -> transforms.Compose:
        """Get image transforms for inference"""
        return transforms.Compose([
            transforms.Resize((224, 224)),
            transforms.ToTensor(),
            transforms.Normalize(
                mean=[0.485, 0.456, 0.406],
                std=[0.229, 0.224, 0.225]
            )
        ])
    
    async def classify_image(
        self,
        image: Image.Image,
        top_k: int = 3
    ) -> List[Dict[str, Any]]:
        """
        Classify satellite image
        
        Args:
            image: PIL Image
            top_k: Number of top predictions to return
            
        Returns:
            List of classification results
        """
        # Transform image
        input_tensor = self.transform(image).unsqueeze(0).to(self.device)
        
        # Inference
        with torch.no_grad():
            outputs = self.model(input_tensor)
            probabilities = torch.nn.functional.softmax(outputs, dim=1)
        
        # Get top-k predictions
        top_probs, top_indices = torch.topk(probabilities, top_k)
        
        results = []
        for prob, idx in zip(top_probs[0], top_indices[0]):
            results.append({
                "class_name": self.class_names[idx.item()],
                "confidence": prob.item(),
                "class_id": idx.item()
            })
        
        return results
    
    async def classify_tiles(
        self,
        image: Image.Image,
        tile_size: int = 224,
        overlap: float = 0.25
    ) -> Dict[str, Any]:
        """
        Classify image using sliding window approach
        
        Args:
            image: Large satellite image
            tile_size: Size of each tile
            overlap: Overlap between tiles
            
        Returns:
            Classification results with spatial distribution
        """
        width, height = image.size
        stride = int(tile_size * (1 - overlap))
        
        tile_results = []
        class_counts = {name: 0 for name in self.class_names}
        
        for y in range(0, height - tile_size + 1, stride):
            for x in range(0, width - tile_size + 1, stride):
                # Extract tile
                tile = image.crop((x, y, x + tile_size, y + tile_size))
                
                # Classify tile
                results = await self.classify_image(tile, top_k=1)
                top_class = results[0]
                
                tile_results.append({
                    "x": x,
                    "y": y,
                    "class": top_class["class_name"],
                    "confidence": top_class["confidence"]
                })
                
                class_counts[top_class["class_name"]] += 1
        
        # Calculate percentages
        total_tiles = len(tile_results)
        class_percentages = {
            name: (count / total_tiles) * 100 
            for name, count in class_counts.items()
        }
        
        # Find dominant class
        dominant_class = max(class_counts, key=class_counts.get)
        
        return {
            "tile_results": tile_results,
            "class_distribution": class_percentages,
            "dominant_class": dominant_class,
            "total_tiles": total_tiles
        }


class ObjectDetector:
    """
    Object detector for satellite imagery
    Uses YOLO-style detection for buildings, roads, vehicles, etc.
    """
    
    def __init__(self, model_path: Optional[str] = None):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model = self._load_model(model_path)
        self.class_names = [
            "building", "road", "vehicle", "vegetation",
            "water_body", "solar_panel", "swimming_pool"
        ]
        self.input_size = 640
        
    def _load_model(self, model_path: Optional[str]):
        """Load detection model"""
        try:
            # Try to load YOLOv8 model
            from ultralytics import YOLO
            if model_path:
                model = YOLO(model_path)
            else:
                model = YOLO('yolov8n.pt')  # Default model
            return model
        except ImportError:
            logger.warning("ultralytics not installed, using mock detector")
            return None
    
    async def detect_objects(
        self,
        image: Image.Image,
        confidence_threshold: float = 0.5,
        target_classes: Optional[List[str]] = None
    ) -> List[DetectionResult]:
        """
        Detect objects in satellite image
        
        Args:
            image: PIL Image
            confidence_threshold: Minimum confidence
            target_classes: Filter for specific classes
            
        Returns:
            List of detection results
        """
        if self.model is None:
            # Return mock results for demo
            return self._mock_detections(image.size)
        
        # Run inference
        results = self.model(image, conf=confidence_threshold)
        
        detections = []
        for result in results:
            boxes = result.boxes
            for box in boxes:
                class_id = int(box.cls)
                class_name = self.class_names[class_id] if class_id < len(self.class_names) else "unknown"
                
                # Filter by target classes
                if target_classes and class_name not in target_classes:
                    continue
                
                x1, y1, x2, y2 = box.xyxy[0].tolist()
                confidence = box.conf.item()
                
                detection = DetectionResult(
                    class_name=class_name,
                    confidence=confidence,
                    bbox=(x1, y1, x2, y2),
                    center=((x1 + x2) / 2, (y1 + y2) / 2),
                    area=(x2 - x1) * (y2 - y1)
                )
                detections.append(detection)
        
        return detections
    
    def _mock_detections(self, image_size: Tuple[int, int]) -> List[DetectionResult]:
        """Generate mock detections for demo purposes"""
        import random
        
        width, height = image_size
        detections = []
        
        for i in range(random.randint(5, 15)):
            x1 = random.uniform(0, width * 0.8)
            y1 = random.uniform(0, height * 0.8)
            w = random.uniform(20, 100)
            h = random.uniform(20, 100)
            
            detection = DetectionResult(
                class_name=random.choice(self.class_names),
                confidence=random.uniform(0.5, 0.99),
                bbox=(x1, y1, x1 + w, y1 + h),
                center=(x1 + w/2, y1 + h/2),
                area=w * h
            )
            detections.append(detection)
        
        return detections


class ImageAnalysisService:
    """
    Main service for satellite image analysis
    """
    
    def __init__(self):
        self.classifier = SatelliteImageClassifier(
            model_path=settings.SATELLITE_MODEL_PATH
        )
        self.detector = ObjectDetector(
            model_path=settings.OBJECT_DETECTOR_PATH
        )
    
    async def load_image_from_url(self, url: str) -> Image.Image:
        """Load image from URL"""
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status != 200:
                    raise ValueError(f"Failed to load image: {response.status}")
                data = await response.read()
                return Image.open(io.BytesIO(data)).convert("RGB")
    
    async def load_image_from_base64(self, base64_str: str) -> Image.Image:
        """Load image from base64 string"""
        image_data = base64.b64decode(base64_str)
        return Image.open(io.BytesIO(image_data)).convert("RGB")
    
    async def analyze_land_use(
        self,
        image: Image.Image,
        use_tiles: bool = True
    ) -> Dict[str, Any]:
        """
        Analyze land use in satellite image
        
        Args:
            image: Satellite image
            use_tiles: Use tile-based classification for large images
            
        Returns:
            Land use analysis results
        """
        import time
        start_time = time.time()
        
        if use_tiles and min(image.size) > 500:
            results = await self.classifier.classify_tiles(image)
        else:
            classifications = await self.classifier.classify_image(image)
            results = {
                "classifications": classifications,
                "dominant_class": classifications[0]["class_name"],
                "class_distribution": {
                    c["class_name"]: c["confidence"] * 100 
                    for c in classifications
                }
            }
        
        processing_time = (time.time() - start_time) * 1000
        
        return {
            "success": True,
            "analysis_type": "land_use_classification",
            "results": results,
            "processing_time_ms": processing_time,
            "image_size": image.size
        }
    
    async def detect_objects_in_image(
        self,
        image: Image.Image,
        target_classes: Optional[List[str]] = None,
        confidence_threshold: float = 0.5
    ) -> Dict[str, Any]:
        """
        Detect objects in satellite image
        
        Args:
            image: Satellite image
            target_classes: Classes to detect
            confidence_threshold: Minimum confidence
            
        Returns:
            Object detection results
        """
        import time
        start_time = time.time()
        
        detections = await self.detector.detect_objects(
            image,
            confidence_threshold=confidence_threshold,
            target_classes=target_classes
        )
        
        # Group by class
        class_counts = {}
        for det in detections:
            class_counts[det.class_name] = class_counts.get(det.class_name, 0) + 1
        
        processing_time = (time.time() - start_time) * 1000
        
        return {
            "success": True,
            "analysis_type": "object_detection",
            "total_objects": len(detections),
            "detections": [
                {
                    "class": d.class_name,
                    "confidence": d.confidence,
                    "bbox": d.bbox,
                    "center": d.center,
                    "area_pixels": d.area
                }
                for d in detections
            ],
            "class_counts": class_counts,
            "processing_time_ms": processing_time,
            "image_size": image.size
        }
    
    async def full_analysis(
        self,
        image: Image.Image
    ) -> Dict[str, Any]:
        """
        Perform full analysis on satellite image
        
        Args:
            image: Satellite image
            
        Returns:
            Complete analysis results
        """
        import asyncio
        
        # Run analyses in parallel
        land_use_task = self.analyze_land_use(image)
        detection_task = self.detect_objects_in_image(image)
        
        land_use_results, detection_results = await asyncio.gather(
            land_use_task, detection_task
        )
        
        return {
            "success": True,
            "analysis_type": "full_analysis",
            "land_use": land_use_results,
            "object_detection": detection_results,
            "image_size": image.size
        }


# Singleton instance
image_analysis_service = ImageAnalysisService()</code></pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.7: SPATIAL PREDICTION SERVICE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û· Ø³Ø±ÙˆÛŒØ³ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…Ú©Ø§Ù†ÛŒ</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ</span>
                        <span>app/services/prediction_service.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn copy-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">import numpy as np
from sklearn.cluster import DBSCAN, KMeans
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score
from scipy.spatial import cKDTree
from scipy.interpolate import griddata
from typing import List, Dict, Any, Optional, Tuple
import logging
from dataclasses import dataclass
from shapely.geometry import Point, Polygon
import geopandas as gpd

logger = logging.getLogger(__name__)


@dataclass
class SpatialPoint:
    """Spatial point with attributes"""
    lon: float
    lat: float
    value: Optional[float] = None
    attributes: Optional[Dict[str, Any]] = None


@dataclass
class ClusterInfo:
    """Cluster information"""
    cluster_id: int
    centroid: Tuple[float, float]
    points: List[SpatialPoint]
    radius: float
    density: float


class SpatialClusteringService:
    """
    Service for spatial clustering analysis
    """
    
    def __init__(self):
        self.scaler = StandardScaler()
    
    def _to_numpy(self, points: List[SpatialPoint]) -> np.ndarray:
        """Convert points to numpy array"""
        return np.array([[p.lon, p.lat] for p in points])
    
    def _haversine_distance(
        self,
        lon1: float, lat1: float,
        lon2: float, lat2: float
    ) -> float:
        """Calculate Haversine distance in meters"""
        R = 6371000  # Earth radius in meters
        
        lat1, lat2 = np.radians(lat1), np.radians(lat2)
        dlat = lat2 - lat1
        dlon = np.radians(lon2 - lon1)
        
        a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
        c = 2 * np.arcsin(np.sqrt(a))
        
        return R * c
    
    async def dbscan_clustering(
        self,
        points: List[SpatialPoint],
        eps_meters: float = 500,
        min_samples: int = 5
    ) -> Dict[str, Any]:
        """
        DBSCAN clustering for spatial points
        
        Args:
            points: List of spatial points
            eps_meters: Maximum distance between points in meters
            min_samples: Minimum points to form cluster
            
        Returns:
            Clustering results
        """
        coords = self._to_numpy(points)
        
        # Convert eps from meters to approximate degrees
        # 1 degree â‰ˆ 111km at equator
        eps_degrees = eps_meters / 111000
        
        # Run DBSCAN
        clustering = DBSCAN(
            eps=eps_degrees,
            min_samples=min_samples,
            metric='haversine'
        )
        
        # Convert to radians for haversine
        coords_rad = np.radians(coords)
        labels = clustering.fit_predict(coords_rad)
        
        # Process results
        clusters = []
        unique_labels = set(labels)
        
        for label in unique_labels:
            mask = labels == label
            cluster_points = [p for p, m in zip(points, mask) if m]
            cluster_coords = coords[mask]
            
            if label == -1:
                # Noise points
                for i, point in enumerate(cluster_points):
                    clusters.append(ClusterInfo(
                        cluster_id=-1,
                        centroid=(point.lon, point.lat),
                        points=[point],
                        radius=0,
                        density=0
                    ))
            else:
                # Calculate centroid
                centroid = cluster_coords.mean(axis=0)
                
                # Calculate radius (max distance from centroid)
                distances = [
                    self._haversine_distance(
                        centroid[0], centroid[1],
                        p.lon, p.lat
                    )
                    for p in cluster_points
                ]
                radius = max(distances) if distances else 0
                
                # Calculate density (points per sq km)
                area = np.pi * (radius/1000)**2 if radius > 0 else 1
                density = len(cluster_points) / area
                
                clusters.append(ClusterInfo(
                    cluster_id=int(label),
                    centroid=(float(centroid[0]), float(centroid[1])),
                    points=cluster_points,
                    radius=radius,
                    density=density
                ))
        
        # Calculate silhouette score if more than 1 cluster
        n_clusters = len([c for c in clusters if c.cluster_id >= 0])
        silhouette = None
        if n_clusters > 1 and len(points) > n_clusters:
            non_noise_mask = labels >= 0
            if sum(non_noise_mask) > n_clusters:
                silhouette = silhouette_score(
                    coords_rad[non_noise_mask],
                    labels[non_noise_mask]
                )
        
        return {
            "algorithm": "DBSCAN",
            "n_clusters": n_clusters,
            "n_noise_points": sum(labels == -1),
            "clusters": [
                {
                    "cluster_id": c.cluster_id,
                    "centroid": {"lon": c.centroid[0], "lat": c.centroid[1]},
                    "point_count": len(c.points),
                    "radius_meters": c.radius,
                    "density_per_sqkm": c.density,
                    "is_outlier": c.cluster_id == -1
                }
                for c in clusters if c.cluster_id >= 0 or len(c.points) == 1
            ],
            "silhouette_score": silhouette,
            "parameters": {
                "eps_meters": eps_meters,
                "min_samples": min_samples
            }
        }
    
    async def kmeans_clustering(
        self,
        points: List[SpatialPoint],
        n_clusters: int = 5
    ) -> Dict[str, Any]:
        """
        K-Means clustering for spatial points
        
        Args:
            points: List of spatial points
            n_clusters: Number of clusters
            
        Returns:
            Clustering results
        """
        coords = self._to_numpy(points)
        
        # Normalize coordinates
        coords_scaled = self.scaler.fit_transform(coords)
        
        # Run K-Means
        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
        labels = kmeans.fit_predict(coords_scaled)
        
        # Get centroids in original scale
        centroids = self.scaler.inverse_transform(kmeans.cluster_centers_)
        
        # Process results
        clusters = []
        for i in range(n_clusters):
            mask = labels == i
            cluster_points = [p for p, m in zip(points, mask) if m]
            cluster_coords = coords[mask]
            
            centroid = centroids[i]
            
            # Calculate radius
            distances = [
                self._haversine_distance(
                    centroid[0], centroid[1],
                    p.lon, p.lat
                )
                for p in cluster_points
            ]
            radius = max(distances) if distances else 0
            
            # Calculate density
            area = np.pi * (radius/1000)**2 if radius > 0 else 1
            density = len(cluster_points) / area
            
            clusters.append({
                "cluster_id": i,
                "centroid": {"lon": float(centroid[0]), "lat": float(centroid[1])},
                "point_count": len(cluster_points),
                "radius_meters": radius,
                "density_per_sqkm": density,
                "is_outlier": False
            })
        
        # Calculate silhouette score
        silhouette = silhouette_score(coords_scaled, labels) if n_clusters > 1 else None
        
        return {
            "algorithm": "KMeans",
            "n_clusters": n_clusters,
            "clusters": clusters,
            "silhouette_score": silhouette,
            "inertia": kmeans.inertia_,
            "parameters": {
                "n_clusters": n_clusters
            }
        }
    
    async def hotspot_analysis(
        self,
        points: List[SpatialPoint],
        bandwidth_meters: float = 1000
    ) -> Dict[str, Any]:
        """
        Kernel Density Estimation for hotspot detection
        
        Args:
            points: List of spatial points with values
            bandwidth_meters: KDE bandwidth in meters
            
        Returns:
            Hotspot analysis results
        """
        coords = self._to_numpy(points)
        values = np.array([p.value or 1.0 for p in points])
        
        # Create grid for density estimation
        lon_min, lon_max = coords[:, 0].min(), coords[:, 0].max()
        lat_min, lat_max = coords[:, 1].min(), coords[:, 1].max()
        
        # Grid resolution
        grid_size = 50
        lon_grid = np.linspace(lon_min, lon_max, grid_size)
        lat_grid = np.linspace(lat_min, lat_max, grid_size)
        lon_mesh, lat_mesh = np.meshgrid(lon_grid, lat_grid)
        
        # Calculate density at each grid point
        density_grid = np.zeros_like(lon_mesh)
        bandwidth_deg = bandwidth_meters / 111000
        
        for i in range(grid_size):
            for j in range(grid_size):
                grid_point = np.array([lon_mesh[i, j], lat_mesh[i, j]])
                distances = np.sqrt(((coords - grid_point)**2).sum(axis=1))
                
                # Gaussian kernel
                weights = np.exp(-0.5 * (distances / bandwidth_deg)**2)
                density_grid[i, j] = (weights * values).sum()
        
        # Normalize
        density_grid = density_grid / density_grid.max()
        
        # Find hotspots (local maxima above threshold)
        threshold = 0.7
        hotspots = []
        
        for i in range(1, grid_size - 1):
            for j in range(1, grid_size - 1):
                if density_grid[i, j] > threshold:
                    # Check if local maximum
                    neighborhood = density_grid[i-1:i+2, j-1:j+2]
                    if density_grid[i, j] == neighborhood.max():
                        hotspots.append({
                            "location": {
                                "lon": float(lon_mesh[i, j]),
                                "lat": float(lat_mesh[i, j])
                            },
                            "intensity": float(density_grid[i, j]),
                            "rank": len(hotspots) + 1
                        })
        
        # Sort by intensity
        hotspots.sort(key=lambda x: x["intensity"], reverse=True)
        for i, h in enumerate(hotspots):
            h["rank"] = i + 1
        
        return {
            "analysis_type": "hotspot_kde",
            "n_hotspots": len(hotspots),
            "hotspots": hotspots[:20],  # Top 20
            "density_stats": {
                "min": float(density_grid.min()),
                "max": float(density_grid.max()),
                "mean": float(density_grid.mean()),
                "std": float(density_grid.std())
            },
            "parameters": {
                "bandwidth_meters": bandwidth_meters,
                "grid_size": grid_size
            }
        }


class SpatialPredictionService:
    """
    Service for spatial prediction and interpolation
    """
    
    def __init__(self):
        self.clustering_service = SpatialClusteringService()
    
    async def spatial_interpolation(
        self,
        points: List[SpatialPoint],
        target_bounds: Tuple[float, float, float, float],
        method: str = "idw",
        resolution: int = 100
    ) -> Dict[str, Any]:
        """
        Spatial interpolation of point values
        
        Args:
            points: Points with values
            target_bounds: (min_lon, min_lat, max_lon, max_lat)
            method: Interpolation method (idw, linear, cubic)
            resolution: Grid resolution
            
        Returns:
            Interpolated grid
        """
        # Extract coordinates and values
        coords = np.array([[p.lon, p.lat] for p in points])
        values = np.array([p.value for p in points if p.value is not None])
        
        if len(values) != len(coords):
            raise ValueError("All points must have values for interpolation")
        
        # Create target grid
        min_lon, min_lat, max_lon, max_lat = target_bounds
        lon_grid = np.linspace(min_lon, max_lon, resolution)
        lat_grid = np.linspace(min_lat, max_lat, resolution)
        lon_mesh, lat_mesh = np.meshgrid(lon_grid, lat_grid)
        
        # Interpolate
        if method == "idw":
            # Inverse Distance Weighting
            interpolated = self._idw_interpolation(
                coords, values, lon_mesh, lat_mesh, power=2
            )
        else:
            # Use scipy griddata
            grid_points = np.column_stack([lon_mesh.ravel(), lat_mesh.ravel()])
            interpolated = griddata(
                coords, values, grid_points, method=method
            ).reshape(lon_mesh.shape)
        
        return {
            "method": method,
            "grid": {
                "lon_range": [float(min_lon), float(max_lon)],
                "lat_range": [float(min_lat), float(max_lat)],
                "resolution": resolution,
                "values": interpolated.tolist()
            },
            "statistics": {
                "min": float(np.nanmin(interpolated)),
                "max": float(np.nanmax(interpolated)),
                "mean": float(np.nanmean(interpolated)),
                "std": float(np.nanstd(interpolated))
            }
        }
    
    def _idw_interpolation(
        self,
        coords: np.ndarray,
        values: np.ndarray,
        lon_mesh: np.ndarray,
        lat_mesh: np.ndarray,
        power: float = 2
    ) -> np.ndarray:
        """Inverse Distance Weighting interpolation"""
        result = np.zeros_like(lon_mesh)
        
        for i in range(lon_mesh.shape[0]):
            for j in range(lon_mesh.shape[1]):
                point = np.array([lon_mesh[i, j], lat_mesh[i, j]])
                distances = np.sqrt(((coords - point)**2).sum(axis=1))
                
                # Handle exact matches
                if np.any(distances == 0):
                    result[i, j] = values[distances == 0][0]
                else:
                    weights = 1 / (distances ** power)
                    result[i, j] = (weights * values).sum() / weights.sum()
        
        return result
    
    async def train_spatial_predictor(
        self,
        training_points: List[SpatialPoint],
        features: List[str]
    ) -> Dict[str, Any]:
        """
        Train a spatial predictionmodel using Random Forest
        
        Args:
            training_points: Points with values and attributes
            features: Feature names to use
            
        Returns:
            Training results and model info
        """
        # Prepare training data
        X = []
        y = []
        
        for point in training_points:
            if point.value is None or point.attributes is None:
                continue
            
            feature_values = [point.lon, point.lat]
            for feat in features:
                if feat in point.attributes:
                    feature_values.append(point.attributes[feat])
                else:
                    feature_values.append(0)
            
            X.append(feature_values)
            y.append(point.value)
        
        X = np.array(X)
        y = np.array(y)
        
        # Scale features
        X_scaled = self.clustering_service.scaler.fit_transform(X)
        
        # Train model
        model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=42,
            n_jobs=-1
        )
        model.fit(X_scaled, y)
        
        # Calculate feature importance
        feature_names = ["longitude", "latitude"] + features
        importance = dict(zip(feature_names, model.feature_importances_))
        
        # Cross-validation score
        from sklearn.model_selection import cross_val_score
        cv_scores = cross_val_score(model, X_scaled, y, cv=5, scoring='r2')
        
        return {
            "success": True,
            "model_type": "RandomForestRegressor",
            "n_training_samples": len(y),
            "features_used": feature_names,
            "feature_importance": importance,
            "cv_scores": {
                "mean_r2": float(cv_scores.mean()),
                "std_r2": float(cv_scores.std()),
                "scores": cv_scores.tolist()
            },
            "model": model  # Return model for predictions
        }
    
    async def predict_values(
        self,
        model,
        target_points: List[SpatialPoint],
        features: List[str],
        include_uncertainty: bool = False
    ) -> List[Dict[str, Any]]:
        """
        Predict values at target locations
        
        Args:
            model: Trained model
            target_points: Points to predict
            features: Feature names
            include_uncertainty: Include prediction uncertainty
            
        Returns:
            Predictions for each point
        """
        predictions = []
        
        for point in target_points:
            feature_values = [point.lon, point.lat]
            for feat in features:
                if point.attributes and feat in point.attributes:
                    feature_values.append(point.attributes[feat])
                else:
                    feature_values.append(0)
            
            X = np.array([feature_values])
            X_scaled = self.clustering_service.scaler.transform(X)
            
            pred = model.predict(X_scaled)[0]
            
            result = {
                "location": {"lon": point.lon, "lat": point.lat},
                "predicted_value": float(pred)
            }
            
            if include_uncertainty:
                # Get predictions from all trees
                tree_predictions = [
                    tree.predict(X_scaled)[0] 
                    for tree in model.estimators_
                ]
                result["uncertainty"] = float(np.std(tree_predictions))
                result["confidence_interval"] = {
                    "lower": float(np.percentile(tree_predictions, 5)),
                    "upper": float(np.percentile(tree_predictions, 95))
                }
            
            predictions.append(result)
        
        return predictions


# Singleton instances
spatial_clustering_service = SpatialClusteringService()
spatial_prediction_service = SpatialPredictionService()</code></pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.8: NLP SERVICE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û¸ Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø²Ø¨Ø§Ù† Ø·Ø¨ÛŒØ¹ÛŒ Ù…Ú©Ø§Ù†ÛŒ</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ</span>
                        <span>app/services/nlp_service.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn copy-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from openai import AsyncOpenAI
from typing import Optional, Dict, Any, List, Tuple
import json
import re
import logging
from dataclasses import dataclass
from enum import Enum

from app.config import settings
from app.services.ai_service import geo_ai_service

logger = logging.getLogger(__name__)


class QueryIntent(str, Enum):
    """Types of spatial query intents"""
    SEARCH = "search"           # Find places
    NAVIGATE = "navigate"       # Get directions
    ANALYZE = "analyze"         # Spatial analysis
    INFO = "info"              # Get information
    COMPARE = "compare"        # Compare locations
    RECOMMEND = "recommend"    # Get recommendations


@dataclass
class ExtractedEntity:
    """Extracted entity from text"""
    text: str
    entity_type: str
    start_pos: int
    end_pos: int
    confidence: float
    normalized_value: Optional[str] = None


@dataclass
class SpatialQuery:
    """Parsed spatial query"""
    intent: QueryIntent
    entities: List[ExtractedEntity]
    location_references: List[Dict[str, Any]]
    spatial_relations: List[str]
    attributes: List[str]
    original_query: str
    interpreted_query: str


class GeoNLPService:
    """
    Natural Language Processing service for spatial queries
    """
    
    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        self.model = settings.OPENAI_MODEL
        
        # Spatial keywords for Persian
        self.spatial_keywords_fa = {
            "Ù†Ø²Ø¯ÛŒÚ©": "near",
            "Ú©Ù†Ø§Ø±": "adjacent",
            "Ø¯Ø§Ø®Ù„": "within",
            "Ø¨ÛŒÙ†": "between",
            "Ø§Ø·Ø±Ø§Ù": "around",
            "Ø´Ù…Ø§Ù„": "north",
            "Ø¬Ù†ÙˆØ¨": "south",
            "Ø´Ø±Ù‚": "east",
            "ØºØ±Ø¨": "west",
            "Ù…Ø±Ú©Ø²": "center",
            "Ø­ÙˆÙ…Ù‡": "suburb",
            "ÙØ§ØµÙ„Ù‡": "distance",
            "Ù…Ø³ÛŒØ±": "route",
            "Ù†Ù‚Ø´Ù‡": "map"
        }
        
        # POI categories
        self.poi_categories = {
            "Ø±Ø³ØªÙˆØ±Ø§Ù†": "restaurant",
            "Ú©Ø§ÙÙ‡": "cafe",
            "Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†": "hospital",
            "Ø¯Ø§Ø±ÙˆØ®Ø§Ù†Ù‡": "pharmacy",
            "Ø¨Ø§Ù†Ú©": "bank",
            "Ù¾Ø§Ø±Ú©": "park",
            "Ù…Ø¯Ø±Ø³Ù‡": "school",
            "Ø¯Ø§Ù†Ø´Ú¯Ø§Ù‡": "university",
            "ÙØ±ÙˆØ´Ú¯Ø§Ù‡": "store",
            "Ù‡ØªÙ„": "hotel",
            "Ù…Ø³Ø¬Ø¯": "mosque",
            "Ù¾Ù…Ù¾ Ø¨Ù†Ø²ÛŒÙ†": "gas_station",
            "Ù¾Ø§Ø±Ú©ÛŒÙ†Ú¯": "parking",
            "Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ Ù…ØªØ±Ùˆ": "metro_station",
            "Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ Ø§ØªÙˆØ¨ÙˆØ³": "bus_station"
        }
    
    async def parse_spatial_query(
        self,
        query: str,
        context: Optional[str] = None,
        user_location: Optional[Tuple[float, float]] = None
    ) -> SpatialQuery:
        """
        Parse natural language spatial query
        
        Args:
            query: User's query in natural language
            context: Additional context
            user_location: User's current location (lon, lat)
            
        Returns:
            Parsed spatial query
        """
        # Use AI service to interpret query
        interpretation = await geo_ai_service.interpret_spatial_query(
            query=query,
            context=context,
            location_hint={"coordinates": list(user_location)} if user_location else None
        )
        
        if not interpretation["success"]:
            raise ValueError(f"Failed to interpret query: {interpretation.get('error')}")
        
        interp = interpretation["interpretation"]
        
        # Extract entities
        entities = await self._extract_entities(query)
        
        # Determine intent
        intent = self._determine_intent(interp.get("query_type", "search"))
        
        # Extract location references
        location_refs = []
        for loc in interp.get("entities", {}).get("locations", []):
            location_refs.append({
                "name": loc,
                "type": "unknown",
                "coordinates": None
            })
        
        return SpatialQuery(
            intent=intent,
            entities=entities,
            location_references=location_refs,
            spatial_relations=interp.get("entities", {}).get("spatial_relations", []),
            attributes=interp.get("entities", {}).get("attributes", []),
            original_query=query,
            interpreted_query=interp.get("interpreted_intent", query)
        )
    
    def _determine_intent(self, query_type: str) -> QueryIntent:
        """Map query type to intent"""
        mapping = {
            "search": QueryIntent.SEARCH,
            "routing": QueryIntent.NAVIGATE,
            "analysis": QueryIntent.ANALYZE,
            "info": QueryIntent.INFO,
            "compare": QueryIntent.COMPARE,
            "recommend": QueryIntent.RECOMMEND
        }
        return mapping.get(query_type, QueryIntent.SEARCH)
    
    async def _extract_entities(self, text: str) -> List[ExtractedEntity]:
        """Extract entities from text using pattern matching and AI"""
        entities = []
        
        # Pattern-based extraction for Persian spatial keywords
        for fa_word, en_word in self.spatial_keywords_fa.items():
            for match in re.finditer(fa_word, text):
                entities.append(ExtractedEntity(
                    text=match.group(),
                    entity_type="spatial_relation",
                    start_pos=match.start(),
                    end_pos=match.end(),
                    confidence=0.9,
                    normalized_value=en_word
                ))
        
        # Pattern-based extraction for POI categories
        for fa_cat, en_cat in self.poi_categories.items():
            for match in re.finditer(fa_cat, text):
                entities.append(ExtractedEntity(
                    text=match.group(),
                    entity_type="poi_category",
                    start_pos=match.start(),
                    end_pos=match.end(),
                    confidence=0.95,
                    normalized_value=en_cat
                ))
        
        return entities
    
    async def generate_postgis_query(
        self,
        spatial_query: SpatialQuery,
        table_name: str = "places",
        geometry_column: str = "geom"
    ) -> str:
        """
        Generate PostGIS SQL query from parsed spatial query
        
        Args:
            spatial_query: Parsed spatial query
            table_name: Database table name
            geometry_column: Geometry column name
            
        Returns:
            PostGIS SQL query
        """
        prompt = f"""
        Ø¨Ø± Ø§Ø³Ø§Ø³ Ú©ÙˆØ¦Ø±ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø²ÛŒØ±ØŒ ÛŒÚ© Ú©ÙˆØ¦Ø±ÛŒ PostGIS Ø¨Ù†ÙˆÛŒØ³:
        
        Intent: {spatial_query.intent.value}
        Locations: {[l['name'] for l in spatial_query.location_references]}
        Spatial Relations: {spatial_query.spatial_relations}
        Attributes: {spatial_query.attributes}
        Original Query: {spatial_query.original_query}
        
        Table: {table_name}
        Geometry Column: {geometry_column}
        
        ÙÙ‚Ø· Ú©ÙˆØ¦Ø±ÛŒ SQL Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†ØŒ Ø¨Ø¯ÙˆÙ† ØªÙˆØ¶ÛŒØ­ Ø§Ø¶Ø§ÙÛŒ.
        Ø§Ø² ØªÙˆØ§Ø¨Ø¹ PostGIS Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†.
        """
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "ØªÙˆ ÛŒÚ© Ù…ØªØ®ØµØµ PostGIS Ù‡Ø³ØªÛŒ. ÙÙ‚Ø· Ú©ÙˆØ¦Ø±ÛŒ SQL Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†."
                    },
                    {"role": "user", "content": prompt}
                ],
                temperature=0.2,
                max_tokens=500
            )
            
            sql = response.choices[0].message.content.strip()
            
            # Clean up SQL
            sql = sql.replace("```sql", "").replace("```", "").strip()
            
            return sql
            
        except Exception as e:
            logger.error(f"Error generating PostGIS query: {e}")
            return ""
    
    async def geocode_address(
        self,
        address: str,
        country_hint: str = "IR"
    ) -> Dict[str, Any]:
        """
        AI-powered geocoding for Persian addresses
        
        Args:
            address: Address string
            country_hint: Country code hint
            
        Returns:
            Geocoding result
        """
        prompt = f"""
        Ø¢Ø¯Ø±Ø³ Ø²ÛŒØ± Ø±Ø§ ØªØ­Ù„ÛŒÙ„ Ú©Ù† Ùˆ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ú©Ø§Ù†ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ú©Ù†:
        
        Ø¢Ø¯Ø±Ø³: {address}
        Ú©Ø´ÙˆØ±: {country_hint}
        
        Ø®Ø±ÙˆØ¬ÛŒ JSON:
        {{
            "parsed_address": {{
                "country": "Ú©Ø´ÙˆØ±",
                "province": "Ø§Ø³ØªØ§Ù†",
                "city": "Ø´Ù‡Ø±",
                "district": "Ù…Ù†Ø·Ù‚Ù‡/Ù…Ø­Ù„Ù‡",
                "street": "Ø®ÛŒØ§Ø¨Ø§Ù†",
                "alley": "Ú©ÙˆÚ†Ù‡",
                "building_number": "Ù¾Ù„Ø§Ú©",
                "unit": "ÙˆØ§Ø­Ø¯"
            }},
            "estimated_coordinates": {{
                "lon": Ø¹Ø¯Ø¯ ÛŒØ§ null,
                "lat": Ø¹Ø¯Ø¯ ÛŒØ§ null,
                "confidence": 0.0-1.0
            }},
            "location_type": "exact|interpolated|geometric_center|approximate",
            "formatted_address": "Ø¢Ø¯Ø±Ø³ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø´Ø¯Ù‡"
        }}
        """
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "ØªÙˆ ÛŒÚ© Ø³ÛŒØ³ØªÙ… geocoding Ù‡Ø³ØªÛŒ. Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒ ÙØ§Ø±Ø³ÛŒ Ø±Ø§ ØªØ­Ù„ÛŒÙ„ Ú©Ù†."
                    },
                    {"role": "user", "content": prompt}
                ],
                temperature=0.2,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            return {
                "success": True,
                "result": result
            }
            
        except Exception as e:
            logger.error(f"Error geocoding address: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def reverse_geocode(
        self,
        lon: float,
        lat: float,
        language: str = "fa"
    ) -> Dict[str, Any]:
        """
        AI-powered reverse geocoding
        
        Args:
            lon: Longitude
            lat: Latitude
            language: Output language
            
        Returns:
            Address information
        """
        prompt = f"""
        Ø¨Ø±Ø§ÛŒ Ù…Ø®ØªØµØ§Øª Ø²ÛŒØ±ØŒ Ø¢Ø¯Ø±Ø³ ØªÙ‚Ø±ÛŒØ¨ÛŒ Ø§Ø±Ø§Ø¦Ù‡ Ø¨Ø¯Ù‡:
        
        Ø·ÙˆÙ„ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ: {lon}
        Ø¹Ø±Ø¶ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ: {lat}
        
        Ø®Ø±ÙˆØ¬ÛŒ JSON:
        {{
            "formatted_address": "Ø¢Ø¯Ø±Ø³ Ú©Ø§Ù…Ù„",
            "components": {{
                "country": "Ú©Ø´ÙˆØ±",
                "province": "Ø§Ø³ØªØ§Ù†",
                "city": "Ø´Ù‡Ø±",
                "district": "Ù…Ù†Ø·Ù‚Ù‡",
                "neighborhood": "Ù…Ø­Ù„Ù‡"
            }},
            "place_type": "Ù†ÙˆØ¹ Ù…Ú©Ø§Ù†",
            "confidence": 0.0-1.0
        }}
        """
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "ØªÙˆ ÛŒÚ© Ø³ÛŒØ³ØªÙ… reverse geocoding Ù‡Ø³ØªÛŒ."
                    },
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            return {
                "success": True,
                "coordinates": {"lon": lon, "lat": lat},
                "result": result
            }
            
        except Exception as e:
            logger.error(f"Error reverse geocoding: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def suggest_places(
        self,
        partial_query: str,
        user_location: Optional[Tuple[float, float]] = None,
        limit: int = 5
    ) -> List[Dict[str, Any]]:
        """
        AI-powered place suggestions (autocomplete)
        
        Args:
            partial_query: Partial search query
            user_location: User's location for relevance
            limit: Maximum suggestions
            
        Returns:
            List of place suggestions
        """
        location_context = ""
        if user_location:
            location_context = f"Ù…ÙˆÙ‚Ø¹ÛŒØª Ú©Ø§Ø±Ø¨Ø±: {user_location[1]}, {user_location[0]}"
        
        prompt = f"""
        Ø¨Ø±Ø§ÛŒ Ø¹Ø¨Ø§Ø±Øª Ø¬Ø³ØªØ¬ÙˆÛŒ Ø²ÛŒØ±ØŒ {limit} Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…Ú©Ø§Ù† Ø§Ø±Ø§Ø¦Ù‡ Ø¨Ø¯Ù‡:
        
        Ø¹Ø¨Ø§Ø±Øª: {partial_query}
        {location_context}
        
        Ø®Ø±ÙˆØ¬ÛŒ JSON:
        {{
            "suggestions": [
                {{
                    "name": "Ù†Ø§Ù… Ù…Ú©Ø§Ù†",
                    "category": "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ",
                    "description": "ØªÙˆØ¶ÛŒØ­ Ú©ÙˆØªØ§Ù‡",
                    "relevance_score": 0.0-1.0
                }}
            ]
        }}
        """
        
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "ØªÙˆ ÛŒÚ© Ø³ÛŒØ³ØªÙ… Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…Ú©Ø§Ù† Ù‡Ø³ØªÛŒ."
                    },
                    {"role": "user", "content": prompt}
                ],
                temperature=0.5,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            return result.get("suggestions", [])
            
        except Exception as e:
            logger.error(f"Error suggesting places: {e}")
            return []


# Singleton instance
geo_nlp_service = GeoNLPService()</code></pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.9: API ENDPOINTS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û¹ API Endpoints</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ</span>
                        <span>app/api/v1/ai_endpoints.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn copy-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import APIRouter, HTTPException, UploadFile, File, Depends
from fastapi.responses import JSONResponse
from typing import Optional, List
import time
import logging

from app.schemas.ai_requests import (
    ImageClassificationRequest,
    ObjectDetectionRequest,
    SpatialPredictionRequest,
    NaturalLanguageQueryRequest,
    GeocodingRequest,
    SpatialClusteringRequest,
    ImageClassificationResponse,
    ObjectDetectionResponse,
    SpatialPredictionResponse,
    NaturalLanguageQueryResponse,
    SpatialClusteringResponse
)
from app.services.ai_service import geo_ai_service
from app.services.image_service import image_analysis_service
from app.services.prediction_service import (
    spatial_clustering_service,
    spatial_prediction_service,
    SpatialPoint
)
from app.services.nlp_service import geo_nlp_service

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/ai", tags=["AI & ML"])


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Image Analysis Endpoints
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.post(
    "/classify-image",
    response_model=ImageClassificationResponse,
    summary="Ø·Ø¨Ù‚Ù‡â€ŒØ¨Ù†Ø¯ÛŒ ØªØµÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ",
    description="ØªØ­Ù„ÛŒÙ„ Ùˆ Ø·Ø¨Ù‚Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø²Ù…ÛŒÙ† Ø¯Ø± ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ"
)
async def classify_satellite_image(
    request: ImageClassificationRequest
):
    """
    Classify land use in satellite imagery
    
    - **image_url**: URL of the satellite image
    - **image_base64**: Base64 encoded image (alternative to URL)
    - **confidence_threshold**: Minimum confidence for classification
    """
    start_time = time.time()
    
    try:
        # Load image
        if request.image_url:
            image = await image_analysis_service.load_image_from_url(request.image_url)
        elif request.image_base64:
            image = await image_analysis_service.load_image_from_base64(request.image_base64)
        else:
            raise HTTPException(status_code=400, detail="No image provided")
        
        # Analyze
        results = await image_analysis_service.analyze_land_use(image)
        
        processing_time = (time.time() - start_time) * 1000
        
        return ImageClassificationResponse(
            success=True,
            classifications=[
                {
                    "class_name": k,
                    "confidence": v / 100,
                    "area_percentage": v
                }
                for k, v in results["results"].get("class_distribution", {}).items()
            ],
            dominant_class=results["results"]["dominant_class"],
            processing_time_ms=processing_time,
            image_metadata={"size": results["image_size"]}
        )
        
    except Exception as e:
        logger.error(f"Image classification error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post(
    "/detect-objects",
    response_model=ObjectDetectionResponse,
    summary="ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§Ø¡ Ø¯Ø± ØªØµÙˆÛŒØ±",
    description="Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ØŒ Ø¬Ø§Ø¯Ù‡â€ŒÙ‡Ø§ØŒ ÙˆØ³Ø§ÛŒÙ„ Ù†Ù‚Ù„ÛŒÙ‡ Ùˆ Ø³Ø§ÛŒØ± Ø§Ø´ÛŒØ§Ø¡"
)
async def detect_objects_in_image(
    request: ObjectDetectionRequest
):
    """
    Detect objects in satellite imagery
    
    - **object_types**: Types of objects to detect
    - **confidence_threshold**: Minimum detection confidence
    - **max_detections**: Maximum number of detections
    """
    start_time = time.time()
    
    try:
        # Load image
        if request.image_url:
            image = await image_analysis_service.load_image_from_url(request.image_url)
        elif request.image_base64:
            image = await image_analysis_service.load_image_from_base64(request.image_base64)
        else:
            raise HTTPException(status_code=400, detail="No image provided")
        
        # Detect objects
        target_classes = [ot.value for ot in request.object_types] if request.object_types else None
        
        results = await image_analysis_service.detect_objects_in_image(
            image,
            target_classes=target_classes,
            confidence_threshold=request.confidence_threshold
        )
        
        processing_time = (time.time() - start_time) * 1000
        
        # Limit detections
        detections = results["detections"][:request.max_detections]
        
        return ObjectDetectionResponse(
            success=True,
            total_objects=len(detections),
            detections=[
                {
                    "object_type": d["class"],
                    "confidence": d["confidence"],
                    "bounding_box": {
                        "x_min": d["bbox"][0],
                        "y_min": d["bbox"][1],
                        "x_max": d["bbox"][2],
                        "y_max": d["bbox"][3]
                    },
                    "center_point": {
                        "type": "Point",
                        "coordinates": list(d["center"])
                    },
                    "area_sqm": d["area_pixels"]
                }
                for d in detections
            ],
            processing_time_ms=processing_time
        )
        
    except Exception as e:
        logger.error(f"Object detection error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post(
    "/upload-and-analyze",
    summary="Ø¢Ù¾Ù„ÙˆØ¯ Ùˆ ØªØ­Ù„ÛŒÙ„ Ú©Ø§Ù…Ù„ ØªØµÙˆÛŒØ±",
    description="Ø¢Ù¾Ù„ÙˆØ¯ ØªØµÙˆÛŒØ± Ùˆ Ø§Ù†Ø¬Ø§Ù… ØªØ­Ù„ÛŒÙ„ Ú©Ø§Ù…Ù„ Ø´Ø§Ù…Ù„ Ø·Ø¨Ù‚Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§Ø¡"
)
async def upload_and_analyze_image(
    file: UploadFile = File(...),
    include_object_detection: bool = True,
    include_land_use: bool = True
):
    """
    Upload image and perform full analysis
    """
    from PIL import Image
    import io
    
    start_time = time.time()
    
    try:
        # Read uploaded file
        contents = await file.read()
        image = Image.open(io.BytesIO(contents)).convert("RGB")
        
        results = {
            "filename": file.filename,
            "image_size": image.size
        }
        
        if include_land_use:
            land_use = await image_analysis_service.analyze_land_use(image)
            results["land_use_analysis"] = land_use
        
        if include_object_detection:
            detection = await image_analysis_service.detect_objects_in_image(image)
            results["object_detection"] = detection
        
        results["total_processing_time_ms"] = (time.time() - start_time) * 1000
        
        return results
        
    except Exception as e:
        logger.error(f"Upload and analyze error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Spatial Analysis Endpoints
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.post(
    "/clustering",
    response_model=SpatialClusteringResponse,
    summary="Ø®ÙˆØ´Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ú©Ø§Ù†ÛŒ",
    description="Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø®ÙˆØ´Ù‡â€ŒÙ‡Ø§ Ùˆ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¯Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ù‚Ø·Ù‡â€ŒØ§ÛŒ"
)
async def perform_spatial_clustering(
    request: SpatialClusteringRequest
):
    """
    Perform spatial clustering analysis
    
    - **algorithm**: Clustering algorithm (kmeans, dbscan, hdbscan)
    - **n_clusters**: Number of clusters (for kmeans)
    - **eps**: Maximum distance in meters (for DBSCAN)
    """
    start_time = time.time()
    
    try:
        # Convert to SpatialPoint objects
        points = [
            SpatialPoint(
                lon=p.coordinates[0],
                lat=p.coordinates[1]
            )
            for p in request.points
        ]
        
        # Run clustering
        if request.algorithm == "kmeans":
            n_clusters = request.n_clusters or 5
            results = await spatial_clustering_service.kmeans_clustering(
                points,
                n_clusters=n_clusters
            )
        elif request.algorithm == "dbscan":
            eps = request.eps or 500
            results = await spatial_clustering_service.dbscan_clustering(
                points,
                eps_meters=eps,
                min_samples=request.min_samples
            )
        else:
            raise HTTPException(status_code=400, detail=f"Unknown algorithm: {request.algorithm}")
        
        processing_time = (time.time() - start_time) * 1000
        
        return SpatialClusteringResponse(
            success=True,
            algorithm=results["algorithm"],
            n_clusters=results["n_clusters"],
            clusters=[
                {
                    "cluster_id": c["cluster_id"],
                    "centroid": {
                        "type": "Point",
                        "coordinates": [c["centroid"]["lon"], c["centroid"]["lat"]]
                    },
                    "point_count": c["point_count"],
                    "radius_meters": c["radius_meters"],
                    "density": c["density_per_sqkm"],
                    "is_outlier": c.get("is_outlier", False)
                }
                for c in results["clusters"]
            ],
            silhouette_score=results.get("silhouette_score"),
            processing_time_ms=processing_time
        )
        
    except Exception as e:
        logger.error(f"Clustering error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post(
    "/hotspot-analysis",
    summary="ØªØ­Ù„ÛŒÙ„ Ù†Ù‚Ø§Ø· Ø¯Ø§Øº",
    description="Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù†Ù‚Ø§Ø· Ø¯Ø§Øº Ùˆ Ù…Ù†Ø§Ø·Ù‚ Ø¨Ø§ ØªØ±Ø§Ú©Ù… Ø¨Ø§Ù„Ø§"
)
async def perform_hotspot_analysis(
    points: List[dict],
    bandwidth_meters: float = 1000
):
    """
    Perform hotspot analysis using Kernel Density Estimation
    
    - **points**: List of points with optional values
    - **bandwidth_meters**: KDE bandwidth in meters
    """
    start_time = time.time()
    
    try:
        spatial_points = [
            SpatialPoint(
                lon=p["coordinates"][0],
                lat=p["coordinates"][1],
                value=p.get("value", 1.0)
            )
            for p in points
        ]
        
        results = await spatial_clustering_service.hotspot_analysis(
            spatial_points,
            bandwidth_meters=bandwidth_meters
        )
        
        results["processing_time_ms"] = (time.time() - start_time) * 1000
        
        return results
        
    except Exception as e:
        logger.error(f"Hotspot analysis error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NLP Endpoints
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.post(
    "/natural-language-query",
    response_model=NaturalLanguageQueryResponse,
    summary="Ø¬Ø³ØªØ¬ÙˆÛŒ Ø²Ø¨Ø§Ù† Ø·Ø¨ÛŒØ¹ÛŒ",
    description="Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©ÙˆØ¦Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ù‡ Ø²Ø¨Ø§Ù† Ø·Ø¨ÛŒØ¹ÛŒ ÙØ§Ø±Ø³ÛŒ"
)
async def process_natural_language_query(
    request: NaturalLanguageQueryRequest
):
    """
    Process natural language spatial query
    
    - **query**: Natural language query in Persian
    - **location_hint**: Optional user location for context
    - **search_radius_km**: Search radius in kilometers
    """
    start_time = time.time()
    
    try:
        # Parse query
        user_location = None
        if request.location_hint:
            user_location = (
                request.location_hint.coordinates[0],
                request.location_hint.coordinates[1]
            )
        
        parsed_query = await geo_nlp_service.parse_spatial_query(
            query=request.query,
            context=request.context,
            user_location=user_location
        )
        
        # Generate PostGIS query
        sql_query = await geo_nlp_service.generate_postgis_query(parsed_query)
        
        processing_time = (time.time() - start_time) * 1000
        
        return NaturalLanguageQueryResponse(
            success=True,
            interpreted_query=parsed_query.interpreted_query,
            extracted_entities={
                "intent": parsed_query.intent.value,
                "locations": [l["name"] for l in parsed_query.location_references],
                "spatial_relations": parsed_query.spatial_relations,
                "attributes": parsed_query.attributes,
                "generated_sql": sql_query
            },
            results=[],  # Would be populated from database query
            suggestions=[
                "Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù†Ø§Ù… Ù…Ø­Ù„Ù‡ Ø±Ø§ Ù…Ø´Ø®Øµâ€ŒØªØ± Ú©Ù†ÛŒØ¯",
                "Ø¨Ø±Ø§ÛŒ Ù†ØªØ§ÛŒØ¬ Ø¨Ù‡ØªØ±ØŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø®ÙˆØ¯ Ø±Ø§ ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯"
            ],
            processing_time_ms=processing_time
        )
        
    except Exception as e:
        logger.error(f"NLP query error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post(
    "/geocode",
    summary="ØªØ¨Ø¯ÛŒÙ„ Ø¢Ø¯Ø±Ø³ Ø¨Ù‡ Ù…Ø®ØªØµØ§Øª",
    description="Geocoding Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒ ÙØ§Ø±Ø³ÛŒ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² AI"
)
async def geocode_address(
    request: GeocodingRequest
):
    """
    Convert Persian address to coordinates
    
    - **address**: Address string in Persian
    - **country_hint**: Country code (default: IR)
    - **fuzzy_match**: Enable fuzzy matching
    """
    try:
        result = await geo_nlp_service.geocode_address(
            address=request.address,
            country_hint=request.country_hint
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Geocoding error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get(
    "/reverse-geocode",
    summary="ØªØ¨Ø¯ÛŒÙ„ Ù…Ø®ØªØµØ§Øª Ø¨Ù‡ Ø¢Ø¯Ø±Ø³",
    description="Reverse Geocoding Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² AI"
)
async def reverse_geocode(
    lon: float,
    lat: float,
    language: str = "fa"
):
    """
    Convert coordinates to address
    
    - **lon**: Longitude
    - **lat**: Latitude
    - **language**: Output language
    """
    try:
        result = await geo_nlp_service.reverse_geocode(
            lon=lon,
            lat=lat,
            language=language
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Reverse geocoding error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get(
    "/suggest-places",
    summary="Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…Ú©Ø§Ù†",
    description="Autocomplete Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ú©Ø§Ù†"
)
async def suggest_places(
    query: str,
    lon: Optional[float] = None,
    lat: Optional[float] = None,
    limit: int = 5
):
    """
    Get place suggestions for autocomplete
    
    - **query**: Partial search query
    - **lon, lat**: User location for relevance
    - **limit**: Maximum suggestions
    """
    try:
        user_location = (lon, lat) if lon and lat else None
        
        suggestions = await geo_nlp_service.suggest_places(
            partial_query=query,
            user_location=user_location,
            limit=limit
        )
        
        return {"suggestions": suggestions}
        
    except Exception as e:
        logger.error(f"Place suggestion error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AI Analysis Endpoints
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.post(
    "/analyze-pattern",
    summary="ØªØ­Ù„ÛŒÙ„ Ø§Ù„Ú¯ÙˆÛŒ Ù…Ú©Ø§Ù†ÛŒ",
    description="ØªØ­Ù„ÛŒÙ„ Ùˆ ØªÙˆØµÛŒÙ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ø§ AI"
)
async def analyze_spatial_pattern(
    pattern_data: dict,
    context: Optional[str] = None
):
    """
    Analyze and describe spatial patterns using AI
    
    - **pattern_data**: Statistical/spatial pattern data
    - **context**: Additional context for analysis
    """
    try:
        result = await geo_ai_service.describe_spatial_pattern(
            pattern_data=pattern_data,
            context=context
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Pattern analysis error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post(
    "/generate-analysis-plan",
    summary="ØªÙˆÙ„ÛŒØ¯ Ø¨Ø±Ù†Ø§Ù…Ù‡ ØªØ­Ù„ÛŒÙ„",
    description="Ø·Ø±Ø§Ø­ÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ ØªØ­Ù„ÛŒÙ„ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ø§ AI"
)
async def generate_analysis_plan(
    objective: str,
    available_data: List[str],
    constraints: Optional[dict] = None
):
    """
    Generate spatial analysis plan using AI
    
    - **objective**: Analysis objective
    - **available_data**: List of available datasets
    - **constraints**: Analysis constraints
    """
    try:
        result = await geo_ai_service.generate_spatial_analysis_plan(
            objective=objective,
            available_data=available_data,
            constraints=constraints
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Analysis plan generation error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post(
    "/extract-locations",
    summary="Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§Ø² Ù…ØªÙ†",
    description="Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ùˆ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ø§Ø² Ù…ØªÙ†"
)
async def extract_locations_from_text(
    text: str,
    language: str = "fa"
):
    """
    Extract geographic locations from text (NER)
    
    - **text**: Input text
    - **language**: Text language
    """
    try:
        result = await geo_ai_service.extract_locations_from_text(
            text=text,
            language=language
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Location extraction error: {e}")
        raise HTTPException(status_code=500, detail=str(e))</code></pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.10: MAIN APPLICATION
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û±Û° ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù†</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ</span>
                        <span>app/main.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn copy-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
import logging

from app.config import settings
from app.api.v1.ai_endpoints import router as ai_router

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan events"""
    # Startup
    logger.info(f"Starting {settings.APP_NAME} v{settings.APP_VERSION}")
    logger.info(f"Debug mode: {settings.DEBUG}")
    
    # Initialize ML models
    logger.info("Loading ML models...")
    # Models are loaded lazily in services
    
    yield
    
    # Shutdown
    logger.info("Shutting down application...")


# Create FastAPI application
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="""
    ## GeoAI FastAPI
    
    ÛŒÚ© API Ø¬Ø§Ù…Ø¹ Ø¨Ø±Ø§ÛŒ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ù…Ø¨ØªÙ†ÛŒ Ø¨Ø± Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ
    
    ### Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§:
    
    * ğŸ›°ï¸ **ØªØ­Ù„ÛŒÙ„ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ** - Ø·Ø¨Ù‚Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø²Ù…ÛŒÙ† Ùˆ ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§Ø¡
    * ğŸ“ **Ø®ÙˆØ´Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ú©Ø§Ù†ÛŒ** - Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø§Ù„Ú¯ÙˆÙ‡Ø§ Ùˆ Ù†Ù‚Ø§Ø· Ø¯Ø§Øº
    * ğŸ’¬ **Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø²Ø¨Ø§Ù† Ø·Ø¨ÛŒØ¹ÛŒ** - Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ù‡ Ø²Ø¨Ø§Ù† ÙØ§Ø±Ø³ÛŒ
    * ğŸ—ºï¸ **Geocoding Ù‡ÙˆØ´Ù…Ù†Ø¯** - ØªØ¨Ø¯ÛŒÙ„ Ø¢Ø¯Ø±Ø³ Ø¨Ù‡ Ù…Ø®ØªØµØ§Øª Ùˆ Ø¨Ø§Ù„Ø¹Ú©Ø³
    * ğŸ“Š **ØªØ­Ù„ÛŒÙ„ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ** - ØªÙˆØµÛŒÙ Ùˆ ØªÙØ³ÛŒØ± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ
    
    ### ØªÚ©Ù†ÙˆÙ„ÙˆÚ˜ÛŒâ€ŒÙ‡Ø§:
    
    * FastAPI + Async
    * PyTorch / TensorFlow
    * OpenAI GPT-4
    * PostGIS
    * Scikit-learn
    """,
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Include routers
app.include_router(ai_router, prefix="/api/v1")


# Root endpoint
@app.get("/", tags=["Root"])
async def root():
    """Root endpoint with API information"""
    return {
        "name": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "status": "running",
        "docs": "/docs",
        "endpoints": {
            "ai": "/api/v1/ai",
            "health": "/health"
        }
    }


# Health check
@app.get("/health", tags=["Health"])
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "version": settings.APP_VERSION,
        "services": {
            "api": "up",
            "ml_models": "loaded",
            "openai": "connected" if settings.OPENAI_API_KEY else "not configured"
        }
    }


# Error handlers
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """Global exception handler"""
    logger.error(f"Unhandled exception: {exc}")
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal server error",
            "detail": str(exc) if settings.DEBUG else "An error occurred"
        }
    )


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.DEBUG
    )</code></pre>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         4.11: USAGE EXAMPLES
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <h3>Û´.Û±Û± Ù…Ø«Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <span>ğŸ</span>
                        <span>examples/usage.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn copy-btn" onclick="copyCode(this)">
                            <span>ğŸ“‹</span> Ú©Ù¾ÛŒ
                        </button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">import httpx
import asyncio
import base64
from pathlib import Path

BASE_URL = "http://localhost:8000/api/v1"


async def example_image_classification():
    """Example: Classify satellite image"""
    print("\n" + "="*50)
    print("ğŸ›°ï¸ Image Classification Example")
    print("="*50)
    
    async with httpx.AsyncClient() as client:
        # Using image URL
        response = await client.post(
            f"{BASE_URL}/ai/classify-image",
            json={
                "image_url": "https://example.com/satellite_image.jpg",
                "confidence_threshold": 0.7
            },
            timeout=60.0
        )
        
        result = response.json()
        print(f"Dominant class: {result.get('dominant_class')}")
        print(f"Processing time: {result.get('processing_time_ms'):.2f}ms")
        
        for cls in result.get('classifications', []):
            print(f"  - {cls['class_name']}: {cls['confidence']:.2%}")


async def example_object_detection():
    """Example: Detect objects in satellite image"""
    print("\n" + "="*50)
    print("ğŸ” Object Detection Example")
    print("="*50)
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{BASE_URL}/ai/detect-objects",
            json={
                "image_url": "https://example.com/aerial_view.jpg",
                "object_types": ["building", "road", "vehicle"],
                "confidence_threshold": 0.5,
                "max_detections": 50
            },
            timeout=60.0
        )
        
        result = response.json()
        print(f"Total objects detected: {result.get('total_objects')}")
        
        for det in result.get('detections', [])[:5]:
            print(f"  - {det['object_type']}: {det['confidence']:.2%}")


async def example_spatial_clustering():
    """Example: Perform spatial clustering"""
    print("\n" + "="*50)
    print("ğŸ“Š Spatial Clustering Example")
    print("="*50)
    
    # Sample points (Tehran area)
    points = [
        {"type": "Point", "coordinates": [51.3890, 35.6892]},
        {"type": "Point", "coordinates": [51.3900, 35.6895]},
        {"type": "Point", "coordinates": [51.3880, 35.6888]},
        {"type": "Point", "coordinates": [51.4100, 35.7000]},
        {"type": "Point", "coordinates": [51.4110, 35.7005]},
        {"type": "Point", "coordinates": [51.4090, 35.6995]},
        {"type": "Point", "coordinates": [51.4500, 35.7200]},
        {"type": "Point", "coordinates": [51.4510, 35.7210]},
    ]
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{BASE_URL}/ai/clustering",
            json={
                "points": points,
                "algorithm": "dbscan",
                "eps": 500,
                "min_samples": 2
            },
            timeout=30.0
        )
        
        result = response.json()
        print(f"Algorithm: {result.get('algorithm')}")
        print(f"Number of clusters: {result.get('n_clusters')}")
        print(f"Silhouette score: {result.get('silhouette_score', 'N/A')}")
        
        for cluster in result.get('clusters', []):
            print(f"  Cluster {cluster['cluster_id']}: {cluster['point_count']} points")


async def example_nlp_query():
    """Example: Natural language spatial query"""
    print("\n" + "="*50)
    print("ğŸ’¬ Natural Language Query Example")
    print("="*50)
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{BASE_URL}/ai/natural-language-query",
            json={
                "query": "Ø±Ø³ØªÙˆØ±Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø§ÛŒØªØ§Ù„ÛŒØ§ÛŒÛŒ Ù†Ø²Ø¯ÛŒÚ© Ù…ÛŒØ¯Ø§Ù† ÙˆÙ†Ú©",
                "location_hint": {
                    "type": "Point",
                    "coordinates": [51.4103, 35.7575]
                },
                "search_radius_km": 2.0,
                "max_results": 10,
                "language": "fa"
            },
            timeout=30.0
        )
        
        result = response.json()
        print(f"Interpreted query: {result.get('interpreted_query')}")
        print(f"Extracted entities: {result.get('extracted_entities')}")


async def example_geocoding():
    """Example: Geocode Persian address"""
    print("\n" + "="*50)
    print("ğŸ“ Geocoding Example")
    print("="*50)
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{BASE_URL}/ai/geocode",
            json={
                "address": "ØªÙ‡Ø±Ø§Ù†ØŒ Ø®ÛŒØ§Ø¨Ø§Ù† ÙˆÙ„ÛŒØ¹ØµØ±ØŒ Ù†Ø±Ø³ÛŒØ¯Ù‡ Ø¨Ù‡ Ù…ÛŒØ¯Ø§Ù† ÙˆÙ†Ú©ØŒ Ù¾Ù„Ø§Ú© Û±Û²Û³",
                "country_hint": "IR",
                "fuzzy_match": True
            },
            timeout=30.0
        )
        
        result = response.json()
        if result.get('success'):
            parsed = result['result']['parsed_address']
            print(f"City: {parsed.get('city')}")
            print(f"Street: {parsed.get('street')}")
            print(f"Building: {parsed.get('building_number')}")


async def example_reverse_geocoding():
    """Example: Reverse geocode coordinates"""
    print("\n" + "="*50)
    print("ğŸ—ºï¸ Reverse Geocoding Example")
    print("="*50)
    
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"{BASE_URL}/ai/reverse-geocode",
            params={
                "lon": 51.4103,
                "lat": 35.7575,
                "language": "fa"
            },
            timeout=30.0
        )
        
        result = response.json()
        if result.get('success'):
            print(f"Address: {result['result']['formatted_address']}")
            print(f"Place type: {result['result']['place_type']}")


async def example_pattern_analysis():
    """Example: Analyze spatial pattern"""
    print("\n" + "="*50)
    print("ğŸ“ˆ Pattern Analysis Example")
    print("="*50)
    
    pattern_data = {
        "type": "clustering_result",
        "n_clusters": 5,
        "cluster_sizes": [120, 85, 67, 45, 23],
        "spatial_extent_km": 15.5,
        "density_variation": 0.45,
        "dominant_direction": "northwest"
    }
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{BASE_URL}/ai/analyze-pattern",
            json=pattern_data,
            params={"context": "ØªØ­Ù„ÛŒÙ„ ØªÙˆØ²ÛŒØ¹ Ø¯Ø§Ø±ÙˆØ®Ø§Ù†Ù‡â€ŒÙ‡Ø§ Ø¯Ø± ØªÙ‡Ø±Ø§Ù†"},
            timeout=30.0
        )
        
        result = response.json()
        if result.get('success'):
            desc = result['description']
            print(f"Summary: {desc.get('summary')}")
            print(f"Key findings:")
            for finding in desc.get('key_findings', []):
                print(f"  - {finding}")


async def example_analysis_plan():
    """Example: Generate analysis plan"""
    print("\n" + "="*50)
    print("ğŸ“‹ Analysis Plan Generation Example")
    print("="*50)
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{BASE_URL}/ai/generate-analysis-plan",
            json={
                "objective": "Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù…Ù†Ø§Ø·Ù‚ Ù…Ù†Ø§Ø³Ø¨ Ø¨Ø±Ø§ÛŒ Ø§Ø­Ø¯Ø§Ø« Ù¾Ø§Ø±Ú©ÛŒÙ†Ú¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø¯Ø± Ù…Ù†Ø·Ù‚Ù‡ Û¶ ØªÙ‡Ø±Ø§Ù†",
                "available_data": [
                    "Ù†Ù‚Ø´Ù‡ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø²Ù…ÛŒÙ†",
                    "Ø´Ø¨Ú©Ù‡ Ù…Ø¹Ø§Ø¨Ø±",
                    "Ù…ÙˆÙ‚Ø¹ÛŒØª Ù¾Ø§Ø±Ú©ÛŒÙ†Ú¯â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯",
                    "ØªØ±Ø§Ú©Ù… Ø¬Ù…Ø¹ÛŒØª",
                    "Ù…Ø±Ø§Ú©Ø² ØªØ¬Ø§Ø±ÛŒ"
                ],
                "constraints": {
                    "budget": "Ù…Ø­Ø¯ÙˆØ¯",
                    "timeline": "Û³ Ù…Ø§Ù‡",
                    "min_capacity": 100
                }
            },
            timeout=60.0
        )
        
        result = response.json()
        if result.get('success'):
            plan = result['analysis_plan']
            print("Analysis Steps:")
            for step in plan.get('analysis_steps', []):
                print(f"  {step['step']}. {step['name']}")
                print(f"     Tools: {', '.join(step.get('tools', []))}")


async def main():
    """Run all examples"""
    print("\n" + "ğŸš€ GeoAI FastAPI - Usage Examples")
    print("="*60)
    
    try:
        await example_spatial_clustering()
        await example_nlp_query()
        await example_geocoding()
        await example_reverse_geocoding()
        await example_pattern_analysis()
        await example_analysis_plan()
        
        # These require actual images
        # await example_image_classification()
        # await example_object_detection()
        
    except httpx.ConnectError:
        print("\nâŒ Error: Could not connect to API server")
        print("   Make sure the server is running on http://localhost:8000")
    except Exception as e:
        print(f"\nâŒ Error: {e}")


if __name__ == "__main__":
    asyncio.run(main())</code></pre>
                </div>
            </div>

        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 5: SATELLITE IMAGERY
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section ai-section" id="satellite">
            <div class="section-header">
                <div class="section-icon">ğŸ›°ï¸</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ûµ</div>
                    <h2 class="section-title">Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h2>
                    <p class="section-subtitle">Rasterio, NDVI, Cloud Masking</p>
                </div>
            </div>

            <h3>Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/services/satellite.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">import rasterio
from rasterio.io import MemoryFile
from rasterio.warp import calculate_default_transform, reproject, Resampling
from rasterio.mask import mask as rasterio_mask
from rasterio.features import shapes
import numpy as np
from PIL import Image
from typing import Dict, Any, Optional, Tuple, List
from shapely.geometry import shape, mapping, box
import io
import logging

logger = logging.getLogger(__name__)


class SatelliteImageProcessor:
    """
    Satellite imagery processing service
    Supports: Sentinel-2, Landsat, custom GeoTIFF
    """
    
    # Band indices for common satellites
    SENTINEL2_BANDS = {
        'blue': 2, 'green': 3, 'red': 4,
        'nir': 8, 'swir1': 11, 'swir2': 12
    }
    
    LANDSAT8_BANDS = {
        'blue': 2, 'green': 3, 'red': 4,
        'nir': 5, 'swir1': 6, 'swir2': 7
    }
    
    def __init__(self):
        pass
    
    def read_geotiff(self, file_bytes: bytes) -> Dict[str, Any]:
        """Read GeoTIFF and return metadata and data"""
        with MemoryFile(file_bytes) as memfile:
            with memfile.open() as src:
                return {
                    'data': src.read(),
                    'profile': src.profile,
                    'bounds': src.bounds,
                    'crs': str(src.crs),
                    'transform': src.transform,
                    'width': src.width,
                    'height': src.height,
                    'count': src.count,
                    'dtypes': src.dtypes
                }
    
    def calculate_ndvi(
        self,
        red_band: np.ndarray,
        nir_band: np.ndarray
    ) -> np.ndarray:
        """
        Calculate Normalized Difference Vegetation Index
        
        NDVI = (NIR - Red) / (NIR + Red)
        Range: -1 to 1 (higher = more vegetation)
        """
        # Avoid division by zero
        np.seterr(divide='ignore', invalid='ignore')
        
        red = red_band.astype(np.float32)
        nir = nir_band.astype(np.float32)
        
        ndvi = (nir - red) / (nir + red)
        ndvi = np.nan_to_num(ndvi, nan=0.0, posinf=1.0, neginf=-1.0)
        
        return ndvi
    
    def calculate_ndwi(
        self,
        green_band: np.ndarray,
        nir_band: np.ndarray
    ) -> np.ndarray:
        """
        Calculate Normalized Difference Water Index
        
        NDWI = (Green - NIR) / (Green + NIR)
        Higher values indicate water bodies
        """
        np.seterr(divide='ignore', invalid='ignore')
        
        green = green_band.astype(np.float32)
        nir = nir_band.astype(np.float32)
        
        ndwi = (green - nir) / (green + nir)
        ndwi = np.nan_to_num(ndwi, nan=0.0, posinf=1.0, neginf=-1.0)
        
        return ndwi
    
    def calculate_ndbi(
        self,
        swir_band: np.ndarray,
        nir_band: np.ndarray
    ) -> np.ndarray:
        """
        Calculate Normalized Difference Built-up Index
        
        NDBI = (SWIR - NIR) / (SWIR + NIR)
        Higher values indicate built-up areas
        """
        np.seterr(divide='ignore', invalid='ignore')
        
        swir = swir_band.astype(np.float32)
        nir = nir_band.astype(np.float32)
        
        ndbi = (swir - nir) / (swir + nir)
        ndbi = np.nan_to_num(ndbi, nan=0.0, posinf=1.0, neginf=-1.0)
        
        return ndbi
    
    def create_rgb_composite(
        self,
        red: np.ndarray,
        green: np.ndarray,
        blue: np.ndarray,
        percentile_clip: Tuple[int, int] = (2, 98)
    ) -> np.ndarray:
        """Create RGB composite with histogram stretching"""
        
        def stretch_band(band):
            p_low, p_high = np.percentile(band, percentile_clip)
            band = np.clip(band, p_low, p_high)
            band = ((band - p_low) / (p_high - p_low) * 255).astype(np.uint8)
            return band
        
        rgb = np.dstack([
            stretch_band(red),
            stretch_band(green),
            stretch_band(blue)
        ])
        
        return rgb
    
    def create_false_color(
        self,
        nir: np.ndarray,
        red: np.ndarray,
        green: np.ndarray,
        percentile_clip: Tuple[int, int] = (2, 98)
    ) -> np.ndarray:
        """Create false color composite (NIR-R-G) for vegetation analysis"""
        return self.create_rgb_composite(nir, red, green, percentile_clip)
    
    def colorize_index(
        self,
        index: np.ndarray,
        colormap: str = 'ndvi'
    ) -> np.ndarray:
        """Apply colormap to index raster"""
        import matplotlib.pyplot as plt
        
        colormaps = {
            'ndvi': 'RdYlGn',
            'ndwi': 'Blues',
            'ndbi': 'YlOrRd',
            'temperature': 'coolwarm'
        }
        
        cmap = plt.get_cmap(colormaps.get(colormap, 'viridis'))
        
        # Normalize to 0-1
        normalized = (index - index.min()) / (index.max() - index.min())
        
        # Apply colormap
        colored = cmap(normalized)[:, :, :3]  # Remove alpha
        colored = (colored * 255).astype(np.uint8)
        
        return colored
    
    def clip_to_geometry(
        self,
        file_bytes: bytes,
        geometry: Dict[str, Any]
    ) -> bytes:
        """Clip raster to geometry boundary"""
        geom = shape(geometry)
        
        with MemoryFile(file_bytes) as memfile:
            with memfile.open() as src:
                out_image, out_transform = rasterio_mask(
                    src, [geom], crop=True
                )
                out_meta = src.meta.copy()
                
                out_meta.update({
                    "driver": "GTiff",
                    "height": out_image.shape[1],
                    "width": out_image.shape[2],
                    "transform": out_transform
                })
        
        # Write to memory
        output = io.BytesIO()
        with MemoryFile(output) as memfile:
            with memfile.open(**out_meta) as dest:
                dest.write(out_image)
        
        output.seek(0)
        return output.read()
    
    def reproject_raster(
        self,
        file_bytes: bytes,
        dst_crs: str = 'EPSG:4326'
    ) -> bytes:
        """Reproject raster to different CRS"""
        with MemoryFile(file_bytes) as memfile:
            with memfile.open() as src:
                transform, width, height = calculate_default_transform(
                    src.crs, dst_crs, src.width, src.height, *src.bounds
                )
                
                kwargs = src.meta.copy()
                kwargs.update({
                    'crs': dst_crs,
                    'transform': transform,
                    'width': width,
                    'height': height
                })
                
                output = io.BytesIO()
                with MemoryFile(output) as out_memfile:
                    with out_memfile.open(**kwargs) as dst:
                        for i in range(1, src.count + 1):
                            reproject(
                                source=rasterio.band(src, i),
                                destination=rasterio.band(dst, i),
                                src_transform=src.transform,
                                src_crs=src.crs,
                                dst_transform=transform,
                                dst_crs=dst_crs,
                                resampling=Resampling.bilinear
                            )
        
        output.seek(0)
        return output.read()
    
    def get_statistics(
        self,
        band: np.ndarray,
        nodata: Optional[float] = None
    ) -> Dict[str, float]:
        """Calculate band statistics"""
        if nodata is not None:
            band = np.ma.masked_equal(band, nodata)
        
        return {
            'min': float(np.min(band)),
            'max': float(np.max(band)),
            'mean': float(np.mean(band)),
            'std': float(np.std(band)),
            'median': float(np.median(band))
        }
    
    def classify_ndvi(
        self,
        ndvi: np.ndarray
    ) -> Tuple[np.ndarray, Dict[str, int]]:
        """
        Classify NDVI into land cover categories
        
        Returns classified raster and class counts
        """
        classes = {
            'water': (-1.0, 0.0),
            'bare_soil': (0.0, 0.2),
            'sparse_vegetation': (0.2, 0.4),
            'moderate_vegetation': (0.4, 0.6),
            'dense_vegetation': (0.6, 1.0)
        }
        
        classified = np.zeros_like(ndvi, dtype=np.uint8)
        counts = {}
        
        for i, (class_name, (low, high)) in enumerate(classes.items(), 1):
            mask = (ndvi >= low) & (ndvi < high)
            classified[mask] = i
            counts[class_name] = int(np.sum(mask))
        
        return classified, counts
    
    def detect_clouds(
        self,
        blue: np.ndarray,
        threshold: float = 0.3
    ) -> np.ndarray:
        """Simple cloud detection based on brightness"""
        # Normalize
        blue_norm = blue.astype(np.float32)
        if blue_norm.max() > 1:
            blue_norm = blue_norm / blue_norm.max()
        
        cloud_mask = blue_norm > threshold
        return cloud_mask.astype(np.uint8)


# Singleton
_processor: Optional[SatelliteImageProcessor] = None

def get_satellite_processor() -> SatelliteImageProcessor:
    global _processor
    if _processor is None:
        _processor = SatelliteImageProcessor()
    return _processor</code></pre>
                </div>
            </div>

            <h3>API Endpoints Ø¨Ø±Ø§ÛŒ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/api/v1/satellite.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import APIRouter, HTTPException, UploadFile, File, Query
from fastapi.responses import StreamingResponse, Response
from typing import Optional, Literal
import io
import numpy as np
from PIL import Image

from app.services.satellite import get_satellite_processor

router = APIRouter(prefix="/satellite", tags=["Satellite Imagery"])


@router.post("/info")
async def get_raster_info(file: UploadFile = File(...)):
    """
    ğŸ“‹ Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙØ§ÛŒÙ„ GeoTIFF
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    info = processor.read_geotiff(contents)
    
    return {
        "filename": file.filename,
        "crs": info['crs'],
        "bounds": {
            "left": info['bounds'].left,
            "bottom": info['bounds'].bottom,
            "right": info['bounds'].right,
            "top": info['bounds'].top
        },
        "size": {
            "width": info['width'],
            "height": info['height']
        },
        "bands": info['count'],
        "dtypes": list(info['dtypes'])
    }


@router.post("/ndvi")
async def calculate_ndvi(
    file: UploadFile = File(...),
    red_band: int = Query(default=4, ge=1, description="Red band number"),
    nir_band: int = Query(default=8, ge=1, description="NIR band number"),
    return_image: bool = True
):
    """
    ğŸŒ¿ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø§Ø®Øµ NDVI
    
    - **red_band**: Ø´Ù…Ø§Ø±Ù‡ Ø¨Ø§Ù†Ø¯ Ù‚Ø±Ù…Ø² (Ù¾ÛŒØ´â€ŒÙØ±Ø¶: 4 Ø¨Ø±Ø§ÛŒ Sentinel-2)
    - **nir_band**: Ø´Ù…Ø§Ø±Ù‡ Ø¨Ø§Ù†Ø¯ NIR (Ù¾ÛŒØ´â€ŒÙØ±Ø¶: 8 Ø¨Ø±Ø§ÛŒ Sentinel-2)
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    
    if red_band > raster['count'] or nir_band > raster['count']:
        raise HTTPException(
            status_code=400,
            detail=f"Band number exceeds available bands ({raster['count']})"
        )
    
    red = raster['data'][red_band - 1]
    nir = raster['data'][nir_band - 1]
    
    ndvi = processor.calculate_ndvi(red, nir)
    stats = processor.get_statistics(ndvi)
    
    if return_image:
        colored = processor.colorize_index(ndvi, 'ndvi')
        img = Image.fromarray(colored)
        
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        
        return StreamingResponse(
            buffer,
            media_type="image/png",
            headers={"X-NDVI-Stats": str(stats)}
        )
    
    return {
        "statistics": stats,
        "classification": processor.classify_ndvi(ndvi)[1]
    }


@router.post("/ndwi")
async def calculate_ndwi(
    file: UploadFile = File(...),
    green_band: int = Query(default=3, ge=1),
    nir_band: int = Query(default=8, ge=1),
    return_image: bool = True
):
    """
    ğŸ’§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø§Ø®Øµ NDWI (ØªØ´Ø®ÛŒØµ Ø¢Ø¨)
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    
    green = raster['data'][green_band - 1]
    nir = raster['data'][nir_band - 1]
    
    ndwi = processor.calculate_ndwi(green, nir)
    stats = processor.get_statistics(ndwi)
    
    if return_image:
        colored = processor.colorize_index(ndwi, 'ndwi')
        img = Image.fromarray(colored)
        
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        
        return StreamingResponse(buffer, media_type="image/png")
    
    return {"statistics": stats}


@router.post("/ndbi")
async def calculate_ndbi(
    file: UploadFile = File(...),
    swir_band: int = Query(default=11, ge=1),
    nir_band: int = Query(default=8, ge=1),
    return_image: bool = True
):
    """
    ğŸ—ï¸ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø§Ø®Øµ NDBI (ØªØ´Ø®ÛŒØµ Ù…Ù†Ø§Ø·Ù‚ Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡)
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    
    swir = raster['data'][swir_band - 1]
    nir = raster['data'][nir_band - 1]
    
    ndbi = processor.calculate_ndbi(swir, nir)
    stats = processor.get_statistics(ndbi)
    
    if return_image:
        colored = processor.colorize_index(ndbi, 'ndbi')
        img = Image.fromarray(colored)
        
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        
        return StreamingResponse(buffer, media_type="image/png")
    
    return {"statistics": stats}


@router.post("/composite")
async def create_composite(
    file: UploadFile = File(...),
    composite_type: Literal["rgb", "false_color", "agriculture"] = "rgb",
    red_band: int = 4,
    green_band: int = 3,
    blue_band: int = 2,
    nir_band: int = 8
):
    """
    ğŸ¨ Ø§ÛŒØ¬Ø§Ø¯ ØªØ±Ú©ÛŒØ¨ Ø±Ù†Ú¯ÛŒ
    
    - **rgb**: ØªØ±Ú©ÛŒØ¨ Ø±Ù†Ú¯ Ø·Ø¨ÛŒØ¹ÛŒ
    - **false_color**: NIR-Red-Green Ø¨Ø±Ø§ÛŒ Ù¾ÙˆØ´Ø´ Ú¯ÛŒØ§Ù‡ÛŒ
    - **agriculture**: SWIR-NIR-Blue Ø¨Ø±Ø§ÛŒ Ú©Ø´Ø§ÙˆØ±Ø²ÛŒ
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    data = raster['data']
    
    if composite_type == "rgb":
        composite = processor.create_rgb_composite(
            data[red_band - 1],
            data[green_band - 1],
            data[blue_band - 1]
        )
    elif composite_type == "false_color":
        composite = processor.create_false_color(
            data[nir_band - 1],
            data[red_band - 1],
            data[green_band - 1]
        )
    else:  # agriculture
        composite = processor.create_rgb_composite(
            data[10],  # SWIR
            data[nir_band - 1],
            data[blue_band - 1]
        )
    
    img = Image.fromarray(composite)
    
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    buffer.seek(0)
    
    return StreamingResponse(buffer, media_type="image/png")


@router.post("/clip")
async def clip_raster(
    file: UploadFile = File(...),
    min_lon: float = Query(...),
    min_lat: float = Query(...),
    max_lon: float = Query(...),
    max_lat: float = Query(...)
):
    """
    âœ‚ï¸ Ø¨Ø±Ø´ ØªØµÙˆÛŒØ± Ø¨Ø§ Ù…Ø³ØªØ·ÛŒÙ„
    """
    from shapely.geometry import box
    
    contents = await file.read()
    processor = get_satellite_processor()
    
    bbox = box(min_lon, min_lat, max_lon, max_lat)
    
    clipped = processor.clip_to_geometry(contents, bbox.__geo_interface__)
    
    return Response(
        content=clipped,
        media_type="image/tiff",
        headers={"Content-Disposition": "attachment; filename=clipped.tif"}
    )


@router.post("/reproject")
async def reproject_raster(
    file: UploadFile = File(...),
    target_crs: str = Query(default="EPSG:4326")
):
    """
    ğŸ”„ ØªØ¨Ø¯ÛŒÙ„ Ø³ÛŒØ³ØªÙ… Ù…Ø®ØªØµØ§Øª
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    reprojected = processor.reproject_raster(contents, target_crs)
    
    return Response(
        content=reprojected,
        media_type="image/tiff",
        headers={"Content-Disposition": f"attachment; filename=reprojected_{target_crs.replace(':', '_')}.tif"}
    )


@router.post("/cloud-mask")
async def detect_clouds(
    file: UploadFile = File(...),
    blue_band: int = Query(default=2, ge=1),
    threshold: float = Query(default=0.3, ge=0, le=1)
):
    """
    â˜ï¸ ØªØ´Ø®ÛŒØµ Ø§Ø¨Ø±
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    blue = raster['data'][blue_band - 1]
    
    cloud_mask = processor.detect_clouds(blue, threshold)
    
    # Calculate cloud coverage
    total_pixels = cloud_mask.size
    cloud_pixels = np.sum(cloud_mask)
    cloud_percentage = (cloud_pixels / total_pixels) * 100
    
    # Create visualization
    mask_colored = np.zeros((*cloud_mask.shape, 3), dtype=np.uint8)
    mask_colored[cloud_mask == 1] = [255, 255, 255]  # White for clouds
    
    img = Image.fromarray(mask_colored)
    
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="image/png",
        headers={
            "X-Cloud-Percentage": str(round(cloud_percentage, 2)),
            "X-Cloud-Pixels": str(cloud_pixels)
        }
    )</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 6: PRACTICAL PROJECTS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="projects">
            <div class="section-header">
                <div class="section-icon">ğŸ“¦</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û¶</div>
                    <h2 class="section-title">Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ</h2>
                    <p class="section-subtitle">Ú©Ø§Ø±Ø¨Ø±Ø¯Ù‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ GeoAI</p>
                </div>
            </div>

            <h3>Ù¾Ø±ÙˆÚ˜Ù‡ Û±: Ø³ÛŒØ³ØªÙ… ØªØ´Ø®ÛŒØµ Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ ØºÛŒØ±Ù…Ø¬Ø§Ø²</h3>

            <div class="info-box info">
                <div class="info-box-title">
                    <span>ğŸ—ï¸</span>
                    Ø´Ø±Ø­ Ù¾Ø±ÙˆÚ˜Ù‡
                </div>
                <div class="info-box-content">
                    <p>
                        Ø³ÛŒØ³ØªÙ…ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ø®ÙˆØ¯Ú©Ø§Ø± Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…Ù‚Ø§ÛŒØ³Ù‡ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ
                        Ùˆ Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ù¾Ø±ÙˆØ§Ù†Ù‡ Ø³Ø§Ø®Øª Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ø´Ù‡Ø±Ø¯Ø§Ø±ÛŒ.
                    </p>
                </div>
            </div>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">projects/illegal_building_detector.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import APIRouter, UploadFile, File, Depends, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from typing import List, Dict, Any
import numpy as np
from PIL import Image
from shapely.geometry import shape, mapping
from datetime import datetime

from app.api.deps import get_db
from app.ml.object_detection import get_detector
from app.services.geo_service import GeoService
from app.models.geo import Building, AIDetection

router = APIRouter(prefix="/projects/illegal-buildings", tags=["Projects"])


class IllegalBuildingDetector:
    """
    Detect potentially illegal buildings by:
    1. Detecting buildings in satellite imagery
    2. Comparing with registered buildings in database
    3. Flagging new/unregistered buildings
    """
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.detector = get_detector()
        self.geo_service = GeoService()
    
    async def detect_new_buildings(
        self,
        image: Image.Image,
        geo_transform: tuple,
        area_of_interest: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Detect buildings and compare with registered ones
        """
        # Step 1: Detect buildings in image
        detections = self.detector.detect_with_geo_coords(
            image, geo_transform, confidence_threshold=0.7
        )
        
        building_detections = [
            d for d in detections if d['class_name'] == 'building'
        ]
        
        # Step 2: Query registered buildings in area
        aoi_geom = shape(area_of_interest)
        
        query = select(Building).where(
            func.ST_Intersects(
                Building.geometry,
                func.ST_GeomFromText(aoi_geom.wkt, 4326)
            )
        )
        
        result = await self.db.execute(query)
        registered_buildings = result.scalars().all()
        
        # Create registered building geometries
        registered_geoms = []
        for b in registered_buildings:
            from geoalchemy2.shape import to_shape
            registered_geoms.append(to_shape(b.geometry))
        
        # Step 3: Find unregistered buildings
        unregistered = []
        
        for detection in building_detections:
            det_geom = shape(detection['geometry'])
            
            # Check if overlaps with any registered building
            is_registered = False
            for reg_geom in registered_geoms:
                if det_geom.intersects(reg_geom):
                    overlap = det_geom.intersection(reg_geom).area / det_geom.area
                    if overlap > 0.5:  # 50% overlap threshold
                        is_registered = True
                        break
            
            if not is_registered:
                detection['status'] = 'potentially_illegal'
                detection['detected_at'] = datetime.utcnow().isoformat()
                unregistered.append(detection)
        
        return unregistered
    
    async def generate_report(
        self,
        detections: List[Dict[str, Any]],
        area_name: str
    ) -> Dict[str, Any]:
        """Generate detection report"""
        
        total_area = sum(
            shape(d['geometry']).area for d in detections
        )
        
        return {
            "report_date": datetime.utcnow().isoformat(),
            "area_name": area_name,
            "total_detections": len(detections),
            "total_area_sq_degrees": total_area,
            "detections": detections,
            "recommendations": [
                "Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒØ¯Ø§Ù†ÛŒ Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡",
                "Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù¾Ø±ÙˆØ§Ù†Ù‡ Ø³Ø§Ø®Øª Ø§Ø² Ø´Ù‡Ø±Ø¯Ø§Ø±ÛŒ",
                "Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ ØªØµØ§ÙˆÛŒØ± Ù‚Ø¨Ù„ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ¹ÛŒÛŒÙ† ØªØ§Ø±ÛŒØ® Ø³Ø§Ø®Øª"
            ]
        }


@router.post("/detect")
async def detect_illegal_buildings(
    image: UploadFile = File(...),
    min_lon: float = 51.0,
    min_lat: float = 35.0,
    max_lon: float = 52.0,
    max_lat: float = 36.0,
    background_tasks: BackgroundTasks = None,
    db: AsyncSession = Depends(get_db)
):
    """
    ğŸ—ï¸ ØªØ´Ø®ÛŒØµ Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø§Ø­ØªÙ…Ø§Ù„Ø§Ù‹ ØºÛŒØ±Ù…Ø¬Ø§Ø²
    """
    import rasterio
    from rasterio.io import MemoryFile
    
    contents = await image.read()
    
    # Read GeoTIFF
    with MemoryFile(contents) as memfile:
        with memfile.open() as src:
            rgb = np.dstack([src.read(i) for i in [1, 2, 3]])
            if rgb.max() > 255:
                rgb = (rgb / rgb.max() * 255).astype(np.uint8)
            
            img = Image.fromarray(rgb)
            geo_transform = src.transform.to_gdal()
    
    # Area of interest
    from shapely.geometry import box
    aoi = box(min_lon, min_lat, max_lon, max_lat)
    
    # Detect
    detector = IllegalBuildingDetector(db)
    unregistered = await detector.detect_new_buildings(
        img, geo_transform, aoi.__geo_interface__
    )
    
    # Generate report
    report = await detector.generate_report(unregistered, "Ù…Ù†Ø·Ù‚Ù‡ Ù…ÙˆØ±Ø¯ Ø¨Ø±Ø±Ø³ÛŒ")
    
    # Save detections to database in background
    if background_tasks and unregistered:
        background_tasks.add_task(
            save_detections_to_db, db, unregistered
        )
    
    return report


async def save_detections_to_db(db: AsyncSession, detections: List[Dict]):
    """Save detections to database"""
    for det in detections:
        ai_detection = AIDetection(
            source_image="satellite_image",
            model_name="building_detector",
            model_version="1.0",
            detection_class="illegal_building",
            confidence=det['confidence'],
            metadata=det
        )
        db.add(ai_detection)
    await db.commit()</code></pre>
                </div>
            </div>

            <h3>Ù¾Ø±ÙˆÚ˜Ù‡ Û²: Ø³ÛŒØ³ØªÙ… Ù…Ø³ÛŒØ±ÛŒØ§Ø¨ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">projects/smart_routing.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import APIRouter, Depends, Query, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field
import heapq
from datetime import datetime
import httpx

from app.api.deps import get_db
from app.schemas.geo import GeoJSONPoint

router = APIRouter(prefix="/projects/routing", tags=["Projects"])


class RouteRequest(BaseModel):
    """Route request model"""
    origin: GeoJSONPoint
    destination: GeoJSONPoint
    waypoints: Optional[List[GeoJSONPoint]] = None
    avoid: Optional[List[str]] = Field(
        default=None,
        description="Features to avoid: traffic, tolls, highways"
    )
    optimize: str = Field(
        default="time",
        description="Optimize for: time, distance, eco"
    )


class RouteStep(BaseModel):
    """Single step in route"""
    instruction: str
    distance_m: float
    duration_s: float
    geometry: Dict[str, Any]


class RouteResponse(BaseModel):
    """Route response model"""
    origin: Dict[str, float]
    destination: Dict[str, float]
    total_distance_km: float
    total_duration_min: float
    steps: List[RouteStep]
    geometry: Dict[str, Any]
    alternatives: Optional[List[Dict]] = None


class SmartRouter:
    """
    AI-enhanced routing service
    Features:
    - Real-time traffic integration
    - ML-based travel time prediction
    - Multi-modal routing
    """
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def find_route(
        self,
        origin: tuple,
        destination: tuple,
        optimize: str = "time"
    ) -> Dict[str, Any]:
        """
        Find optimal route using pgRouting
        """
        # Find nearest nodes
        origin_node = await self._find_nearest_node(origin)
        dest_node = await self._find_nearest_node(destination)
        
        # Cost column based on optimization
        cost_column = {
            "time": "cost_time",
            "distance": "cost_length",
            "eco": "cost_eco"
        }.get(optimize, "cost_time")
        
        # Run Dijkstra
        query = text(f"""
            SELECT 
                seq, node, edge, cost, agg_cost,
                ST_AsGeoJSON(geom) as geometry,
                name, road_type
            FROM pgr_dijkstra(
                'SELECT id, source, target, {cost_column} as cost FROM roads',
                :origin_node,
                :dest_node,
                directed := true
            ) AS route
            JOIN roads ON route.edge = roads.id
        """)
        
        result = await self.db.execute(
            query,
            {"origin_node": origin_node, "dest_node": dest_node}
        )
        rows = result.fetchall()
        
        if not rows:
            raise HTTPException(status_code=404, detail="No route found")
        
        # Build route
        steps = []
        total_distance = 0
        total_duration = 0
        geometries = []
        
        for row in rows:
            import json
            geom = json.loads(row.geometry)
            geometries.append(geom)
            
            step = RouteStep(
                instruction=self._generate_instruction(row.name, row.road_type),
                distance_m=row.cost * 1000 if optimize == "distance" else 0,
                duration_s=row.cost * 60 if optimize == "time" else 0,
                geometry=geom
            )
            steps.append(step)
            total_distance += row.cost
            total_duration += row.cost
        
        # Merge geometries
        from shapely.geometry import shape, LineString
        from shapely.ops import linemerge
        
        lines = [shape(g) for g in geometries if g['type'] == 'LineString']
        merged = linemerge(lines)
        
        return {
            "origin": {"lon": origin[0], "lat": origin[1]},
            "destination": {"lon": destination[0], "lat": destination[1]},
            "total_distance_km": round(total_distance, 2),
            "total_duration_min": round(total_duration, 1),
            "steps": steps,
            "geometry": merged.__geo_interface__
        }
    
    async def _find_nearest_node(self, point: tuple) -> int:
        """Find nearest network node to point"""
        query = text("""
            SELECT id FROM roads_vertices_pgr
            ORDER BY the_geom <-> ST_SetSRID(ST_MakePoint(:lon, :lat), 4326)
            LIMIT 1
        """)
        
        result = await self.db.execute(
            query, {"lon": point[0], "lat": point[1]}
        )
        row = result.fetchone()
        
        if not row:
            raise HTTPException(status_code=404, detail="No network node found")
        
        return row.id
    
    def _generate_instruction(self, name: str, road_type: str) -> str:
        """Generate turn-by-turn instruction"""
        if not name:
            return f"Ø§Ø¯Ø§Ù…Ù‡ Ù…Ø³ÛŒØ± Ø¯Ø± {road_type}"
        return f"Ø­Ø±Ú©Øª Ø¯Ø± {name}"
    
    async def get_traffic_data(self, bbox: tuple) -> Dict[str, Any]:
        """Get real-time traffic data"""
        # This would integrate with traffic API
        # For demo, return mock data
        return {
            "timestamp": datetime.utcnow().isoformat(),
            "congestion_level": "moderate",
            "incidents": []
        }
    
    async def predict_travel_time(
        self,
        origin: tuple,
        destination: tuple,
        departure_time: datetime
    ) -> Dict[str, Any]:
        """
        ML-based travel time prediction
        Considers: historical patterns, weather, events
        """
        # Get base route
        route = await self.find_route(origin, destination)
        
        # Apply time-of-day factor
        hour = departure_time.hour
        
        # Rush hour factors
        if 7 <= hour <= 9 or 17 <= hour <= 19:
            time_factor = 1.5  # 50% longer during rush hour
        elif 22 <= hour or hour <= 5:
            time_factor = 0.8  # 20% faster at night
        else:
            time_factor = 1.0
        
        predicted_duration = route['total_duration_min'] * time_factor
        
        return {
            "base_duration_min": route['total_duration_min'],
            "predicted_duration_min": round(predicted_duration, 1),
            "time_factor": time_factor,
            "confidence": 0.85,
            "factors": {
                "time_of_day": "rush_hour" if time_factor > 1 else "normal",
                "weather": "clear",
                "events": []
            }
        }


@router.post("/find", response_model=RouteResponse)
async def find_route(
    request: RouteRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    ğŸ—ºï¸ ÛŒØ§ÙØªÙ† Ù…Ø³ÛŒØ± Ø¨Ù‡ÛŒÙ†Ù‡
    """
    router_service = SmartRouter(db)
    
    origin = (
        request.origin.coordinates[0],
        request.origin.coordinates[1]
    )
    destination = (
        request.destination.coordinates[0],
        request.destination.coordinates[1]
    )
    
    route = await router_service.find_route(
        origin, destination, request.optimize
    )
    
    return route


@router.post("/predict-time")
async def predict_travel_time(
    origin: GeoJSONPoint,
    destination: GeoJSONPoint,
    departure_time: Optional[datetime] = None,
    db: AsyncSession = Depends(get_db)
):
    """
    â±ï¸ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø²Ù…Ø§Ù† Ø³ÙØ± Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ
    """
    router_service = SmartRouter(db)
    
    if not departure_time:
        departure_time = datetime.utcnow()
    
    prediction = await router_service.predict_travel_time(
        (origin.coordinates[0], origin.coordinates[1]),
        (destination.coordinates[0], destination.coordinates[1]),
        departure_time
    )
    
    return prediction


@router.get("/traffic")
async def get_traffic(
    min_lon: float = Query(...),
    min_lat: float = Query(...),
    max_lon: float = Query(...),
    max_lat: float = Query(...),
    db: AsyncSession = Depends(get_db)
):
    """
    ğŸš¦ Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª ØªØ±Ø§ÙÛŒÚ©
    """
    router_service = SmartRouter(db)
    
    traffic = await router_service.get_traffic_data(
        (min_lon, min_lat, max_lon, max_lat)
    )
    
    return traffic</code></pre>
                </div>
            </div>

            <h3>Ù¾Ø±ÙˆÚ˜Ù‡ Û³: Ø³ÛŒØ³ØªÙ… Ù¾Ø§ÛŒØ´ Ù…Ø­ÛŒØ· Ø²ÛŒØ³Øª</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">projects/environmental_monitoring.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import APIRouter, UploadFile, File, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import numpy as np
from PIL import Image

from app.api.deps import get_db
from app.services.satellite import get_satellite_processor
from app.ml.segmentation import get_segmentation

router = APIRouter(prefix="/projects/environment", tags=["Projects"])


class EnvironmentalMonitor:
    """
    Environmental monitoring system using satellite imagery
    
    Features:
    - Vegetation health monitoring (NDVI trends)
    - Water body detection and change
    - Urban sprawl detection
    - Deforestation alerts
    """
    
    def __init__(self):
        self.satellite = get_satellite_processor()
        self.segmentation = get_segmentation()
    
    def analyze_vegetation_health(
        self,
        ndvi_current: np.ndarray,
        ndvi_previous: Optional[np.ndarray] = None
    ) -> Dict[str, Any]:
        """Analyze vegetation health and changes"""
        
        # Current statistics
        current_stats = {
            "mean_ndvi": float(np.mean(ndvi_current)),
            "healthy_vegetation_percent": float(
                np.sum(ndvi_current > 0.4) / ndvi_current.size * 100
            ),
            "stressed_vegetation_percent": float(
                np.sum((ndvi_current > 0.2) & (ndvi_current <= 0.4)) / ndvi_current.size * 100
            ),
            "bare_soil_percent": float(
                np.sum(ndvi_current <= 0.2) / ndvi_current.size * 100
            )
        }
        
        # Change analysis if previous data available
        if ndvi_previous is not None:
            change = ndvi_current - ndvi_previous
            current_stats["change_analysis"] = {
                "mean_change": float(np.mean(change)),
                "improvement_percent": float(
                    np.sum(change > 0.1) / change.size * 100
                ),
                "degradation_percent": float(
                    np.sum(change < -0.1) / change.size * 100
                ),
                "stable_percent": float(
                    np.sum(np.abs(change) <= 0.1) / change.size * 100
                )
            }
            
            # Generate alerts
            if current_stats["change_analysis"]["degradation_percent"] > 10:
                current_stats["alert"] = {
                    "level": "warning",
                    "message": "Ú©Ø§Ù‡Ø´ Ù‚Ø§Ø¨Ù„ ØªÙˆØ¬Ù‡ Ù¾ÙˆØ´Ø´ Ú¯ÛŒØ§Ù‡ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯",
                    "recommendation": "Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ù„Ù„ ØªØ®Ø±ÛŒØ¨ Ùˆ Ø§Ù‚Ø¯Ø§Ù… Ø§ØµÙ„Ø§Ø­ÛŒ"
                }
        
        return current_stats
    
    def detect_water_changes(
        self,
        ndwi_current: np.ndarray,
        ndwi_previous: Optional[np.ndarray] = None,
        threshold: float = 0.3
    ) -> Dict[str, Any]:
        """Detect water body changes"""
        
        water_mask_current = ndwi_current > threshold
        water_percent_current = np.sum(water_mask_current) / water_mask_current.size * 100
        
        result = {
            "water_coverage_percent": float(water_percent_current),
            "water_pixels": int(np.sum(water_mask_current)),
            "total_pixels": int(water_mask_current.size)
        }
        
        if ndwi_previous is not None:
            water_mask_previous = ndwi_previous > threshold
            water_percent_previous = np.sum(water_mask_previous) / water_mask_previous.size * 100
            
            change = water_percent_current - water_percent_previous
            
            result["change_analysis"] = {
                "previous_coverage_percent": float(water_percent_previous),
                "change_percent": float(change),
                "trend": "increasing" if change > 1 else "decreasing" if change < -1 else "stable"
            }
            
            # Drought alert
            if change < -5:
                result["alert"] = {
                    "level": "critical",
                    "message": "Ú©Ø§Ù‡Ø´ Ø´Ø¯ÛŒØ¯ Ù…Ù†Ø§Ø¨Ø¹ Ø¢Ø¨ÛŒ",
                    "recommendation": "Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø®Ø´Ú©Ø³Ø§Ù„ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ù†Ø§Ø¨Ø¹ Ø¢Ø¨"
                }
        
        return result
    
    def detect_urban_expansion(
        self,
        segmentation_current: np.ndarray,
        segmentation_previous: Optional[np.ndarray] = None,
        building_class_id: int = 1
    ) -> Dict[str, Any]:
        """Detect urban expansion"""
        
        urban_mask_current = segmentation_current == building_class_id
        urban_percent_current = np.sum(urban_mask_current) / urban_mask_current.size * 100
        
        result = {
            "urban_coverage_percent": float(urban_percent_current),
            "timestamp": datetime.utcnow().isoformat()
        }
        
        if segmentation_previous is not None:
            urban_mask_previous = segmentation_previous == building_class_id
            urban_percent_previous = np.sum(urban_mask_previous) / urban_mask_previous.size * 100
            
            # Find new urban areas
            new_urban = urban_mask_current & ~urban_mask_previous
            new_urban_percent = np.sum(new_urban) / new_urban.size * 100
            
            result["expansion_analysis"] = {
                "previous_coverage_percent": float(urban_percent_previous),
                "new_urban_percent": float(new_urban_percent),
                "growth_rate": float(
                    (urban_percent_current - urban_percent_previous) / urban_percent_previous * 100
                ) if urban_percent_previous > 0 else 0
            }
        
        return result
    
    def generate_environmental_report(
        self,
        vegetation_analysis: Dict,
        water_analysis: Dict,
        urban_analysis: Dict,
        area_name: str
    ) -> Dict[str, Any]:
        """Generate comprehensive environmental report"""
        
        # Calculate overall health score (0-100)
        health_score = 0
        
        # Vegetation contribution (40%)
        health_score += vegetation_analysis.get("healthy_vegetation_percent", 0) * 0.4
        
        # Water contribution (30%)
        water_score = min(water_analysis.get("water_coverage_percent", 0) * 3, 30)
        health_score += water_score
        
        # Urban balance contribution (30%)
        urban_percent = urban_analysis.get("urban_coverage_percent", 0)
        if urban_percent < 30:
            health_score += 30
        elif urban_percent < 50:
            health_score += 20
        else:
            health_score += 10
        
        # Collect all alerts
        alerts = []
        for analysis in [vegetation_analysis, water_analysis, urban_analysis]:
            if "alert" in analysis:
                alerts.append(analysis["alert"])
        
        return {
            "report_date": datetime.utcnow().isoformat(),
            "area_name": area_name,
            "overall_health_score": round(health_score, 1),
            "health_status": "Ø®ÙˆØ¨" if health_score >= 70 else "Ù…ØªÙˆØ³Ø·" if health_score >= 50 else "Ù†Ú¯Ø±Ø§Ù†â€ŒÚ©Ù†Ù†Ø¯Ù‡",
            "vegetation": vegetation_analysis,
            "water_resources": water_analysis,
            "urbanization": urban_analysis,
            "alerts": alerts,
            "recommendations": self._generate_recommendations(
                vegetation_analysis, water_analysis, urban_analysis
            )
        }
    
    def _generate_recommendations(
        self,
        vegetation: Dict,
        water: Dict,
        urban: Dict
    ) -> List[str]:
        """Generate actionable recommendations"""
        recommendations = []
        
        if vegetation.get("stressed_vegetation_percent", 0) > 20:
            recommendations.append("Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø¢Ø¨ÛŒØ§Ø±ÛŒ Ùˆ Ø³Ù„Ø§Ù…Øª Ø®Ø§Ú© Ø¯Ø± Ù…Ù†Ø§Ø·Ù‚ Ø¨Ø§ Ù¾ÙˆØ´Ø´ Ú¯ÛŒØ§Ù‡ÛŒ Ø¶Ø¹ÛŒÙ")
        
        if water.get("change_analysis", {}).get("trend") == "decreasing":
            recommendations.append("Ù¾Ø§ÛŒØ´ Ù…Ù†Ø§Ø¨Ø¹ Ø¢Ø¨ÛŒ Ùˆ Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ù‡ÛŒÙ†Ù‡ Ø¢Ø¨")
        
        if urban.get("expansion_analysis", {}).get("growth_rate", 0) > 5:
            recommendations.append("Ø¨Ø±Ø±Ø³ÛŒ ØªÙˆØ³Ø¹Ù‡ Ø´Ù‡Ø±ÛŒ Ùˆ ØªØ£Ø«ÛŒØ± Ø¢Ù† Ø¨Ø± Ø§Ú©ÙˆØ³ÛŒØ³ØªÙ… Ù…Ù†Ø·Ù‚Ù‡")
        
        if not recommendations:
            recommendations.append("Ø§Ø¯Ø§Ù…Ù‡ Ù¾Ø§ÛŒØ´ Ø¯ÙˆØ±Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ø­ÙØ¸ ÙˆØ¶Ø¹ÛŒØª Ù…Ø·Ù„ÙˆØ¨")
        
        return recommendations


@router.post("/analyze")
async def analyze_environment(
    current_image: UploadFile = File(..., description="ØªØµÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ ÙØ¹Ù„ÛŒ"),
    previous_image: Optional[UploadFile] = File(None, description="ØªØµÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ Ù‚Ø¨Ù„ÛŒ"),
    area_name: str = Query(default="Ù…Ù†Ø·Ù‚Ù‡ Ù…ÙˆØ±Ø¯ Ø¨Ø±Ø±Ø³ÛŒ"),
    db: AsyncSession = Depends(get_db)
):
    """
    ğŸŒ ØªØ­Ù„ÛŒÙ„ Ø¬Ø§Ù…Ø¹ Ù…Ø­ÛŒØ· Ø²ÛŒØ³Øª
    
    Ø´Ø§Ù…Ù„: Ù¾ÙˆØ´Ø´ Ú¯ÛŒØ§Ù‡ÛŒØŒ Ù…Ù†Ø§Ø¨Ø¹ Ø¢Ø¨ÛŒØŒ ØªÙˆØ³Ø¹Ù‡ Ø´Ù‡Ø±ÛŒ
    """
    import rasterio
    from rasterio.io import MemoryFile
    
    monitor = EnvironmentalMonitor()
    
    # Read current image
    current_contents = await current_image.read()
    
    with MemoryFile(current_contents) as memfile:
        with memfile.open() as src:
            current_data = src.read()
    
    # Calculate indices for current image
    red = current_data[3]  # Band 4
    nir = current_data[7]  # Band 8
    green = current_data[2]  # Band 3
    
    ndvi_current = monitor.satellite.calculate_ndvi(red, nir)
    ndwi_current = monitor.satellite.calculate_ndwi(green, nir)
    
    # Segmentation
    rgb = np.dstack([current_data[3], current_data[2], current_data[1]])
    if rgb.max() > 255:
        rgb = (rgb / rgb.max() * 255).astype(np.uint8)
    
    segmentation_current = monitor.segmentation.segment(Image.fromarray(rgb))
    
    # Process previous image if provided
    ndvi_previous = None
    ndwi_previous = None
    segmentation_previous = None
    
    if previous_image:
        previous_contents = await previous_image.read()
        
        with MemoryFile(previous_contents) as memfile:
            with memfile.open() as src:
                previous_data = src.read()
        
        red_prev = previous_data[3]
        nir_prev = previous_data[7]
        green_prev = previous_data[2]
        
        ndvi_previous = monitor.satellite.calculate_ndvi(red_prev, nir_prev)
        ndwi_previous = monitor.satellite.calculate_ndwi(green_prev, nir_prev)
        
        rgb_prev = np.dstack([previous_data[3], previous_data[2], previous_data[1]])
        if rgb_prev.max() > 255:
            rgb_prev = (rgb_prev / rgb_prev.max() * 255).astype(np.uint8)
        
        segmentation_previous = monitor.segmentation.segment(Image.fromarray(rgb_prev))
    
    # Analyze
    vegetation_analysis = monitor.analyze_vegetation_health(ndvi_current, ndvi_previous)
    water_analysis = monitor.detect_water_changes(ndwi_current, ndwi_previous)
    urban_analysis = monitor.detect_urban_expansion(
        segmentation_current, segmentation_previous
    )
    
    # Generate report
    report = monitor.generate_environmental_report(
        vegetation_analysis,
        water_analysis,
        urban_analysis,
        area_name
    )
    
    return report


@router.post("/deforestation-alert")
async def check_deforestation(
    current_image: UploadFile = File(...),
    baseline_image: UploadFile = File(...),
    threshold_percent: float = Query(default=5.0, ge=1.0, le=50.0)
):
    """
    ğŸŒ² ØªØ´Ø®ÛŒØµ Ø¬Ù†Ú¯Ù„â€ŒØ²Ø¯Ø§ÛŒÛŒ
    
    Ù…Ù‚Ø§ÛŒØ³Ù‡ ØªØµØ§ÙˆÛŒØ± Ùˆ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù…Ù†Ø§Ø·Ù‚ Ø¨Ø§ Ú©Ø§Ù‡Ø´ Ù¾ÙˆØ´Ø´ Ø¬Ù†Ú¯Ù„ÛŒ
    """
    import rasterio
    from rasterio.io import MemoryFile
    
    processor = get_satellite_processor()
    
    # Read images
    current_contents = await current_image.read()
    baseline_contents = await baseline_image.read()
    
    with MemoryFile(current_contents) as memfile:
        with memfile.open() as src:
            current_data = src.read()
            geo_transform = src.transform.to_gdal()
    
    with MemoryFile(baseline_contents) as memfile:
        with memfile.open() as src:
            baseline_data = src.read()
    
    # Calculate NDVI
    ndvi_current = processor.calculate_ndvi(current_data[3], current_data[7])
    ndvi_baseline = processor.calculate_ndvi(baseline_data[3], baseline_data[7])
    
    # Forest mask (NDVI > 0.5 typically indicates forest)
    forest_threshold = 0.5
    forest_current = ndvi_current > forest_threshold
    forest_baseline = ndvi_baseline > forest_threshold
    
    # Deforestation = was forest, now not forest
    deforestation_mask = forest_baseline & ~forest_current
    
    # Calculate statistics
    total_baseline_forest = np.sum(forest_baseline)
    deforested_pixels = np.sum(deforestation_mask)
    deforestation_percent = (deforested_pixels / total_baseline_forest * 100) if total_baseline_forest > 0 else 0
    
    # Generate alert if threshold exceeded
    alert_level = "normal"
    if deforestation_percent >= threshold_percent:
        alert_level = "critical"
    elif deforestation_percent >= threshold_percent / 2:
        alert_level = "warning"
    
    return {
        "analysis_date": datetime.utcnow().isoformat(),
        "baseline_forest_pixels": int(total_baseline_forest),
        "current_forest_pixels": int(np.sum(forest_current)),
        "deforested_pixels": int(deforested_pixels),
        "deforestation_percent": round(deforestation_percent, 2),
        "alert": {
            "level": alert_level,
            "threshold_percent": threshold_percent,
            "exceeded": deforestation_percent >= threshold_percent
        },
        "recommendations": [
            "Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒØ¯Ø§Ù†ÛŒ Ù…Ù†Ø§Ø·Ù‚ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡",
            "ØªØ­Ù„ÛŒÙ„ Ø¹Ù„Ù„ Ø¬Ù†Ú¯Ù„â€ŒØ²Ø¯Ø§ÛŒÛŒ",
            "Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø­ÛŒØ§ÛŒ Ù¾ÙˆØ´Ø´ Ø¬Ù†Ú¯Ù„ÛŒ"
        ] if alert_level != "normal" else ["Ø§Ø¯Ø§Ù…Ù‡ Ù¾Ø§ÛŒØ´ Ø¯ÙˆØ±Ù‡â€ŒØ§ÛŒ"]
    }</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 7: DEPLOYMENT
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="deployment">
            <div class="section-header">
                <div class="section-icon">ğŸš€</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û·</div>
                    <h2 class="section-title">Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ùˆ Production</h2>
                    <p class="section-subtitle">Docker, Kubernetes, Monitoring</p>
                </div>
            </div>

            <h3>Dockerfile Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ´Ø¯Ù‡</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon json">ğŸ³</div>
                        <span class="code-filename">docker/Dockerfile</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-dockerfile"># â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Stage 1: Builder
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FROM python:3.11-slim as builder

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libgdal-dev \
    libgeos-dev \
    libproj-dev \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip wheel --no-cache-dir --no-deps --wheel-dir /app/wheels -r requirements.txt


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Stage 2: Runtime
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FROM python:3.11-slim as runtime

WORKDIR /app

# Install runtime dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    libgdal32 \
    libgeos-c1v5 \
    libproj25 \
    libgl1-mesa-glx \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# Copy wheels and install
COPY --from=builder /app/wheels /wheels
RUN pip install --no-cache /wheels/*

# Copy application
COPY app/ ./app/
COPY ml_models/ ./ml_models/

# Create non-root user
RUN useradd -m -u 1000 appuser && \
    chown -R appuser:appuser /app
USER appuser

# Environment
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PORT=8000

EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import httpx; httpx.get('http://localhost:8000/health')" || exit 1

# Run
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]</code></pre>
                </div>
            </div>

            <h3>Kubernetes Deployment</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon json">â˜¸ï¸</div>
                        <span class="code-filename">k8s/deployment.yaml</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: geoai-api
  labels:
    app: geoai-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: geoai-api
  template:
    metadata:
      labels:
        app: geoai-api
    spec:
      containers:
      - name: geoai-api
        image: geoai-fastapi:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: geoai-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: geoai-secrets
              key: redis-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
            nvidia.com/gpu: 1  # GPU for AI inference
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: ml-models
          mountPath: /app/ml_models
          readOnly: true
      volumes:
      - name: ml-models
        persistentVolumeClaim:
          claimName: ml-models-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: geoai-api-service
spec:
  selector:
    app: geoai-api
  ports:
  - port: 80
    targetPort: 8000
  type: LoadBalancer
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: geoai-api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: geoai-api
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80</code></pre>
                </div>
            </div>

            <h3>Celery Worker Ø¨Ø±Ø§ÛŒ ØªØ³Ú©â€ŒÙ‡Ø§ÛŒ Ø³Ù†Ú¯ÛŒÙ†</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/worker.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from celery import Celery
from celery.signals import worker_ready
import logging

from app.config import settings

logger = logging.getLogger(__name__)

# Create Celery app
celery_app = Celery(
    "geoai_worker",
    broker=settings.REDIS_URL,
    backend=settings.REDIS_URL
)

# Configuration
celery_app.conf.update(
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="UTC",
    enable_utc=True,
    task_track_started=True,
    task_time_limit=3600,  # 1 hour max
    worker_prefetch_multiplier=1,  # For GPU tasks
    task_routes={
        "app.worker.process_satellite_image": {"queue": "gpu"},
        "app.worker.run_object_detection": {"queue": "gpu"},
        "app.worker.run_segmentation": {"queue": "gpu"},
        "app.worker.spatial_analysis": {"queue": "cpu"},
    }
)


@worker_ready.connect
def load_models(**kwargs):
    """Load ML models when worker starts"""
    logger.info("Loading ML models...")
    from app.ml.object_detection import get_detector
    from app.ml.segmentation import get_segmentation
    
    get_detector()
    get_segmentation()
    logger.info("ML models loaded!")


@celery_app.task(bind=True, max_retries=3)
def process_satellite_image(self, image_path: str, operations: list):
    """
    Process satellite image with multiple operations
    """
    try:
        from app.services.satellite import get_satellite_processor
        import rasterio
        
        processor = get_satellite_processor()
        results = {}
        
        with rasterio.open(image_path) as src:
            data = src.read()
            
            for op in operations:
                if op == "ndvi":
                    ndvi = processor.calculate_ndvi(data[3], data[7])
                    results["ndvi"] = processor.get_statistics(ndvi)
                
                elif op == "ndwi":
                    ndwi = processor.calculate_ndwi(data[2], data[7])
                    results["ndwi"] = processor.get_statistics(ndwi)
                
                elif op == "classification":
                    ndvi = processor.calculate_ndvi(data[3], data[7])
                    _, counts = processor.classify_ndvi(ndvi)
                    results["classification"] = counts
        
        return {"status": "success", "results": results}
        
    except Exception as e:
        logger.error(f"Error processing image: {e}")
        self.retry(exc=e, countdown=60)


@celery_app.task(bind=True, max_retries=3)
def run_object_detection(self, image_path: str, confidence: float = 0.5):
    """
    Run object detection on image
    """
    try:
        from app.ml.object_detection import get_detector
        from PIL import Image
        
        detector = get_detector()
        image = Image.open(image_path)
        
        detections = detector.detect(image, confidence_threshold=confidence)
        
        return {
            "status": "success",
            "detections": detections,
            "count": len(detections)
        }
        
    except Exception as e:
        logger.error(f"Error in detection: {e}")
        self.retry(exc=e, countdown=60)


@celery_app.task(bind=True)
def run_segmentation(self, image_path: str):
    """
    Run semantic segmentation on image
    """
    try:
        from app.ml.segmentation import get_segmentation
        from PIL import Image
        import numpy as np
        
        segmentation = get_segmentation()
        image = Image.open(image_path)
        
        mask = segmentation.segment(image)
        stats = segmentation.get_statistics(mask)
        
        return {
            "status": "success",
            "statistics": stats
        }
        
    except Exception as e:
        logger.error(f"Error in segmentation: {e}")
        raise


@celery_app.task
def spatial_analysis(layer_name: str, operation: str, params: dict):
    """
    Run spatial analysis on database layer
    """
    import asyncio
    from app.db.session import async_session
    from app.services.geo_service import GeoService
    
    async def run_analysis():
        async with async_session() as db:
            geo_service = GeoService(db)
            
            if operation == "buffer":
                result = geo_service.buffer(
                    params["geometry"],
                    params["distance"]
                )
            elif operation == "intersection":
                result = geo_service.intersection(
                    params["geometry1"],
                    params["geometry2"]
                )
            else:
                raise ValueError(f"Unknown operation: {operation}")
            
            return result
    
    return asyncio.run(run_analysis())


@celery_app.task
def generate_report(report_type: str, params: dict):
    """
    Generate various reports
    """
    from datetime import datetime
    import json
    
    report = {
        "type": report_type,
        "generated_at": datetime.utcnow().isoformat(),
        "params": params
    }
    
    if report_type == "environmental":
        # Generate environmental report
        report["content"] = {
            "summary": "Environmental analysis report",
            "data": params
        }
    
    elif report_type == "urban":
        # Generate urban analysis report
        report["content"] = {
            "summary": "Urban development report",
            "data": params
        }
    
    # Save report
    report_path = f"/tmp/reports/{report_type}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
    
    import os
    os.makedirs(os.path.dirname(report_path), exist_ok=True)
    
    with open(report_path, 'w') as f:
        json.dump(report, f, indent=2)
    
    return {"status": "success", "report_path": report_path}</code></pre>
                </div>
            </div>

            <h3>Monitoring Ø¨Ø§ Prometheus</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/core/monitoring.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from prometheus_client import Counter, Histogram, Gauge, generate_latest
from fastapi import APIRouter, Response
from functools import wraps
import time

router = APIRouter(tags=["Monitoring"])

# Metrics
REQUEST_COUNT = Counter(
    'geoai_requests_total',
    'Total request count',
    ['method', 'endpoint', 'status']
)

REQUEST_LATENCY = Histogram(
    'geoai_request_latency_seconds',
    'Request latency in seconds',
    ['method', 'endpoint'],
    buckets=[0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 30.0]
)

ACTIVE_REQUESTS = Gauge(
    'geoai_active_requests',
    'Number of active requests'
)

ML_INFERENCE_TIME = Histogram(
    'geoai_ml_inference_seconds',
    'ML model inference time',
    ['model_name'],
    buckets=[0.1, 0.5, 1.0, 2.0, 5.0, 10.0]
)

SPATIAL_OPERATION_TIME = Histogram(
    'geoai_spatial_operation_seconds',
    'Spatial operation time',
    ['operation'],
    buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 5.0]
)

GPU_MEMORY_USAGE = Gauge(
    'geoai_gpu_memory_bytes',
    'GPU memory usage in bytes'
)


def track_request(func):
    """Decorator to track request metrics"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        ACTIVE_REQUESTS.inc()
        start_time = time.time()
        
        try:
            response = await func(*args, **kwargs)
            status = "success"
            return response
        except Exception as e:
            status = "error"
            raise
        finally:
            ACTIVE_REQUESTS.dec()
            duration = time.time() - start_time
            
            REQUEST_COUNT.labels(
                method="POST",
                endpoint=func.__name__,
                status=status
            ).inc()
            
            REQUEST_LATENCY.labels(
                method="POST",
                endpoint=func.__name__
            ).observe(duration)
    
    return wrapper


def track_ml_inference(model_name: str):
    """Decorator to track ML inference time"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            duration = time.time() - start_time
            
            ML_INFERENCE_TIME.labels(model_name=model_name).observe(duration)
            
            return result
        return wrapper
    return decorator


def track_spatial_operation(operation: str):
    """Decorator to track spatial operation time"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            duration = time.time() - start_time
            
            SPATIAL_OPERATION_TIME.labels(operation=operation).observe(duration)
            
            return result
        return wrapper
    return decorator


def update_gpu_metrics():
    """Update GPU memory metrics"""
    try:
        import torch
        if torch.cuda.is_available():
            memory_allocated = torch.cuda.memory_allocated()
            GPU_MEMORY_USAGE.set(memory_allocated)
    except:
        pass


@router.get("/metrics")
async def metrics():
    """Prometheus metrics endpoint"""
    update_gpu_metrics()
    return Response(
        content=generate_latest(),
        media_type="text/plain"
    )</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 8: BEST PRACTICES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="best-practices">
            <div class="section-header">
                <div class="section-icon">âœ¨</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û¸</div>
                    <h2 class="section-title">Ø¨Ù‡ØªØ±ÛŒÙ† Ø´ÛŒÙˆÙ‡â€ŒÙ‡Ø§</h2>
                    <p class="section-subtitle">Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ Ùˆ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ø·Ø±Ø§Ø­ÛŒ</p>
                </div>
            </div>

            <div class="best-practices-grid">
                <div class="practice-card">
                    <div class="practice-icon">ğŸ”’</div>
                    <h4>Ø§Ù…Ù†ÛŒØª</h4>
                    <ul>
                        <li>Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² JWT Ø¨Ø±Ø§ÛŒ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª</li>
                        <li>Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§ÛŒ GeoJSON</li>
                        <li>Ù…Ø­Ø¯ÙˆØ¯Ø³Ø§Ø²ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¢Ù¾Ù„ÙˆØ¯</li>
                        <li>Rate Limiting Ø¨Ø±Ø§ÛŒ API</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <div class="practice-icon">âš¡</div>
                    <h4>Ø¹Ù…Ù„Ú©Ø±Ø¯</h4>
                    <ul>
                        <li>Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Spatial Index Ø¯Ø± PostGIS</li>
                        <li>Cache Ú©Ø±Ø¯Ù† Ù†ØªØ§ÛŒØ¬ Ø¨Ø§ Redis</li>
                        <li>Async/Await Ø¨Ø±Ø§ÛŒ I/O</li>
                        <li>Batch Processing Ø¨Ø±Ø§ÛŒ AI</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <div class="practice-icon">ğŸ“</div>
                    <h4>Ù…Ø¹Ù…Ø§Ø±ÛŒ</h4>
                    <ul>
                        <li>Ø¬Ø¯Ø§Ø³Ø§Ø²ÛŒ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§ (API, Service, Repository)</li>
                        <li>Dependency Injection</li>
                        <li>Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Pydantic Ø¨Ø±Ø§ÛŒ Validation</li>
                        <li>Error Handling ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <div class="practice-icon">ğŸ§ª</div>
                    <h4>ØªØ³Øª</h4>
                    <ul>
                        <li>Unit Test Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§</li>
                        <li>Integration Test Ø¨Ø±Ø§ÛŒ API</li>
                        <li>Test Fixtures Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ GeoJSON</li>
                        <li>Mock Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ø®Ø§Ø±Ø¬ÛŒ</li>
                    </ul>
                </div>
            </div>

            <h3>Ù†Ù…ÙˆÙ†Ù‡ ØªØ³Øª</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">tests/test_geo.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">import pytest
from httpx import AsyncClient
from app.main import app
from app.services.geo_service import GeoService


# Fixtures
@pytest.fixture
def sample_point():
    return {
        "type": "Point",
        "coordinates": [51.389, 35.689]
    }


@pytest.fixture
def sample_polygon():
    return {
        "type": "Polygon",
        "coordinates": [[[51.0, 35.0], [52.0, 35.0], [52.0, 36.0], [51.0, 36.0], [51.0, 35.0]]]
    }


# Unit Tests
class TestGeoService:
    
    def test_buffer_point(self, sample_point):
        """Test buffer operation on point"""
        result = GeoService.buffer(sample_point, 1000)
        
        assert result["type"] == "Polygon"
        assert len(result["coordinates"]) > 0
    
    def test_calculate_area(self, sample_polygon):
        """Test area calculation"""
        result = GeoService.calculate_area(sample_polygon)
        
        assert result.area_sq_meters > 0
        assert result.area_sq_kilometers > 0
        assert result.area_hectares > 0
    
    def test_calculate_distance(self):
        """Test distance calculation"""
        point1 = {"type": "Point", "coordinates": [51.389, 35.689]}
        point2 = {"type": "Point", "coordinates": [51.489, 35.789]}
        
        result = GeoService.calculate_distance(point1, point2)
        
        assert result.distance_meters > 0
        assert result.distance_kilometers == result.distance_meters / 1000
    
    def test_intersects(self, sample_polygon):
        """Test intersection check"""
        point_inside = {"type": "Point", "coordinates": [51.5, 35.5]}
        point_outside = {"type": "Point", "coordinates": [50.0, 34.0]}
        
        assert GeoService.intersects(sample_polygon, point_inside) == True
        assert GeoService.intersects(sample_polygon, point_outside) == False


# Integration Tests
@pytest.mark.asyncio
class TestGeoAPI:
    
    async def test_buffer_endpoint(self, sample_point):
        """Test buffer API endpoint"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post(
                "/api/v1/geo/buffer",
                json={
                    "geometry": sample_point,
                    "distance": 500,
                    "resolution": 16
                }
            )
        
        assert response.status_code == 200
        data = response.json()
        assert data["type"] == "Feature"
        assert data["geometry"]["type"] == "Polygon"
    
    async def test_area_endpoint(self, sample_polygon):
        """Test area calculation endpoint"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post(
                "/api/v1/geo/area",
                json=sample_polygon
            )
        
        assert response.status_code == 200
        data = response.json()
        assert "area_sq_meters" in data
    
    async def test_invalid_geometry(self):
        """Test error handling for invalid geometry"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post(
                "/api/v1/geo/area",
                json={"type": "Point", "coordinates": [51.0, 35.0]}
            )
        
        assert response.status_code == 400</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SUMMARY
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="summary">
            <div class="section-header">
                <div class="section-icon">ğŸ“‹</div>
                <div class="section-title-group">
                    <div class="section-number">Ø®Ù„Ø§ØµÙ‡</div>
                    <h2 class="section-title">Ø¬Ù…Ø¹â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ Ù…Ù†Ø§Ø¨Ø¹</h2>
                    <p class="section-subtitle">Ø¢Ù†Ú†Ù‡ Ø¢Ù…ÙˆØ®ØªÛŒÙ… Ùˆ Ú¯Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ø¨Ø¹Ø¯ÛŒ</p>
                </div>
            </div>

            <div class="summary-grid">
                <div class="summary-card">
                    <h4>ğŸ—ºï¸ GeoSpatial</h4>
                    <ul>
                        <li>PostGIS Ùˆ GeoAlchemy2</li>
                        <li>Shapely Ø¨Ø±Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù‡Ù†Ø¯Ø³ÛŒ</li>
                        <li>GeoJSON Ùˆ Pydantic</li>
                        <li>Spatial Queries</li>
                    </ul>
                </div>

                <div class="summary-card">
                    <h4>ğŸ¤– Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h4>
                    <ul>
                        <li>Object Detection (YOLO, Faster R-CNN)</li>
                        <li>Semantic Segmentation (DeepLab)</li>
                        <li>LLM Ø¨Ø±Ø§ÛŒ Ú©ÙˆØ¦Ø±ÛŒ Ø·Ø¨ÛŒØ¹ÛŒ</li>
                        <li>Change Detection</li>
                    </ul>
                </div>

                <div class="summary-card">
                    <h4>ğŸ›°ï¸ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h4>
                    <ul>
                        <li>Rasterio Ùˆ GeoTIFF</li>
                        <li>Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ NDVI, NDWI, NDBI</li>
                        <li>ØªØ±Ú©ÛŒØ¨â€ŒÙ‡Ø§ÛŒ Ø±Ù†Ú¯ÛŒ</li>
                        <li>Cloud Masking</li>
                    </ul>
                </div>

                <div class="summary-card">
                    <h4>ğŸš€ Production</h4>
                    <ul>
                        <li>Docker Ùˆ Kubernetes</li>
                        <li>Celery Ø¨Ø±Ø§ÛŒ ØªØ³Ú©â€ŒÙ‡Ø§ÛŒ Ø³Ù†Ú¯ÛŒÙ†</li>
                        <li>Monitoring Ø¨Ø§ Prometheus</li>
                        <li>Auto-scaling</li>
                    </ul>
                </div>
            </div>

            <h3>Ù…Ù†Ø§Ø¨Ø¹ Ù…ÙÛŒØ¯</h3>

            <div class="resources-list">
                <div class="resource-item">
                    <span class="resource-icon">ğŸ“š</span>
                    <div class="resource-content">
                        <a href="https://fastapi.tiangolo.com/" target="_blank">FastAPI Documentation</a>
                        <p>Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø±Ø³Ù…ÛŒ FastAPI</p>
                    </div>
                </div>

                <div class="resource-item">
                    <span class="resource-icon">ğŸ—ºï¸</span>
                    <div class="resource-content">
                        <a href="https://postgis.net/documentation/" target="_blank">PostGIS Documentation</a>
                        <p>Ù…Ø³ØªÙ†Ø¯Ø§Øª PostGIS</p>
                    </div>
                </div>

                <div class="resource-item">
                    <span class="resource-icon">ğŸ”·</span>
                    <div class="resource-content">
                        <a href="https://shapely.readthedocs.io/" target="_blank">Shapely Documentation</a>
                        <p>Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Ø¹Ù…Ù„ÛŒØ§Øª Ù‡Ù†Ø¯Ø³ÛŒ</p>
                    </div>
                </div>

                <div class="resource-item">
                    <span class="resource-icon">ğŸ›°ï¸</span>
                    <div class="resource-content">
                        <a href="https://rasterio.readthedocs.io/" target="_blank">Rasterio Documentation</a>
                        <p>Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø±Ø³ØªØ±ÛŒ</p>
                    </div>
                </div>

                <div class="resource-item">
                    <span class="resource-icon">ğŸ¤–</span>
                    <div class="resource-content">
                        <a href="https://pytorch.org/tutorials/" target="_blank">PyTorch Tutorials</a>
                        <p>Ø¢Ù…ÙˆØ²Ø´â€ŒÙ‡Ø§ÛŒ PyTorch</p>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         FOOTER
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>ğŸŒ GeoAI FastAPI Tutorial</h4>
                <p>Ø¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹ ØªÙˆØ³Ø¹Ù‡ API Ù‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</p>
            </div>
            <div class="footer-section">
                <h4>ØªÚ©Ù†ÙˆÙ„ÙˆÚ˜ÛŒâ€ŒÙ‡Ø§</h4>
                <div class="tech-tags">
                    <span class="tech-tag">FastAPI</span>
                    <span class="tech-tag">PostGIS</span>
                    <span class="tech-tag">PyTorch</span>
                    <span class="tech-tag">Shapely</span>
                    <span class="tech-tag">Rasterio</span>
                </div>
            </div>
            <div class="footer-section">
                <h4>Ù†Ø³Ø®Ù‡</h4>
                <p>v1.0.0 - Ø¯ÛŒ Û±Û´Û°Û´</p>
            </div>
        </div>
        <div class="footer-bottom">
            <p>Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡ Ø¨Ø§ â¤ï¸ Ø¨Ø±Ø§ÛŒ Ø¬Ø§Ù…Ø¹Ù‡ GIS Ø§ÛŒØ±Ø§Ù†</p>
        </div>
    </footer>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         SCRIPTS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/dockerfile.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>

    <script>
        // Initialize syntax highlighting
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });

        // Copy code function
        function copyCode(button) {
            const codeBlock = button.closest('.code-block');
            const code = codeBlock.querySelector('code').textContent;

            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.textContent;
                button.textContent = 'âœ… Ú©Ù¾ÛŒ Ø´Ø¯!';
                button.classList.add('copied');

                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                button.textContent = 'âŒ Ø®Ø·Ø§';
            });
        }

        // Smooth scroll for navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href');
                const targetElement = document.querySelector(targetId);

                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Active section highlighting
        const sections = document.querySelectorAll('.section');
        const navLinks = document.querySelectorAll('.nav-link');

        const observerOptions = {
            root: null,
            rootMargin: '-20% 0px -80% 0px',
            threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');

                    navLinks.forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === `#${id}`) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }, observerOptions);

        sections.forEach(section => {
            observer.observe(section);
        });

        // Progress bar
        const progressBar = document.createElement('div');
        progressBar.className = 'reading-progress';
        progressBar.innerHTML = '<div class="reading-progress-bar"></div>';
        document.body.appendChild(progressBar);

        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;

            document.querySelector('.reading-progress-bar').style.width = scrolled + '%';
        });

        // Theme toggle (optional)
        function toggleTheme() {
            document.body.classList.toggle('dark-theme');
            localStorage.setItem('theme', document.body.classList.contains('dark-theme') ? 'dark' : 'light');
        }

        // Load saved theme
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-theme');
        }

        // Back to top button
        const backToTop = document.createElement('button');
        backToTop.className = 'back-to-top';
        backToTop.innerHTML = 'â¬†ï¸';
        backToTop.title = 'Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø¨Ø§Ù„Ø§';
        document.body.appendChild(backToTop);

        backToTop.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        window.addEventListener('scroll', () => {
            if (window.scrollY > 500) {
                backToTop.classList.add('visible');
            } else {
                backToTop.classList.remove('visible');
            }
        });

        // Print-friendly
        window.addEventListener('beforeprint', () => {
            document.querySelectorAll('.code-block').forEach(block => {
                block.style.maxHeight = 'none';
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + K for search (placeholder)
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                console.log('Search functionality can be added here');
            }

            // Escape to close modals
            if (e.key === 'Escape') {
                // Close any open modals
            }
        });

        // Code block line numbers (optional enhancement)
        document.querySelectorAll('pre code').forEach((block) => {
            const lines = block.innerHTML.split('\n');
            if (lines.length > 3) {
                // Could add line numbers here if needed
            }
        });

        // Lazy loading for images
        if ('IntersectionObserver' in window) {
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                        }
                        observer.unobserve(img);
                    }
                });
            });

            document.querySelectorAll('img[data-src]').forEach(img => {
                imageObserver.observe(img);
            });
        }

        // Console welcome message
        console.log('%cğŸŒ GeoAI FastAPI Tutorial', 'font-size: 24px; font-weight: bold; color: #059669;');
        console.log('%cØ¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹ ØªÙˆØ³Ø¹Ù‡ API Ù‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ', 'font-size: 14px; color: #6b7280;');
        console.log('%câ­ Star us on GitHub!', 'font-size: 12px; color: #3b82f6;');
    </script>

    <!-- Additional Styles for new elements -->
    <style>
        /* Reading Progress Bar */
        .reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(5, 150, 105, 0.2);
            z-index: 10000;
        }

        .reading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #059669, #10b981, #34d399);
            width: 0%;
            transition: width 0.1s ease;
        }

        /* Back to Top Button */
        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #059669, #10b981);
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(5, 150, 105, 0.4);
            z-index: 1000;
        }

        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .back-to-top:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(5, 150, 105, 0.5);
        }

        /* Summary Grid */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .summary-card {
            background: linear-gradient(135deg, #f0fdf4, #dcfce7);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #bbf7d0;
        }

        .summary-card h4 {
            color: #059669;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .summary-card ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .summary-card li {
            padding: 0.5rem 0;
            padding-right: 1.5rem;
            position: relative;
            color: #374151;
            border-bottom: 1px dashed #d1fae5;
        }

        .summary-card li:last-child {
            border-bottom: none;
        }

        .summary-card li::before {
            content: 'âœ“';
            position: absolute;
            right: 0;
            color: #10b981;
            font-weight: bold;
        }

        /* Resources List */
        .resources-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 2rem 0;
        }

        .resource-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 1.5rem;
            background: white;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .resource-item:hover {
            border-color: #10b981;
            box-shadow: 0 4px 12px rgba(5, 150, 105, 0.15);
            transform: translateX(-5px);
        }

        .resource-icon {
            font-size: 2rem;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0fdf4;
            border-radius: 10px;
        }

        .resource-content {
            flex: 1;
        }

        .resource-content a {
            color: #059669;
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .resource-content a:hover {
            text-decoration: underline;
        }

        .resource-content p {
            margin: 0.25rem 0 0 0;
            color: #6b7280;
            font-size: 0.9rem;
        }

        /* Best Practices Grid */
        .best-practices-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .practice-card {
            background: white;
            border-radius: 16px;
            padding: 1.5rem;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .practice-card:hover {
            border-color: #10b981;
            box-shadow: 0 8px 25px rgba(5, 150, 105, 0.15);
            transform: translateY(-5px);
        }

        .practice-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .practice-card h4 {
            color: #1f2937;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .practice-card ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .practice-card li {
            padding: 0.5rem 0;
            padding-right: 1.2rem;
            position: relative;
            color: #4b5563;
            font-size: 0.95rem;
        }

        .practice-card li::before {
            content: 'â€¢';
            position: absolute;
            right: 0;
            color: #10b981;
            font-weight: bold;
        }

        /* Footer Styles */
        .footer {
            background: linear-gradient(135deg, #064e3b, #065f46);
            color: white;
            padding: 3rem 2rem 1rem;
            margin-top: 4rem;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
        }

        .footer-section h4 {
            color: #34d399;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .footer-section p {
            color: #a7f3d0;
            line-height: 1.6;
        }

        .tech-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .tech-tag {
            background: rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .footer-bottom {
            text-align: center;
            padding-top: 2rem;
            margin-top: 2rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .footer-bottom p {
            color: #a7f3d0;
        }

        /* Dark Theme (Optional) */
        .dark-theme {
            --bg-color: #111827;
            --text-color: #f3f4f6;
            --card-bg: #1f2937;
            --border-color: #374151;
        }

        .dark-theme body {
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .dark-theme .section {
            background: var(--card-bg);
            border-color: var(--border-color);
        }

        .dark-theme .code-block {
            background: #0d1117;
        }

        .dark-theme .info-box {
            background: var(--card-bg);
            border-color: var(--border-color);
        }

        /* Print Styles */
        @media print {

            .sidebar,
            .back-to-top,
            .reading-progress,
            .code-actions {
                display: none !important;
            }

            .main-content {
                margin: 0;
                padding: 1rem;
            }

            .section {
                break-inside: avoid;
                page-break-inside: avoid;
            }

            .code-block {
                max-height: none !important;
                overflow: visible !important;
            }

            body {
                font-size: 12pt;
            }

            a {
                text-decoration: none;
                color: inherit;
            }

            a[href]::after {
                content: " (" attr(href) ")";
                font-size: 0.8em;
                color: #666;
            }
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {

            .summary-grid,
            .best-practices-grid {
                grid-template-columns: 1fr;
            }

            .footer-content {
                grid-template-columns: 1fr;
                text-align: center;
            }

            .tech-tags {
                justify-content: center;
            }

            .back-to-top {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
            }

            .resource-item {
                flex-direction: column;
                text-align: center;
            }
        }

        /* Animation for section entry */
        .section {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.6s ease forwards;
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section:nth-child(1) {
            animation-delay: 0.1s;
        }

        .section:nth-child(2) {
            animation-delay: 0.2s;
        }

        .section:nth-child(3) {
            animation-delay: 0.3s;
        }

        .section:nth-child(4) {
            animation-delay: 0.4s;
        }

        .section:nth-child(5) {
            animation-delay: 0.5s;
        }

        .section:nth-child(6) {
            animation-delay: 0.6s;
        }

        .section:nth-child(7) {
            animation-delay: 0.7s;
        }

        .section:nth-child(8) {
            animation-delay: 0.8s;
        }

        /* Tooltip styles */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1f2937;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
            bottom: calc(100% + 10px);
        }

        /* Code highlight improvements */
        .hljs {
            background: transparent !important;
            padding: 0 !important;
        }

        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em !important;
        }

        /* Custom scrollbar for code blocks */
        .code-body::-webkit-scrollbar {
            height: 8px;
        }

        .code-body::-webkit-scrollbar-track {
            background: #1e293b;
            border-radius: 4px;
        }

        .code-body::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        .code-body::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Selection styling */
        ::selection {
            background: #10b981;
            color: white;
        }

        ::-moz-selection {
            background: #10b981;
            color: white;
        }

        /* Focus styles for accessibility */
        a:focus,
        button:focus {
            outline: 2px solid #10b981;
            outline-offset: 2px;
        }

        /* Skip to content link for accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #059669;
            color: white;
            padding: 8px 16px;
            z-index: 10001;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
        }
    </style>

    <!-- Skip to content link -->
    <a href="#intro" class="skip-link">Ø±ÙØªÙ† Ø¨Ù‡ Ù…Ø­ØªÙˆØ§ÛŒ Ø§ØµÙ„ÛŒ</a>

</body>

</html>