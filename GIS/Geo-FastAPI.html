<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI + GeoSpatial + AI | Ø¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <!-- Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>
    
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ROOT VARIABLES & THEME
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        :root {
            /* Primary Colors - Geo Theme */
            --primary: #10b981;
            --primary-dark: #059669;
            --primary-light: #34d399;
            --primary-glow: rgba(16, 185, 129, 0.4);
            
            /* AI Accent Colors */
            --ai-purple: #8b5cf6;
            --ai-blue: #3b82f6;
            --ai-cyan: #06b6d4;
            --ai-pink: #ec4899;
            
            /* FastAPI Orange */
            --fastapi: #009688;
            --fastapi-light: #4db6ac;
            
            /* Status Colors */
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            
            /* Dark Theme */
            --bg-primary: #0a0f1a;
            --bg-secondary: #111827;
            --bg-tertiary: #1f2937;
            --bg-card: #1a2332;
            --bg-code: #0d1117;
            
            /* Text Colors */
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            
            /* Border Colors */
            --border-color: #2d3748;
            --border-light: #374151;
            
            /* Gradients */
            --gradient-geo: linear-gradient(135deg, #10b981 0%, #06b6d4 100%);
            --gradient-ai: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
            --gradient-fast: linear-gradient(135deg, #009688 0%, #4db6ac 100%);
            --gradient-hero: linear-gradient(135deg, #10b981 0%, #8b5cf6 50%, #06b6d4 100%);
            --gradient-dark: linear-gradient(180deg, #0a0f1a 0%, #111827 100%);
            
            /* Shadows */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
            --shadow-glow: 0 0 40px var(--primary-glow);
            --shadow-ai: 0 0 40px rgba(139, 92, 246, 0.3);
            
            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --radius-full: 9999px;
            
            /* Font */
            --font-main: 'Vazirmatn', system-ui, sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESET & BASE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            font-size: 16px;
        }

        body {
            font-family: var(--font-main);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.8;
            overflow-x: hidden;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SCROLLBAR
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gradient-geo);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SELECTION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        ::selection {
            background: var(--primary);
            color: white;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HEADER & NAVIGATION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(10, 15, 26, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 0;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 24px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.4rem;
            font-weight: 800;
            text-decoration: none;
            color: var(--text-primary);
        }

        .logo-icon {
            width: 42px;
            height: 42px;
            background: var(--gradient-geo);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
        }

        .logo-text {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }

        .logo-text span:first-child {
            background: var(--gradient-hero);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .logo-text span:last-child {
            font-size: 0.7rem;
            font-weight: 400;
            color: var(--text-muted);
        }

        .nav {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 8px 16px;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-link:hover {
            background: rgba(16, 185, 129, 0.1);
            color: var(--primary-light);
        }

        .nav-link.active {
            background: rgba(16, 185, 129, 0.2);
            color: var(--primary);
        }

        .nav-link .nav-icon {
            font-size: 1rem;
        }

        /* Mobile Menu */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HERO SECTION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .hero {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 120px 24px 80px;
            position: relative;
            overflow: hidden;
        }

        .hero-bg {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(16, 185, 129, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(139, 92, 246, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(6, 182, 212, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Animated Grid */
        .hero-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(rgba(16, 185, 129, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(16, 185, 129, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
        }

        .hero-content {
            position: relative;
            z-index: 1;
            max-width: 1000px;
            text-align: center;
        }

        .hero-badges {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 32px;
        }

        .hero-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: var(--radius-full);
            font-size: 0.85rem;
            font-weight: 600;
        }

        .hero-badge.geo {
            background: rgba(16, 185, 129, 0.15);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--primary-light);
        }

        .hero-badge.ai {
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #a78bfa;
        }

        .hero-badge.fast {
            background: rgba(0, 150, 136, 0.15);
            border: 1px solid rgba(0, 150, 136, 0.3);
            color: var(--fastapi-light);
        }

        .hero h1 {
            font-size: clamp(2.5rem, 7vw, 4.5rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 24px;
        }

        .hero h1 .gradient-text {
            background: var(--gradient-hero);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero-subtitle {
            font-size: 1.3rem;
            color: var(--text-secondary);
            max-width: 700px;
            margin: 0 auto 40px;
            line-height: 1.7;
        }

        .hero-cta {
            display: flex;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
            margin-bottom: 60px;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 14px 28px;
            border-radius: var(--radius-md);
            font-size: 1rem;
            font-weight: 600;
            font-family: var(--font-main);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .btn-primary {
            background: var(--gradient-geo);
            color: white;
            box-shadow: 0 4px 20px var(--primary-glow);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px var(--primary-glow);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-card);
            border-color: var(--primary);
        }

        /* Hero Stats */
        .hero-stats {
            display: flex;
            justify-content: center;
            gap: 48px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 900;
            background: var(--gradient-geo);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MAIN CONTENT
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px 80px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SECTION STYLES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .section {
            margin-bottom: 64px;
            padding: 48px;
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-geo);
        }

        .section.ai-section::before {
            background: var(--gradient-ai);
        }

        .section.fast-section::before {
            background: var(--gradient-fast);
        }

        .section-header {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 32px;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-icon {
            width: 64px;
            height: 64px;
            background: var(--gradient-geo);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            flex-shrink: 0;
            box-shadow: var(--shadow-glow);
        }

        .section.ai-section .section-icon {
            background: var(--gradient-ai);
            box-shadow: var(--shadow-ai);
        }

        .section.fast-section .section-icon {
            background: var(--gradient-fast);
        }

        .section-title-group {
            flex: 1;
        }

        .section-number {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 4px;
        }

        .section.ai-section .section-number {
            color: var(--ai-purple);
        }

        .section-title {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .section-subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TYPOGRAPHY
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        h3 {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 40px 0 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        h3::before {
            content: '';
            width: 4px;
            height: 24px;
            background: var(--gradient-geo);
            border-radius: 2px;
        }

        h4 {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--primary-light);
            margin: 28px 0 12px;
        }

        p {
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        a {
            color: var(--primary);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        a:hover {
            color: var(--primary-light);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CODE BLOCKS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .code-block {
            margin: 24px 0;
            border-radius: var(--radius-lg);
            overflow: hidden;
            background: var(--bg-code);
            border: 1px solid var(--border-color);
        }

        .code-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .code-lang {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .code-lang-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 700;
        }

        .code-lang-icon.python {
            background: linear-gradient(135deg, #3776ab 0%, #ffd43b 100%);
            color: white;
        }

        .code-lang-icon.bash {
            background: #4eaa25;
            color: white;
        }

        .code-lang-icon.json {
            background: #f59e0b;
            color: white;
        }

        .code-lang-icon.sql {
            background: #336791;
            color: white;
        }

        .code-filename {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .code-actions {
            display: flex;
            gap: 8px;
        }

        .code-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            font-family: var(--font-main);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .code-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }

        .code-btn.copied {
            background: rgba(16, 185, 129, 0.3);
            color: var(--primary);
        }

        .code-body {
            padding: 20px;
            overflow-x: auto;
        }

        .code-body pre {
            margin: 0;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.7;
            direction: ltr;
            text-align: left;
        }

        .code-body code {
            font-family: var(--font-mono);
        }

        /* Inline Code */
        code:not([class*="language-"]) {
            background: rgba(16, 185, 129, 0.15);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.85em;
            color: var(--primary-light);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CARDS & GRIDS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 24px;
            margin: 24px 0;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 20px;
            margin: 24px 0;
        }

        .grid-4 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 24px 0;
        }

        .card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 24px;
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--primary);
            transform: translateY(-4px);
            box-shadow: var(--shadow-glow);
        }

        .card.ai-card:hover {
            border-color: var(--ai-purple);
            box-shadow: var(--shadow-ai);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .card-icon {
            width: 48px;
            height: 48px;
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            flex-shrink: 0;
        }

        .card-icon.geo { background: rgba(16, 185, 129, 0.2); }
        .card-icon.ai { background: rgba(139, 92, 246, 0.2); }
        .card-icon.fast { background: rgba(0, 150, 136, 0.2); }
        .card-icon.blue { background: rgba(59, 130, 246, 0.2); }
        .card-icon.orange { background: rgba(245, 158, 11, 0.2); }
        .card-icon.pink { background: rgba(236, 72, 153, 0.2); }
        .card-icon.cyan { background: rgba(6, 182, 212, 0.2); }

        .card-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .card-content {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .card-content ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .card-content li {
            padding: 8px 0;
            padding-right: 20px;
            position: relative;
            border-bottom: 1px solid var(--border-color);
        }

        .card-content li:last-child {
            border-bottom: none;
        }

        .card-content li::before {
            content: 'â†’';
            position: absolute;
            right: 0;
            color: var(--primary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           INFO BOXES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .info-box {
            padding: 20px 24px;
            border-radius: var(--radius-lg);
            margin: 24px 0;
            border-right: 4px solid;
        }

        .info-box.tip {
            background: rgba(16, 185, 129, 0.1);
            border-right-color: var(--primary);
        }

        .info-box.warning {
            background: rgba(245, 158, 11, 0.1);
            border-right-color: var(--warning);
        }

        .info-box.danger {
            background: rgba(239, 68, 68, 0.1);
            border-right-color: var(--danger);
        }

        .info-box.info {
            background: rgba(59, 130, 246, 0.1);
            border-right-color: var(--info);
        }

        .info-box.ai {
            background: rgba(139, 92, 246, 0.1);
            border-right-color: var(--ai-purple);
        }

        .info-box-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .info-box-content {
            color: var(--text-secondary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ARCHITECTURE DIAGRAM
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .architecture-box {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 32px;
            margin: 24px 0;
            overflow-x: auto;
        }

        .architecture-title {
            text-align: center;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 24px;
            font-size: 1.1rem;
        }

        .architecture-diagram {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--text-secondary);
            white-space: pre;
            direction: ltr;
            text-align: center;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TABLES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .table-container {
            overflow-x: auto;
            margin: 24px 0;
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        th, td {
            padding: 14px 18px;
            text-align: right;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            font-weight: 700;
            color: var(--primary);
            white-space: nowrap;
        }

        tr:hover {
            background: rgba(16, 185, 129, 0.05);
        }

        tr:last-child td {
            border-bottom: none;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FILE TREE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .file-tree {
            background: var(--bg-code);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 24px;
            margin: 24px 0;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            direction: ltr;
            text-align: left;
        }

        .file-tree-title {
            color: var(--primary);
            font-weight: 700;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .file-tree pre {
            margin: 0;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .file-tree .folder {
            color: var(--ai-purple);
        }

        .file-tree .file-py {
            color: var(--primary);
        }

        .file-tree .file-json {
            color: var(--warning);
        }

        .file-tree .file-sql {
            color: var(--info);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           API ENDPOINT CARDS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .endpoint-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            margin: 20px 0;
            overflow: hidden;
        }

        .endpoint-header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: var(--bg-code);
            border-bottom: 1px solid var(--border-color);
        }

        .endpoint-method {
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            font-weight: 700;
            font-family: var(--font-mono);
        }

        .endpoint-method.get {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .endpoint-method.post {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .endpoint-method.put {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .endpoint-method.delete {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .endpoint-path {
            font-family: var(--font-mono);
            font-size: 0.95rem;
            color: var(--text-primary);
            direction: ltr;
        }

        .endpoint-body {
            padding: 20px;
        }

        .endpoint-desc {
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FEATURE LIST
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .feature-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        .feature-list li {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .feature-list li:last-child {
            border-bottom: none;
        }

        .feature-icon {
            width: 24px;
            height: 24px;
            background: var(--gradient-geo);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .feature-text {
            color: var(--text-secondary);
        }

        .feature-text strong {
            color: var(--text-primary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CHAPTER NAVIGATION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .chapter-nav {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin: 48px 0;
        }

        .chapter-link {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .chapter-link:hover {
            border-color: var(--primary);
            transform: translateX(-8px);
            box-shadow: var(--shadow-glow);
        }

        .chapter-link.ai-link:hover {
            border-color: var(--ai-purple);
            box-shadow: var(--shadow-ai);
        }

        .chapter-num {
            width: 48px;
            height: 48px;
            background: var(--gradient-geo);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 1.2rem;
            color: white;
            flex-shrink: 0;
        }

        .chapter-link.ai-link .chapter-num {
            background: var(--gradient-ai);
        }

        .chapter-info {
            flex: 1;
        }

        .chapter-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .chapter-desc {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STEPS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .steps {
            margin: 24px 0;
        }

        .step {
            display: flex;
            gap: 20px;
            padding: 24px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }

        .step:hover {
            border-color: var(--primary);
        }

        .step-number {
            width: 48px;
            height: 48px;
            background: var(--gradient-geo);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 1.2rem;
            color: white;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .step-desc {
            color: var(--text-secondary);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FOOTER
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 48px 24px;
            margin-top: 64px;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        .footer-logo {
            font-size: 1.5rem;
            font-weight: 800;
            background: var(--gradient-hero);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 16px;
        }

        .footer-text {
            color: var(--text-muted);
            font-size: 0.95rem;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-top: 24px;
            flex-wrap: wrap;
        }

        .footer-links a {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (max-width: 1024px) {
            .nav {
                display: none;
            }

            .menu-toggle {
                display: block;
            }
        }

        @media (max-width: 768px) {
            .hero {
                padding: 100px 16px 60px;
            }

            .hero h1 {
                font-size: 2rem;
            }

            .hero-subtitle {
                font-size: 1.1rem;
            }

            .section {
                padding: 24px;
                margin-bottom: 32px;
            }

            .section-header {
                flex-direction: column;
                text-align: center;
            }

            .section-icon {
                margin: 0 auto;
            }

            h3 {
                font-size: 1.2rem;
            }

            .grid-2, .grid-3, .grid-4 {
                grid-template-columns: 1fr;
            }

            .step {
                flex-direction: column;
                text-align: center;
            }

            .hero-stats {
                gap: 24px;
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ANIMATIONS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        .section {
            animation: fadeInUp 0.6s ease-out;
        }

        /* AI Glow Animation */
        @keyframes aiGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
            }
            50% {
                box-shadow: 0 0 40px rgba(139, 92, 246, 0.5);
            }
        }

        .ai-glow {
            animation: aiGlow 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         HEADER
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <header class="header">
        <div class="header-content">
            <a href="#" class="logo">
                <div class="logo-icon">ğŸŒ</div>
                <div class="logo-text">
                    <span>GeoAI FastAPI</span>
                    <span>Ø¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹</span>
                </div>
            </a>
            
            <nav class="nav">
                <a href="#intro" class="nav-link">
                    <span class="nav-icon">ğŸš€</span>
                    <span>Ù…Ø¹Ø±ÙÛŒ</span>
                </a>
                <a href="#setup" class="nav-link">
                    <span class="nav-icon">âš™ï¸</span>
                    <span>Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ</span>
                </a>
                <a href="#geo-basics" class="nav-link">
                    <span class="nav-icon">ğŸ—ºï¸</span>
                    <span>GeoSpatial</span>
                </a>
                <a href="#ai-integration" class="nav-link">
                    <span class="nav-icon">ğŸ¤–</span>
                    <span>AI</span>
                </a>
                <a href="#projects" class="nav-link">
                    <span class="nav-icon">ğŸ“¦</span>
                    <span>Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§</span>
                </a>
            </nav>

            <button class="menu-toggle">â˜°</button>
        </div>
    </header>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         HERO
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <section class="hero">
        <div class="hero-bg"></div>
        <div class="hero-grid"></div>
        
        <div class="hero-content">
            <div class="hero-badges">
                <span class="hero-badge fast">âš¡ FastAPI</span>
                <span class="hero-badge geo">ğŸŒ GeoSpatial</span>
                <span class="hero-badge ai">ğŸ¤– AI/ML</span>
            </div>
            
            <h1>
                <span class="gradient-text">FastAPI + GeoSpatial</span>
                <br>
                Ø¨Ø§ Ù‚Ø¯Ø±Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ
            </h1>
            
            <p class="hero-subtitle">
                Ø³Ø§Ø®Øª API Ù‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¨Ø§ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ú©Ø§Ø±Ø§ÛŒÛŒ
                <br>
                Ø§Ø² ØªØ­Ù„ÛŒÙ„ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ ØªØ§ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ø§ AI
            </p>
            
            <div class="hero-cta">
                <a href="#intro" class="btn btn-primary">
                    <span>ğŸš€</span>
                    <span>Ø´Ø±ÙˆØ¹ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ</span>
                </a>
                <a href="#projects" class="btn btn-secondary">
                    <span>ğŸ“¦</span>
                    <span>Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ</span>
                </a>
            </div>
            
            <div class="hero-stats">
                <div class="stat-item">
                    <div class="stat-value">Û±Û²</div>
                    <div class="stat-label">ÙØµÙ„ Ø¢Ù…ÙˆØ²Ø´ÛŒ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">ÛµÛ°+</div>
                    <div class="stat-label">Ù†Ù…ÙˆÙ†Ù‡ Ú©Ø¯</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">Ûµ</div>
                    <div class="stat-label">Ù¾Ø±ÙˆÚ˜Ù‡ Ø¹Ù…Ù„ÛŒ</div>
                </div>
            </div>
        </div>
    </section>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         MAIN CONTENT
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <main class="main-content">

        <!-- Chapter Navigation -->
        <div class="chapter-nav">
            <a href="#intro" class="chapter-link">
                <div class="chapter-num">Û±</div>
                <div class="chapter-info">
                    <div class="chapter-title">Ù…Ø¹Ø±ÙÛŒ Ùˆ Ù…ÙØ§Ù‡ÛŒÙ…</div>
                    <div class="chapter-desc">FastAPIØŒ GeoSpatialØŒ AI</div>
                </div>
            </a>
            <a href="#setup" class="chapter-link">
                <div class="chapter-num">Û²</div>
                <div class="chapter-info">
                    <div class="chapter-title">Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡</div>
                    <div class="chapter-desc">Ù…Ø­ÛŒØ· ØªÙˆØ³Ø¹Ù‡ Ùˆ Ø³Ø§Ø®ØªØ§Ø±</div>
                </div>
            </a>
            <a href="#geo-basics" class="chapter-link">
                <div class="chapter-num">Û³</div>
                <div class="chapter-info">
                    <div class="chapter-title">Ù…Ø¨Ø§Ù†ÛŒ GeoSpatial</div>
                    <div class="chapter-desc">PostGIS, Shapely, GeoJSON</div>
                </div>
            </a>
            <a href="#ai-integration" class="chapter-link ai-link">
                <div class="chapter-num">Û´</div>
                <div class="chapter-info">
                    <div class="chapter-title">ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡â€ŒØ³Ø§Ø²ÛŒ AI</div>
                    <div class="chapter-desc">ML, Computer Vision, LLM</div>
                </div>
            </a>
            <a href="#satellite" class="chapter-link ai-link">
                <div class="chapter-num">Ûµ</div>
                <div class="chapter-info">
                    <div class="chapter-title">ØªØ­Ù„ÛŒÙ„ Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</div>
                    <div class="chapter-desc">ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ Ø¨Ø§ AI</div>
                </div>
            </a>
            <a href="#projects" class="chapter-link">
                <div class="chapter-num">Û¶</div>
                <div class="chapter-info">
                    <div class="chapter-title">Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ</div>
                    <div class="chapter-desc">Ú©Ø§Ø±Ø¨Ø±Ø¯Ù‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ</div>
                </div>
            </a>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 1: INTRODUCTION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="intro">
            <div class="section-header">
                <div class="section-icon">ğŸš€</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û±</div>
                    <h2 class="section-title">Ù…Ø¹Ø±ÙÛŒ Ùˆ Ù…ÙØ§Ù‡ÛŒÙ… Ù¾Ø§ÛŒÙ‡</h2>
                    <p class="section-subtitle">Ø¢Ø´Ù†Ø§ÛŒÛŒ Ø¨Ø§ FastAPIØŒ GeoSpatial Ùˆ AI</p>
                </div>
            </div>

            <h3>Ú†Ø±Ø§ FastAPI Ø¨Ø±Ø§ÛŒ GeoSpatial AIØŸ</h3>
            
            <p>
                <strong>FastAPI</strong> ÛŒÚ© ÙØ±ÛŒÙ…â€ŒÙˆØ±Ú© Ù…Ø¯Ø±Ù† Ùˆ Ø¨Ø³ÛŒØ§Ø± Ø³Ø±ÛŒØ¹ Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø®Øª API Ø¨Ø§ Python Ø§Ø³Øª.
                ØªØ±Ú©ÛŒØ¨ Ø¢Ù† Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ùˆ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒØŒ Ø§Ù…Ú©Ø§Ù† Ø³Ø§Ø®Øª Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ù‚Ø¯Ø±ØªÙ…Ù†Ø¯ GeoAI Ø±Ø§ ÙØ±Ø§Ù‡Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
            </p>

            <div class="grid-3">
                <div class="card">
                    <div class="card-header">
                        <div class="card-icon fast">âš¡</div>
                        <div class="card-title">FastAPI</div>
                    </div>
                    <div class="card-content">
                        <ul>
                            <li>Ø³Ø±Ø¹Øª Ø¨Ø³ÛŒØ§Ø± Ø¨Ø§Ù„Ø§ (Starlette + Pydantic)</li>
                            <li>Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø®ÙˆØ¯Ú©Ø§Ø± OpenAPI</li>
                            <li>Type Hints Ùˆ Validation</li>
                            <li>Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² Async/Await</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <div class="card-icon geo">ğŸŒ</div>
                        <div class="card-title">GeoSpatial</div>
                    </div>
                    <div class="card-content">
                        <ul>
                            <li>Ú©Ø§Ø± Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ</li>
                            <li>ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ</li>
                            <li>PostGIS Ùˆ GeoDjango</li>
                            <li>ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</li>
                        </ul>
                    </div>
                </div>

                <div class="card ai-card">
                    <div class="card-header">
                        <div class="card-icon ai">ğŸ¤–</div>
                        <div class="card-title">AI/ML</div>
                    </div>
                    <div class="card-content">
                        <ul>
                            <li>ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§ Ø¯Ø± ØªØµØ§ÙˆÛŒØ±</li>
                            <li>Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù…Ú©Ø§Ù†ÛŒ</li>
                            <li>ØªØ­Ù„ÛŒÙ„ Ø³Ø±ÛŒ Ø²Ù…Ø§Ù†ÛŒ</li>
                            <li>LLM Ø¨Ø±Ø§ÛŒ Geo Query</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3>Ù…Ø¹Ù…Ø§Ø±ÛŒ Ú©Ù„ÛŒ Ø³ÛŒØ³ØªÙ…</h3>

            <div class="architecture-box">
                <div class="architecture-title">ğŸ—ï¸ Ù…Ø¹Ù…Ø§Ø±ÛŒ GeoAI API</div>
                <div class="architecture-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         CLIENT LAYER                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Web App â”‚  â”‚ Mobile   â”‚  â”‚  QGIS    â”‚  â”‚  Other   â”‚        â”‚
â”‚  â”‚ (React)  â”‚  â”‚   App    â”‚  â”‚ Plugin   â”‚  â”‚  GIS     â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜        â”‚
â”‚       â”‚             â”‚             â”‚             â”‚               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚             â”‚             â”‚             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   API Gateway   â”‚
                    â”‚   (FastAPI)     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                    â”‚                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚  GeoSpatial   â”‚   â”‚   AI/ML         â”‚   â”‚   Auth &     â”‚
â”‚   Services    â”‚   â”‚   Services      â”‚   â”‚   Cache      â”‚
â”‚               â”‚   â”‚                 â”‚   â”‚              â”‚
â”‚ â€¢ Buffer      â”‚   â”‚ â€¢ Object Det.  â”‚   â”‚ â€¢ JWT Auth   â”‚
â”‚ â€¢ Intersect   â”‚   â”‚ â€¢ Prediction   â”‚   â”‚ â€¢ Redis      â”‚
â”‚ â€¢ Routing     â”‚   â”‚ â€¢ Classificationâ”‚   â”‚ â€¢ Rate Limit â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                    â”‚                    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚              â”‚              â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
      â”‚   PostGIS    â”‚ â”‚  Object   â”‚ â”‚   Tile    â”‚
      â”‚   Database   â”‚ â”‚  Storage  â”‚ â”‚  Server   â”‚
      â”‚              â”‚ â”‚  (MinIO)  â”‚ â”‚ (Martin)  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                </div>
            </div>

            <h3>Ù¾Ø´ØªÙ‡ ÙÙ†Ø§ÙˆØ±ÛŒ (Tech Stack)</h3>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Ù„Ø§ÛŒÙ‡</th>
                            <th>ØªÚ©Ù†ÙˆÙ„ÙˆÚ˜ÛŒ</th>
                            <th>ØªÙˆØ¶ÛŒØ­Ø§Øª</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>API Framework</strong></td>
                            <td>FastAPI</td>
                            <td>ÙØ±ÛŒÙ…â€ŒÙˆØ±Ú© Ø§ØµÙ„ÛŒ Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Async</td>
                        </tr>
                        <tr>
                            <td><strong>Validation</strong></td>
                            <td>Pydantic v2</td>
                            <td>Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ùˆ GeoJSON</td>
                        </tr>
                        <tr>
                            <td><strong>Database</strong></td>
                            <td>PostgreSQL + PostGIS</td>
                            <td>Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ</td>
                        </tr>
                        <tr>
                            <td><strong>ORM</strong></td>
                            <td>SQLAlchemy + GeoAlchemy2</td>
                            <td>Ú©Ø§Ø± Ø¨Ø§ Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ</td>
                        </tr>
                        <tr>
                            <td><strong>Geo Libraries</strong></td>
                            <td>Shapely, GeoPandas, Rasterio</td>
                            <td>Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø¯Ø§Ø±ÛŒ Ùˆ Ø±Ø³ØªØ±ÛŒ</td>
                        </tr>
                        <tr>
                            <td><strong>AI/ML</strong></td>
                            <td>PyTorch, TensorFlow, Scikit-learn</td>
                            <td>Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù…Ø§Ø´ÛŒÙ†</td>
                        </tr>
                        <tr>
                            <td><strong>Computer Vision</strong></td>
                            <td>OpenCV, Detectron2, YOLO</td>
                            <td>Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµÙˆÛŒØ± Ùˆ ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§</td>
                        </tr>
                        <tr>
                            <td><strong>LLM</strong></td>
                            <td>LangChain, OpenAI, Ollama</td>
                            <td>Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø²Ø¨Ø§Ù† Ø·Ø¨ÛŒØ¹ÛŒ Ø¨Ø±Ø§ÛŒ Geo</td>
                        </tr>
                        <tr>
                            <td><strong>Cache</strong></td>
                            <td>Redis</td>
                            <td>Ú©Ø´ Ùˆ ØµÙ Ù¾ÛŒØ§Ù…</td>
                        </tr>
                        <tr>
                            <td><strong>Task Queue</strong></td>
                            <td>Celery</td>
                            <td>Ù¾Ø±Ø¯Ø§Ø²Ø´â€ŒÙ‡Ø§ÛŒ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 2: PROJECT SETUP
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="setup">
            <div class="section-header">
                <div class="section-icon">âš™ï¸</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û²</div>
                    <h2 class="section-title">Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡</h2>
                    <p class="section-subtitle">Ù…Ø­ÛŒØ· ØªÙˆØ³Ø¹Ù‡ Ùˆ Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡</p>
                </div>
            </div>

            <h3>Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡</h3>

            <div class="file-tree">
                <div class="file-tree-title">ğŸ“ geoai-fastapi/</div>
<pre>
<span class="folder">â”œâ”€â”€ app/</span>
â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   <span class="file-py">â”œâ”€â”€ main.py</span>                 # Entry point
â”‚   <span class="file-py">â”œâ”€â”€ config.py</span>               # Settings
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ api/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ deps.py</span>             # Dependencies
â”‚   â”‚   <span class="folder">â”œâ”€â”€ v1/</span>
â”‚   â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   â”‚   <span class="file-py">â”œâ”€â”€ router.py</span>
â”‚   â”‚   â”‚   <span class="file-py">â”œâ”€â”€ geo.py</span>          # Geo endpoints
â”‚   â”‚   â”‚   <span class="file-py">â”œâ”€â”€ ai.py</span>           # AI endpoints
â”‚   â”‚   â”‚   <span class="file-py">â””â”€â”€ analysis.py</span>     # Analysis endpoints
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ models/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ geo.py</span>              # Geo models
â”‚   â”‚   <span class="file-py">â””â”€â”€ prediction.py</span>       # ML models
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ schemas/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ geo.py</span>              # Pydantic schemas
â”‚   â”‚   <span class="file-py">â””â”€â”€ ai.py</span>               # AI schemas
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ services/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ geo_service.py</span>      # Geo operations
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ ai_service.py</span>       # AI inference
â”‚   â”‚   <span class="file-py">â””â”€â”€ satellite.py</span>        # Satellite imagery
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ ml/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ object_detection.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ segmentation.py</span>
â”‚   â”‚   <span class="file-py">â””â”€â”€ prediction.py</span>
â”‚   â”‚
â”‚   <span class="folder">â”œâ”€â”€ db/</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ session.py</span>
â”‚   â”‚   <span class="file-py">â””â”€â”€ base.py</span>
â”‚   â”‚
â”‚   <span class="folder">â””â”€â”€ core/</span>
â”‚       <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚       <span class="file-py">â”œâ”€â”€ security.py</span>
â”‚       <span class="file-py">â””â”€â”€ middleware.py</span>
â”‚
<span class="folder">â”œâ”€â”€ ml_models/</span>                  # Trained ML models
â”‚   â”œâ”€â”€ object_detection/
â”‚   â”œâ”€â”€ segmentation/
â”‚   â””â”€â”€ prediction/
â”‚
<span class="folder">â”œâ”€â”€ tests/</span>
â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   <span class="file-py">â”œâ”€â”€ test_geo.py</span>
â”‚   <span class="file-py">â””â”€â”€ test_ai.py</span>
â”‚
<span class="folder">â”œâ”€â”€ docker/</span>
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ Dockerfile.ml
â”‚   â””â”€â”€ docker-compose.yml
â”‚
<span class="file-json">â”œâ”€â”€ pyproject.toml</span>
<span class="file-json">â”œâ”€â”€ requirements.txt</span>
<span class="file-json">â”œâ”€â”€ .env.example</span>
<span class="file-json">â””â”€â”€ README.md</span>
</pre>
            </div>

            <h3>Ù†ØµØ¨ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒâ€ŒÙ‡Ø§</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon bash">$</div>
                        <span class="code-filename">requirements.txt</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-bash"># FastAPI Core
fastapi==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.3
pydantic-settings==2.1.0

# Database
sqlalchemy==2.0.25
asyncpg==0.29.0
geoalchemy2==0.14.3
alembic==1.13.1

# GeoSpatial
shapely==2.0.2
geopandas==0.14.2
pyproj==3.6.1
rasterio==1.3.9
fiona==1.9.5
geojson==3.1.0

# AI/ML
torch==2.1.2
torchvision==0.16.2
tensorflow==2.15.0
scikit-learn==1.4.0
numpy==1.26.3
pandas==2.1.4

# Computer Vision
opencv-python==4.9.0.80
Pillow==10.2.0
ultralytics==8.1.0  # YOLOv8

# LLM
langchain==0.1.0
openai==1.8.0
ollama==0.1.6

# Utilities
httpx==0.26.0
python-multipart==0.0.6
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
redis==5.0.1
celery==5.3.4

# Testing
pytest==7.4.4
pytest-asyncio==0.23.3</code></pre>
                </div>
            </div>

            <h3>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾Ø±ÙˆÚ˜Ù‡ (Config)</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/config.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from pydantic_settings import BaseSettings
from functools import lru_cache
from typing import Optional


class Settings(BaseSettings):
    """Application settings with environment variables."""
    
    # App
    APP_NAME: str = "GeoAI FastAPI"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = False
    
    # Server
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # Database
    DATABASE_URL: str = "postgresql+asyncpg://user:pass@localhost:5432/geoai"
    
    # Redis
    REDIS_URL: str = "redis://localhost:6379/0"
    
    # Security
    SECRET_KEY: str = "your-super-secret-key-change-in-production"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # AI/ML
    ML_MODELS_PATH: str = "./ml_models"
    OBJECT_DETECTION_MODEL: str = "yolov8n.pt"
    SEGMENTATION_MODEL: str = "sam_vit_h.pth"
    
    # OpenAI
    OPENAI_API_KEY: Optional[str] = None
    
    # Ollama (Local LLM)
    OLLAMA_BASE_URL: str = "http://localhost:11434"
    OLLAMA_MODEL: str = "llama2"
    
    # GeoSpatial
    DEFAULT_SRID: int = 4326
    DEFAULT_BUFFER_DISTANCE: float = 1000.0  # meters
    
    # File Storage
    UPLOAD_DIR: str = "./uploads"
    MAX_UPLOAD_SIZE: int = 100 * 1024 * 1024  # 100MB
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()


settings = get_settings()</code></pre>
                </div>
            </div>

            <h3>ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ FastAPI</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/main.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
import logging

from app.config import settings
from app.api.v1.router import api_router
from app.db.session import engine
from app.core.middleware import RequestLoggingMiddleware
from app.ml.object_detection import ObjectDetector

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Global ML models (loaded once at startup)
ml_models = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Application lifespan manager.
    Load resources at startup, cleanup at shutdown.
    """
    # Startup
    logger.info("ğŸš€ Starting GeoAI FastAPI...")
    
    # Load ML models
    logger.info("ğŸ“¦ Loading ML models...")
    try:
        ml_models["object_detector"] = ObjectDetector(
            model_path=f"{settings.ML_MODELS_PATH}/{settings.OBJECT_DETECTION_MODEL}"
        )
        logger.info("âœ… Object detection model loaded")
    except Exception as e:
        logger.warning(f"âš ï¸ Could not load object detection model: {e}")
    
    logger.info("âœ… Application started successfully!")
    
    yield
    
    # Shutdown
    logger.info("ğŸ›‘ Shutting down GeoAI FastAPI...")
    ml_models.clear()


# Create FastAPI app
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="""
    ğŸŒ **GeoAI FastAPI** - Geospatial API with AI capabilities
    
    ## Features
    
    * ğŸ—ºï¸ **GeoSpatial Operations** - Buffer, Intersect, Union, etc.
    * ğŸ¤– **AI/ML Integration** - Object detection, segmentation
    * ğŸ“¡ **Satellite Imagery** - Process and analyze satellite data
    * ğŸ” **Spatial Queries** - PostGIS powered queries
    * ğŸ’¬ **Natural Language** - Query geo data with LLM
    """,
    lifespan=lifespan,
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json"
)

# CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Custom Middleware
app.add_middleware(RequestLoggingMiddleware)

# Include routers
app.include_router(api_router, prefix="/api/v1")


@app.get("/", tags=["Root"])
async def root():
    """Root endpoint with API info."""
    return {
        "name": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "docs": "/docs",
        "health": "/health"
    }


@app.get("/health", tags=["Health"])
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "models_loaded": list(ml_models.keys()),
        "database": "connected"
    }


# Get ML models in routes
def get_ml_models():
    return ml_models


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG
    )</code></pre>
                </div>
            </div>

            <h3>Docker Compose</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon json">yml</div>
                        <span class="code-filename">docker/docker-compose.yml</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-yaml">version: '3.9'

services:
  # FastAPI Application
  api:
    build:
      context: ..
      dockerfile: docker/Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://geoai:geoai@db:5432/geoai
      - REDIS_URL=redis://redis:6379/0
      - OLLAMA_BASE_URL=http://ollama:11434
    volumes:
      - ../ml_models:/app/ml_models
      - ../uploads:/app/uploads
    depends_on:
      - db
      - redis
    restart: unless-stopped

  # PostgreSQL + PostGIS
  db:
    image: postgis/postgis:16-3.4
    environment:
      - POSTGRES_USER=geoai
      - POSTGRES_PASSWORD=geoai
      - POSTGRES_DB=geoai
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  # Ollama (Local LLM)
  ollama:
    image: ollama/ollama:latest
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama
    restart: unless-stopped

  # Martin (Vector Tiles Server)
  martin:
    image: ghcr.io/maplibre/martin:latest
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://geoai:geoai@db:5432/geoai
    depends_on:
      - db
    restart: unless-stopped

  # Celery Worker
  celery:
    build:
      context: ..
      dockerfile: docker/Dockerfile
    command: celery -A app.worker worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql+asyncpg://geoai:geoai@db:5432/geoai
      - REDIS_URL=redis://redis:6379/0
    volumes:
      - ../ml_models:/app/ml_models
    depends_on:
      - db
      - redis
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  ollama_data:</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 3: GEOSPATIAL BASICS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="geo-basics">
            <div class="section-header">
                <div class="section-icon">ğŸ—ºï¸</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û³</div>
                    <h2 class="section-title">Ù…Ø¨Ø§Ù†ÛŒ GeoSpatial Ø¯Ø± FastAPI</h2>
                    <p class="section-subtitle">PostGIS, Shapely, GeoJSON Ùˆ Pydantic</p>
                </div>
            </div>

            <h3>Schema Ù‡Ø§ÛŒ GeoJSON Ø¨Ø§ Pydantic</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/schemas/geo.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Union, Literal, Any
from enum import Enum


class GeometryType(str, Enum):
    """GeoJSON geometry types."""
    POINT = "Point"
    LINE_STRING = "LineString"
    POLYGON = "Polygon"
    MULTI_POINT = "MultiPoint"
    MULTI_LINE_STRING = "MultiLineString"
    MULTI_POLYGON = "MultiPolygon"
    GEOMETRY_COLLECTION = "GeometryCollection"


class PointCoordinates(BaseModel):
    """Point coordinates [lon, lat] or [lon, lat, elevation]."""
    coordinates: List[float] = Field(..., min_length=2, max_length=3)
    
    @field_validator('coordinates')
    @classmethod
    def validate_coordinates(cls, v):
        lon, lat = v[0], v[1]
        if not (-180 <= lon <= 180):
            raise ValueError(f"Longitude must be between -180 and 180, got {lon}")
        if not (-90 <= lat <= 90):
            raise ValueError(f"Latitude must be between -90 and 90, got {lat}")
        return v


class GeoJSONPoint(BaseModel):
    """GeoJSON Point geometry."""
    type: Literal["Point"] = "Point"
    coordinates: List[float] = Field(..., min_length=2, max_length=3)
    
    class Config:
        json_schema_extra = {
            "example": {
                "type": "Point",
                "coordinates": [51.389, 35.689]
            }
        }


class GeoJSONLineString(BaseModel):
    """GeoJSON LineString geometry."""
    type: Literal["LineString"] = "LineString"
    coordinates: List[List[float]]
    
    @field_validator('coordinates')
    @classmethod
    def validate_line(cls, v):
        if len(v) < 2:
            raise ValueError("LineString must have at least 2 points")
        return v


class GeoJSONPolygon(BaseModel):
    """GeoJSON Polygon geometry."""
    type: Literal["Polygon"] = "Polygon"
    coordinates: List[List[List[float]]]
    
    @field_validator('coordinates')
    @classmethod
    def validate_polygon(cls, v):
        for ring in v:
            if len(ring) < 4:
                raise ValueError("Polygon ring must have at least 4 points")
            if ring[0] != ring[-1]:
                raise ValueError("Polygon ring must be closed")
        return v
    
    class Config:
        json_schema_extra = {
            "example": {
                "type": "Polygon",
                "coordinates": [[[51.0, 35.0], [52.0, 35.0], [52.0, 36.0], [51.0, 36.0], [51.0, 35.0]]]
            }
        }


# Union of all geometry types
GeoJSONGeometry = Union[GeoJSONPoint, GeoJSONLineString, GeoJSONPolygon]


class GeoJSONFeature(BaseModel):
    """GeoJSON Feature."""
    type: Literal["Feature"] = "Feature"
    geometry: GeoJSONGeometry
    properties: Optional[dict] = {}
    id: Optional[Union[str, int]] = None


class GeoJSONFeatureCollection(BaseModel):
    """GeoJSON FeatureCollection."""
    type: Literal["FeatureCollection"] = "FeatureCollection"
    features: List[GeoJSONFeature]
    
    class Config:
        json_schema_extra = {
            "example": {
                "type": "FeatureCollection",
                "features": [
                    {
                        "type": "Feature",
                        "geometry": {"type": "Point", "coordinates": [51.389, 35.689]},
                        "properties": {"name": "Tehran"}
                    }
                ]
            }
        }


# Request/Response schemas
class BufferRequest(BaseModel):
    """Buffer operation request."""
    geometry: GeoJSONGeometry
    distance: float = Field(..., gt=0, description="Buffer distance in meters")
    srid: int = Field(default=4326, description="Spatial Reference ID")


class BufferResponse(BaseModel):
    """Buffer operation response."""
    original: GeoJSONGeometry
    buffered: GeoJSONPolygon
    distance: float
    area_sqm: float


class SpatialQueryRequest(BaseModel):
    """Spatial query request."""
    geometry: GeoJSONGeometry
    operation: Literal["intersects", "contains", "within", "touches"] = "intersects"
    layer: str
    limit: int = Field(default=100, le=1000)


class DistanceRequest(BaseModel):
    """Distance calculation request."""
    from_point: GeoJSONPoint
    to_point: GeoJSONPoint
    unit: Literal["meters", "kilometers", "miles"] = "meters"


class DistanceResponse(BaseModel):
    """Distance calculation response."""
    distance: float
    unit: str
    from_point: GeoJSONPoint
    to_point: GeoJSONPoint</code></pre>
                </div>
            </div>

            <h3>Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Database Ø¨Ø§ GeoAlchemy2</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/models/geo.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from geoalchemy2 import Geometry
from geoalchemy2.shape import to_shape, from_shape
from datetime import datetime
import json

from app.db.base import Base


class SpatialLayer(Base):
    """Base model for spatial layers."""
    __tablename__ = "spatial_layers"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), unique=True, index=True)
    description = Column(Text, nullable=True)
    geometry_type = Column(String(50))  # Point, LineString, Polygon, etc.
    srid = Column(Integer, default=4326)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    features = relationship("SpatialFeature", back_populates="layer", cascade="all, delete-orphan")


class SpatialFeature(Base):
    """Model for spatial features."""
    __tablename__ = "spatial_features"
    
    id = Column(Integer, primary_key=True, index=True)
    layer_id = Column(Integer, ForeignKey("spatial_layers.id"), index=True)
    
    # Geometry column with spatial index
    geom = Column(
        Geometry(geometry_type="GEOMETRY", srid=4326, spatial_index=True),
        nullable=False
    )
    
    # Properties stored as JSON
    properties = Column(Text, default="{}")
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    layer = relationship("SpatialLayer", back_populates="features")
    
    @property
    def shapely_geom(self):
        """Convert to Shapely geometry."""
        return to_shape(self.geom)
    
    @shapely_geom.setter
    def shapely_geom(self, shape):
        """Set from Shapely geometry."""
        self.geom = from_shape(shape, srid=4326)
    
    @property
    def props(self) -> dict:
        """Get properties as dict."""
        return json.loads(self.properties) if self.properties else {}
    
    @props.setter
    def props(self, value: dict):
        """Set properties from dict."""
        self.properties = json.dumps(value)
    
    def to_geojson_feature(self) -> dict:
        """Convert to GeoJSON Feature."""
        from shapely.geometry import mapping
        return {
            "type": "Feature",
            "id": self.id,
            "geometry": mapping(self.shapely_geom),
            "properties": {
                **self.props,
                "layer_id": self.layer_id,
                "created_at": self.created_at.isoformat() if self.created_at else None
            }
        }


class POI(Base):
    """Points of Interest model."""
    __tablename__ = "pois"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), index=True)
    category = Column(String(100), index=True)
    description = Column(Text, nullable=True)
    
    # Point geometry
    location = Column(
        Geometry(geometry_type="POINT", srid=4326, spatial_index=True),
        nullable=False
    )
    
    # Additional fields
    address = Column(String(500), nullable=True)
    phone = Column(String(50), nullable=True)
    website = Column(String(255), nullable=True)
    rating = Column(Float, nullable=True)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    @property
    def coordinates(self) -> tuple:
        """Get (lon, lat) tuple."""
        point = to_shape(self.location)
        return (point.x, point.y)


class Road(Base):
    """Road network model."""
    __tablename__ = "roads"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=True)
    road_type = Column(String(50), index=True)  # highway, primary, secondary, etc.
    
    # LineString geometry
    geom = Column(
        Geometry(geometry_type="LINESTRING", srid=4326, spatial_index=True),
        nullable=False
    )
    
    # Road properties
    length_m = Column(Float)  # Length in meters
    speed_limit = Column(Integer, nullable=True)
    one_way = Column(String(10), default="no")
    
    @property
    def length_km(self) -> float:
        """Get length in kilometers."""
        return self.length_m / 1000 if self.length_m else 0</code></pre>
                </div>
            </div>

            <h3>Ø³Ø±ÙˆÛŒØ³ GeoSpatial</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/services/geo_service.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from typing import List, Optional, Dict, Any
from shapely.geometry import shape, mapping, Point, LineString, Polygon
from shapely.ops import transform, unary_union
from shapely import wkt, wkb
import pyproj
from functools import partial
import json

from geoalchemy2 import functions as func
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.geo import SpatialFeature, SpatialLayer, POI
from app.schemas.geo import GeoJSONGeometry, GeoJSONFeatureCollection


class GeoService:
    """Service for geospatial operations."""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # GEOMETRY OPERATIONS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    @staticmethod
    def geojson_to_shapely(geojson: dict) -> Any:
        """Convert GeoJSON to Shapely geometry."""
        return shape(geojson)
    
    @staticmethod
    def shapely_to_geojson(geom) -> dict:
        """Convert Shapely geometry to GeoJSON."""
        return mapping(geom)
    
    @staticmethod
    def reproject(geom, from_srid: int = 4326, to_srid: int = 32640):
        """
        Reproject geometry between coordinate systems.
        Default: WGS84 (4326) to UTM 40N (32640) for Iran
        """
        project = pyproj.Transformer.from_crs(
            f"EPSG:{from_srid}",
            f"EPSG:{to_srid}",
            always_xy=True
        ).transform
        return transform(project, geom)
    
    def buffer(
        self,
        geojson: dict,
        distance: float,
        srid: int = 4326,
        cap_style: int = 1,
        join_style: int = 1
    ) -> dict:
        """
        Create buffer around geometry.
        
        Args:
            geojson: Input GeoJSON geometry
            distance: Buffer distance in meters
            srid: Spatial Reference ID
            cap_style: 1=round, 2=flat, 3=square
            join_style: 1=round, 2=mitre, 3=bevel
        
        Returns:
            Buffered geometry as GeoJSON
        """
        # Convert to Shapely
        geom = self.geojson_to_shapely(geojson)
        
        # Reproject to UTM for accurate distance calculation
        geom_utm = self.reproject(geom, from_srid=srid, to_srid=32640)
        
        # Create buffer
        buffered_utm = geom_utm.buffer(
            distance,
            cap_style=cap_style,
            join_style=join_style
        )
        
        # Reproject back to original CRS
        buffered = self.reproject(buffered_utm, from_srid=32640, to_srid=srid)
        
        return self.shapely_to_geojson(buffered)
    
    def calculate_area(self, geojson: dict, srid: int = 4326) -> float:
        """Calculate area in square meters."""
        geom = self.geojson_to_shapely(geojson)
        geom_utm = self.reproject(geom, from_srid=srid, to_srid=32640)
        return geom_utm.area
    
    def calculate_length(self, geojson: dict, srid: int = 4326) -> float:
        """Calculate length in meters (for lines)."""
        geom = self.geojson_to_shapely(geojson)
        geom_utm = self.reproject(geom, from_srid=srid, to_srid=32640)
        return geom_utm.length
    
    def calculate_distance(
        self,
        point1: dict,
        point2: dict,
        srid: int = 4326
    ) -> float:
        """Calculate distance between two points in meters."""
        geom1 = self.geojson_to_shapely(point1)
        geom2 = self.geojson_to_shapely(point2)
        
        geom1_utm = self.reproject(geom1, from_srid=srid, to_srid=32640)
        geom2_utm = self.reproject(geom2, from_srid=srid, to_srid=32640)
        
        return geom1_utm.distance(geom2_utm)
    
    def intersection(self, geojson1: dict, geojson2: dict) -> Optional[dict]:
        """Get intersection of two geometries."""
        geom1 = self.geojson_to_shapely(geojson1)
        geom2 = self.geojson_to_shapely(geojson2)
        
        result = geom1.intersection(geom2)
        
        if result.is_empty:
            return None
        
        return self.shapely_to_geojson(result)
    
    def union(self, geometries: List[dict]) -> dict:
        """Union multiple geometries."""
        shapes = [self.geojson_to_shapely(g) for g in geometries]
        result = unary_union(shapes)
        return self.shapely_to_geojson(result)
    
    def centroid(self, geojson: dict) -> dict:
        """Get centroid of geometry."""
        geom = self.geojson_to_shapely(geojson)
        return self.shapely_to_geojson(geom.centroid)
    
    def convex_hull(self, geojson: dict) -> dict:
        """Get convex hull of geometry."""
        geom = self.geojson_to_shapely(geojson)
        return self.shapely_to_geojson(geom.convex_hull)
    
    def simplify(self, geojson: dict, tolerance: float = 0.001) -> dict:
        """Simplify geometry."""
        geom = self.geojson_to_shapely(geojson)
        simplified = geom.simplify(tolerance, preserve_topology=True)
        return self.shapely_to_geojson(simplified)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DATABASE OPERATIONS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def spatial_query(
        self,
        geojson: dict,
        layer_name: str,
        operation: str = "intersects",
        limit: int = 100
    ) -> List[dict]:
        """
        Perform spatial query on a layer.
        
        Args:
            geojson: Query geometry
            layer_name: Target layer name
            operation: intersects, contains, within, touches
            limit: Max results
        
        Returns:
            List of GeoJSON features
        """
        # Convert GeoJSON to WKT
        geom = self.geojson_to_shapely(geojson)
        geom_wkt = geom.wkt
        
        # Get layer
        layer_query = select(SpatialLayer).where(SpatialLayer.name == layer_name)
        result = await self.db.execute(layer_query)
        layer = result.scalar_one_or_none()
        
        if not layer:
            raise ValueError(f"Layer '{layer_name}' not found")
        
        # Build spatial query
        query_geom = func.ST_GeomFromText(geom_wkt, 4326)
        
        if operation == "intersects":
            spatial_filter = func.ST_Intersects(SpatialFeature.geom, query_geom)
        elif operation == "contains":
            spatial_filter = func.ST_Contains(SpatialFeature.geom, query_geom)
        elif operation == "within":
            spatial_filter = func.ST_Within(SpatialFeature.geom, query_geom)
        elif operation == "touches":
            spatial_filter = func.ST_Touches(SpatialFeature.geom, query_geom)
        else:
            raise ValueError(f"Unknown operation: {operation}")
        
        query = (
            select(SpatialFeature)
            .where(and_(
                SpatialFeature.layer_id == layer.id,
                spatial_filter
            ))
            .limit(limit)
        )
        
        result = await self.db.execute(query)
        features = result.scalars().all()
        
        return [f.to_geojson_feature() for f in features]
    
    async def find_nearest(
        self,
        point: dict,
        layer_name: str,
        limit: int = 10,
        max_distance: float = None
    ) -> List[dict]:
        """Find nearest features to a point."""
        geom = self.geojson_to_shapely(point)
        point_wkt = geom.wkt
        
        # Get layer
        layer_query = select(SpatialLayer).where(SpatialLayer.name == layer_name)
        result = await self.db.execute(layer_query)
        layer = result.scalar_one_or_none()
        
        if not layer:
            raise ValueError(f"Layer '{layer_name}' not found")
        
        query_point = func.ST_GeomFromText(point_wkt, 4326)
        
        # Query with distance
        query = (
            select(
                SpatialFeature,
                func.ST_Distance(
                    func.ST_Transform(SpatialFeature.geom, 32640),
                    func.ST_Transform(query_point, 32640)
                ).label('distance')
            )
            .where(SpatialFeature.layer_id == layer.id)
            .order_by('distance')
            .limit(limit)
        )
        
        if max_distance:
            query = query.where(
                func.ST_DWithin(
                    func.ST_Transform(SpatialFeature.geom, 32640),
                    func.ST_Transform(query_point, 32640),
                    max_distance
                )
            )
        
        result = await self.db.execute(query)
        rows = result.all()
        
        features = []
        for feature, distance in rows:
            geojson = feature.to_geojson_feature()
            geojson['properties']['distance_m'] = distance
            features.append(geojson)
        
        return features
    
    async def create_feature(
        self,
        layer_name: str,
        geojson: dict,
        properties: dict = None
    ) -> dict:
        """Create a new feature in a layer."""
        # Get layer
        layer_query = select(SpatialLayer).where(SpatialLayer.name == layer_name)
        result = await self.db.execute(layer_query)
        layer = result.scalar_one_or_none()
        
        if not layer:
            raise ValueError(f"Layer '{layer_name}' not found")
        
        # Create feature
        geom = self.geojson_to_shapely(geojson)
        
        feature = SpatialFeature(
            layer_id=layer.id,
            properties=json.dumps(properties or {})
        )
        feature.shapely_geom = geom
        
        self.db.add(feature)
        await self.db.commit()
        await self.db.refresh(feature)
        
        return feature.to_geojson_feature()</code></pre>
                </div>
            </div>

            <h3>API Endpoints Ø¨Ø±Ø§ÛŒ GeoSpatial</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/api/v1/geo.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Optional

from app.api.deps import get_db
from app.services.geo_service import GeoService
from app.schemas.geo import (
    GeoJSONGeometry,
    GeoJSONFeatureCollection,
    BufferRequest,
    BufferResponse,
    SpatialQueryRequest,
    DistanceRequest,
    DistanceResponse
)

router = APIRouter(prefix="/geo", tags=["GeoSpatial"])


@router.post("/buffer", response_model=BufferResponse)
async def create_buffer(
    request: BufferRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Create a buffer around a geometry.
    
    - **geometry**: Input GeoJSON geometry
    - **distance**: Buffer distance in meters
    - **srid**: Spatial Reference ID (default: 4326)
    """
    geo_service = GeoService(db)
    
    buffered = geo_service.buffer(
        geojson=request.geometry.model_dump(),
        distance=request.distance,
        srid=request.srid
    )
    
    area = geo_service.calculate_area(buffered, srid=request.srid)
    
    return BufferResponse(
        original=request.geometry,
        buffered=buffered,
        distance=request.distance,
        area_sqm=area
    )


@router.post("/distance", response_model=DistanceResponse)
async def calculate_distance(
    request: DistanceRequest,
    db: AsyncSession = Depends(get_db)
):
    """Calculate distance between two points."""
    geo_service = GeoService(db)
    
    distance = geo_service.calculate_distance(
        point1=request.from_point.model_dump(),
        point2=request.to_point.model_dump()
    )
    
    # Convert units
    if request.unit == "kilometers":
        distance = distance / 1000
    elif request.unit == "miles":
        distance = distance / 1609.344
    
    return DistanceResponse(
        distance=round(distance, 2),
        unit=request.unit,
        from_point=request.from_point,
        to_point=request.to_point
    )


@router.post("/area")
async def calculate_area(
    geometry: GeoJSONGeometry,
    db: AsyncSession = Depends(get_db)
):
    """Calculate area of a polygon in square meters."""
    geo_service = GeoService(db)
    
    if geometry.type not in ["Polygon", "MultiPolygon"]:
        raise HTTPException(
            status_code=400,
            detail="Area can only be calculated for Polygon or MultiPolygon"
        )
    
    area = geo_service.calculate_area(geometry.model_dump())
    
    return {
        "area_sqm": round(area, 2),
        "area_hectares": round(area / 10000, 4),
        "area_sqkm": round(area / 1000000, 6)
    }


@router.post("/centroid")
async def get_centroid(
    geometry: GeoJSONGeometry,
    db: AsyncSession = Depends(get_db)
):
    """Get centroid of a geometry."""
    geo_service = GeoService(db)
    centroid = geo_service.centroid(geometry.model_dump())
    
    return {
        "type": "Feature",
        "geometry": centroid,
        "properties": {"type": "centroid"}
    }


@router.post("/intersection")
async def get_intersection(
    geometry1: GeoJSONGeometry,
    geometry2: GeoJSONGeometry,
    db: AsyncSession = Depends(get_db)
):
    """Get intersection of two geometries."""
    geo_service = GeoService(db)
    
    result = geo_service.intersection(
        geometry1.model_dump(),
        geometry2.model_dump()
    )
    
    if result is None:
        return {"intersects": False, "geometry": None}
    
    return {
        "intersects": True,
        "geometry": result,
        "area_sqm": geo_service.calculate_area(result) if result.get("type") in ["Polygon", "MultiPolygon"] else None
    }


@router.post("/union")
async def union_geometries(
    geometries: List[GeoJSONGeometry],
    db: AsyncSession = Depends(get_db)
):
    """Union multiple geometries."""
    if len(geometries) < 2:
        raise HTTPException(
            status_code=400,
            detail="At least 2 geometries required for union"
        )
    
    geo_service = GeoService(db)
    result = geo_service.union([g.model_dump() for g in geometries])
    
    return {
        "type": "Feature",
        "geometry": result,
        "properties": {"operation": "union", "input_count": len(geometries)}
    }


@router.post("/simplify")
async def simplify_geometry(
    geometry: GeoJSONGeometry,
    tolerance: float = Query(default=0.001, ge=0.0001, le=1.0),
    db: AsyncSession = Depends(get_db)
):
    """Simplify a geometry."""
    geo_service = GeoService(db)
    simplified = geo_service.simplify(geometry.model_dump(), tolerance)
    
    return {
        "type": "Feature",
        "geometry": simplified,
        "properties": {"tolerance": tolerance}
    }


@router.post("/query")
async def spatial_query(
    request: SpatialQueryRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Perform spatial query on a layer.
    
    Operations: intersects, contains, within, touches
    """
    geo_service = GeoService(db)
    
    try:
        features = await geo_service.spatial_query(
            geojson=request.geometry.model_dump(),
            layer_name=request.layer,
            operation=request.operation,
            limit=request.limit
        )
        
        return {
            "type": "FeatureCollection",
            "features": features,
            "count": len(features),
            "query": {
                "layer": request.layer,
                "operation": request.operation
            }
        }
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.post("/nearest")
async def find_nearest(
    point: GeoJSONGeometry,
    layer: str,
    limit: int = Query(default=10, le=100),
    max_distance: Optional[float] = Query(default=None, description="Max distance in meters"),
    db: AsyncSession = Depends(get_db)
):
    """Find nearest features to a point."""
    if point.type != "Point":
        raise HTTPException(status_code=400, detail="Input must be a Point geometry")
    
    geo_service = GeoService(db)
    
    try:
        features = await geo_service.find_nearest(
            point=point.model_dump(),
            layer_name=layer,
            limit=limit,
            max_distance=max_distance
        )
        
        return {
            "type": "FeatureCollection",
            "features": features,
            "count": len(features)
        }
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))</code></pre>
                </div>
            </div>

            <div class="info-box tip">
                <div class="info-box-title">
                    <span>ğŸ’¡</span>
                    Ù†Ú©ØªÙ‡ Ù…Ù‡Ù…
                </div>
                <div class="info-box-content">
                    <p>
                        Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ø¯Ù‚ÛŒÙ‚ Ù…Ø³Ø§Ø­Øª Ùˆ ÙØ§ØµÙ„Ù‡ Ø¯Ø± Ø§ÛŒØ±Ø§Ù†ØŒ Ø§Ø² <code>EPSG:32640</code> (UTM Zone 40N) Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.
                        Ø§ÛŒÙ† Ø³ÛŒØ³ØªÙ… Ù…Ø®ØªØµØ§Øª Ø¨Ø±Ø§ÛŒ Ù…Ù†Ø§Ø·Ù‚ Ø¨ÛŒÙ† Ø·ÙˆÙ„ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ ÛµÛ´ ØªØ§ Û¶Û° Ø¯Ø±Ø¬Ù‡ Ø´Ø±Ù‚ÛŒ Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³Øª.
                    </p>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 4: AI INTEGRATION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section ai-section" id="ai-integration">
            <div class="section-header">
                <div class="section-icon">ğŸ¤–</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û´</div>
                    <h2 class="section-title">ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h2>
                    <p class="section-subtitle">Object Detection, Segmentation, LLM</p>
                </div>
            </div>

            <h3>ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§ Ø¯Ø± ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h3>

            <p>
                Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ YOLO Ùˆ Detectron2 Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒÙ… Ø§Ø´ÛŒØ§ Ù…Ø®ØªÙ„Ù Ù…Ø§Ù†Ù†Ø¯ 
                Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ØŒ Ø¬Ø§Ø¯Ù‡â€ŒÙ‡Ø§ØŒ ÙˆØ³Ø§ÛŒÙ„ Ù†Ù‚Ù„ÛŒÙ‡ Ùˆ... Ø±Ø§ Ø¯Ø± ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ú©Ù†ÛŒÙ….
            </p>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/ml/object_detection.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from typing import List, Dict, Any, Optional
from pathlib import Path
import numpy as np
from PIL import Image
import io

# YOLOv8
from ultralytics import YOLO

# For geo-referencing detections
from shapely.geometry import box, Point, mapping
import rasterio
from rasterio.transform import rowcol, xy


class ObjectDetector:
    """
    Object detection for satellite/aerial imagery.
    Uses YOLOv8 for detection with geo-referencing support.
    """
    
    # Common classes for satellite imagery
    SATELLITE_CLASSES = [
        "building", "road", "vehicle", "tree", "water",
        "agricultural", "industrial", "residential",
        "parking", "solar_panel", "ship", "airplane"
    ]
    
    def __init__(
        self,
        model_path: str = "yolov8n.pt",
        confidence_threshold: float = 0.5,
        device: str = "auto"
    ):
        """
        Initialize object detector.
        
        Args:
            model_path: Path to YOLO model weights
            confidence_threshold: Min confidence for detections
            device: 'cpu', 'cuda', or 'auto'
        """
        self.model = YOLO(model_path)
        self.confidence_threshold = confidence_threshold
        self.device = device
    
    def detect(
        self,
        image: np.ndarray,
        classes: Optional[List[int]] = None
    ) -> List[Dict[str, Any]]:
        """
        Detect objects in an image.
        
        Args:
            image: Image as numpy array (RGB)
            classes: Filter specific class indices
        
        Returns:
            List of detections with boxes and labels
        """
        results = self.model(
            image,
            conf=self.confidence_threshold,
            classes=classes,
            device=self.device
        )
        
        detections = []
        
        for result in results:
            boxes = result.boxes
            
            for i, box_data in enumerate(boxes):
                x1, y1, x2, y2 = box_data.xyxy[0].cpu().numpy()
                confidence = float(box_data.conf[0])
                class_id = int(box_data.cls[0])
                class_name = result.names[class_id]
                
                detections.append({
                    "id": i,
                    "class_id": class_id,
                    "class_name": class_name,
                    "confidence": round(confidence, 3),
                    "bbox": {
                        "x1": float(x1),
                        "y1": float(y1),
                        "x2": float(x2),
                        "y2": float(y2),
                        "width": float(x2 - x1),
                        "height": float(y2 - y1)
                    },
                    "center": {
                        "x": float((x1 + x2) / 2),
                        "y": float((y1 + y2) / 2)
                    }
                })
        
        return detections
    
    def detect_from_bytes(self, image_bytes: bytes) -> List[Dict[str, Any]]:
        """Detect objects from image bytes."""
        image = Image.open(io.BytesIO(image_bytes))
        image_array = np.array(image)
        return self.detect(image_array)
    
    def detect_with_georef(
        self,
        image_path: str,
        output_srid: int = 4326
    ) -> Dict[str, Any]:
        """
        Detect objects in a georeferenced image (GeoTIFF).
        Returns detections with geographic coordinates.
        
        Args:
            image_path: Path to GeoTIFF file
            output_srid: Output coordinate system
        
        Returns:
            GeoJSON FeatureCollection of detections
        """
        with rasterio.open(image_path) as src:
            # Read image
            image = src.read([1, 2, 3])  # RGB bands
            image = np.moveaxis(image, 0, -1)  # CHW -> HWC
            
            # Get transform
            transform = src.transform
            crs = src.crs
            
            # Detect objects
            detections = self.detect(image)
            
            # Convert to geo features
            features = []
            
            for det in detections:
                # Get pixel coordinates
                x1, y1 = det["bbox"]["x1"], det["bbox"]["y1"]
                x2, y2 = det["bbox"]["x2"], det["bbox"]["y2"]
                
                # Convert to geographic coordinates
                lon1, lat1 = xy(transform, y1, x1)
                lon2, lat2 = xy(transform, y2, x2)
                
                # Create bounding box polygon
                bbox_geom = box(
                    min(lon1, lon2), min(lat1, lat2),
                    max(lon1, lon2), max(lat1, lat2)
                )
                
                # Center point
                center_lon, center_lat = xy(
                    transform,
                    det["center"]["y"],
                    det["center"]["x"]
                )
                
                feature = {
                    "type": "Feature",
                    "geometry": mapping(bbox_geom),
                    "properties": {
                        "class_id": det["class_id"],
                        "class_name": det["class_name"],
                        "confidence": det["confidence"],
                        "center": {
                            "lon": center_lon,
                            "lat": center_lat
                        },
                        "pixel_bbox": det["bbox"]
                    }
                }
                
                features.append(feature)
            
            return {
                "type": "FeatureCollection",
                "features": features,
                "crs": {
                    "type": "name",
                    "properties": {"name": f"EPSG:{output_srid}"}
                },
                "metadata": {
                    "source_crs": str(crs),
                    "detection_count": len(features),
                    "image_size": {
                        "width": src.width,
                        "height": src.height
                    }
                }
            }
    
    def detect_batch(
        self,
        images: List[np.ndarray]
    ) -> List[List[Dict[str, Any]]]:
        """Batch detection for multiple images."""
        results = self.model(
            images,
            conf=self.confidence_threshold,
            device=self.device
        )
        
        all_detections = []
        
        for result in results:
            detections = []
            boxes = result.boxes
            
            for i, box_data in enumerate(boxes):
                x1, y1, x2, y2 = box_data.xyxy[0].cpu().numpy()
                confidence = float(box_data.conf[0])
                class_id = int(box_data.cls[0])
                class_name = result.names[class_id]
                
                detections.append({
                    "class_name": class_name,
                    "confidence": round(confidence, 3),
                    "bbox": [float(x1), float(y1), float(x2), float(y2)]
                })
            
            all_detections.append(detections)
        
        return all_detections


class BuildingDetector(ObjectDetector):
    """Specialized detector for buildings in satellite imagery."""
    
    def __init__(self, model_path: str = "building_detector.pt"):
        super().__init__(model_path)
    
    def detect_buildings(
        self,
        image: np.ndarray,
        min_area: float = 50.0
    ) -> List[Dict[str, Any]]:
        """
        Detect buildings with area filtering.
        
        Args:
            image: Input image
            min_area: Minimum building area in pixels
        """
        detections = self.detect(image)
        
        # Filter by area
        filtered = []
        for det in detections:
            area = det["bbox"]["width"] * det["bbox"]["height"]
            if area >= min_area:
                det["area_pixels"] = area
                filtered.append(det)
        
        return filtered
    
    def estimate_building_footprints(
        self,
        detections: List[Dict[str, Any]],
        pixel_size_m: float = 0.5
    ) -> List[Dict[str, Any]]:
        """
        Estimate building footprint areas.
        
        Args:
            detections: List of building detections
            pixel_size_m: Ground sampling distance (meters/pixel)
        """
        for det in detections:
            area_pixels = det.get("area_pixels", 
                det["bbox"]["width"] * det["bbox"]["height"])
            det["area_sqm"] = area_pixels * (pixel_size_m ** 2)
        
        return detections</code></pre>
                </div>
            </div>

            <h3>Schema Ù‡Ø§ÛŒ AI</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/schemas/ai.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from enum import Enum


class DetectionClass(str, Enum):
    """Supported detection classes."""
    BUILDING = "building"
    ROAD = "road"
    VEHICLE = "vehicle"
    TREE = "tree"
    WATER = "water"
    SHIP = "ship"
    AIRPLANE = "airplane"


class BoundingBox(BaseModel):
    """Bounding box coordinates."""
    x1: float
    y1: float
    x2: float
    y2: float
    width: Optional[float] = None
    height: Optional[float] = None


class Detection(BaseModel):
    """Single object detection result."""
    id: int
    class_id: int
    class_name: str
    confidence: float = Field(..., ge=0, le=1)
    bbox: BoundingBox
    center: Dict[str, float]
    area_sqm: Optional[float] = None


class DetectionResponse(BaseModel):
    """Object detection API response."""
    detections: List[Detection]
    count: int
    image_size: Dict[str, int]
    processing_time_ms: float
    model_name: str


class GeoDetectionResponse(BaseModel):
    """Georeferenced detection response."""
    type: str = "FeatureCollection"
    features: List[Dict[str, Any]]
    metadata: Dict[str, Any]


class SegmentationRequest(BaseModel):
    """Image segmentation request."""
    classes: List[str] = Field(
        default=["building", "road", "vegetation", "water"],
        description="Classes to segment"
    )
    output_format: str = Field(
        default="geojson",
        description="Output format: geojson, mask, or both"
    )


class SegmentationResult(BaseModel):
    """Segmentation result for a single class."""
    class_name: str
    pixel_count: int
    area_sqm: Optional[float] = None
    coverage_percent: float
    geometry: Optional[Dict[str, Any]] = None


class SegmentationResponse(BaseModel):
    """Image segmentation API response."""
    results: List[SegmentationResult]
    total_pixels: int
    processing_time_ms: float


class PredictionRequest(BaseModel):
    """Spatial prediction request."""
    location: Dict[str, float] = Field(
        ...,
        description="Location as {lon, lat}"
    )
    features: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Additional features for prediction"
    )
    model_name: str = Field(
        default="default",
        description="Prediction model to use"
    )


class PredictionResponse(BaseModel):
    """Spatial prediction response."""
    location: Dict[str, float]
    prediction: Any
    confidence: Optional[float] = None
    model_name: str
    features_used: List[str]


class NaturalLanguageGeoQuery(BaseModel):
    """Natural language geographic query."""
    query: str = Field(
        ...,
        description="Natural language query",
        examples=["Find all buildings within 500m of the river"]
    )
    context: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Additional context (current location, etc.)"
    )


class NLGeoQueryResponse(BaseModel):
    """Response for natural language geo query."""
    original_query: str
    interpreted_query: Dict[str, Any]
    sql_query: Optional[str] = None
    results: Optional[Dict[str, Any]] = None
    explanation: str</code></pre>
                </div>
            </div>

            <h3>Ø³Ø±ÙˆÛŒØ³ LLM Ø¨Ø±Ø§ÛŒ Query Ù‡Ø§ÛŒ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">Py</div>
                        <span class="code-filename">app/services/llm_geo_service.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
                    <pre><code class="language-python">from typing import Dict, Any, Optional, List
from langchain_openai import ChatOpenAI
from langchain_community.llms import Ollama
from langchain.prompts import ChatPromptTemplate
from langchain.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field
import json
import re

from app.config import settings


class GeoQueryIntent(BaseModel):
    """Parsed geographic query intent."""
    operation: strØ§Ø¯Ø§Ù…Ù‡ ÙØ§ÛŒÙ„ HTML:

```html
â”‚   â”‚   <span class="file-py">â”œâ”€â”€ session.py</span>
â”‚   â”‚   <span class="file-py">â””â”€â”€ base.py</span>
â”‚   â”‚
â”‚   <span class="folder">â””â”€â”€ utils/</span>
â”‚       <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚       <span class="file-py">â”œâ”€â”€ geo_utils.py</span>
â”‚       <span class="file-py">â””â”€â”€ helpers.py</span>
â”‚
<span class="folder">â”œâ”€â”€ ml_models/</span>                  # Trained models
â”‚   â”œâ”€â”€ object_detection/
â”‚   â”œâ”€â”€ segmentation/
â”‚   â””â”€â”€ prediction/
â”‚
<span class="folder">â”œâ”€â”€ tests/</span>
â”‚   <span class="file-py">â”œâ”€â”€ __init__.py</span>
â”‚   <span class="file-py">â”œâ”€â”€ test_geo.py</span>
â”‚   <span class="file-py">â””â”€â”€ test_ai.py</span>
â”‚
<span class="folder">â”œâ”€â”€ docker/</span>
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ docker-compose.yml
â”‚
<span class="file-json">â”œâ”€â”€ pyproject.toml</span>
<span class="file-json">â”œâ”€â”€ requirements.txt</span>
<span class="file-json">â””â”€â”€ .env.example</span>
</pre>
            </div>

            <h3>Ù†ØµØ¨ Ùˆ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ</h3>

            <div class="steps">
                <div class="step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <div class="step-title">Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ÛŒØ· Ù…Ø¬Ø§Ø²ÛŒ</div>
                        <div class="step-desc">Ø§ÛŒØ¬Ø§Ø¯ Ùˆ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù…Ø­ÛŒØ· Ù…Ø¬Ø§Ø²ÛŒ Python</div>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <div class="step-title">Ù†ØµØ¨ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒâ€ŒÙ‡Ø§</div>
                        <div class="step-desc">Ù†ØµØ¨ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²</div>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <div class="step-title">ØªÙ†Ø¸ÛŒÙ… Ø¯ÛŒØªØ§Ø¨ÛŒØ³</div>
                        <div class="step-desc">Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ PostgreSQL Ø¨Ø§ PostGIS</div>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <div class="step-title">Ø§Ø¬Ø±Ø§ÛŒ Ø³Ø±ÙˆØ±</div>
                        <div class="step-desc">Ø§Ø¬Ø±Ø§ÛŒ FastAPI Ø¨Ø§ uvicorn</div>
                    </div>
                </div>
            </div>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon bash">$</div>
                        <span class="code-filename">Terminal</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-bash"># Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±ÙˆÚ˜Ù‡
mkdir geoai-fastapi && cd geoai-fastapi

# Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ÛŒØ· Ù…Ø¬Ø§Ø²ÛŒ
python -m venv venv
source venv/bin/activate  # Linux/Mac
# ÛŒØ§
.\venv\Scripts\activate  # Windows

# Ù†ØµØ¨ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒâ€ŒÙ‡Ø§
pip install fastapi[all] uvicorn
pip install sqlalchemy geoalchemy2 asyncpg
pip install shapely geopandas rasterio
pip install torch torchvision  # Ø¨Ø±Ø§ÛŒ AI
pip install opencv-python-headless
pip install python-multipart aiofiles
pip install redis celery</code></pre>
                </div>
            </div>

            <h3>ÙØ§ÛŒÙ„ requirements.txt</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon json">ğŸ“„</div>
                        <span class="code-filename">requirements.txt</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-bash"># Core
fastapi==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.3
pydantic-settings==2.1.0

# Database
sqlalchemy==2.0.25
geoalchemy2==0.14.3
asyncpg==0.29.0
alembic==1.13.1

# GeoSpatial
shapely==2.0.2
geopandas==0.14.2
pyproj==3.6.1
rasterio==1.3.9
fiona==1.9.5
geojson==3.1.0

# AI/ML
torch==2.1.2
torchvision==0.16.2
scikit-learn==1.4.0
numpy==1.26.3
pandas==2.1.4

# Computer Vision
opencv-python-headless==4.9.0.80
Pillow==10.2.0

# LLM
langchain==0.1.0
openai==1.7.2

# Utilities
python-multipart==0.0.6
aiofiles==23.2.1
httpx==0.26.0
redis==5.0.1
celery==5.3.6

# Testing
pytest==7.4.4
pytest-asyncio==0.23.3</code></pre>
                </div>
            </div>

            <h3>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾Ø±ÙˆÚ˜Ù‡ (Config)</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/config.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from pydantic_settings import BaseSettings
from functools import lru_cache
from typing import Optional


class Settings(BaseSettings):
    """Application Settings"""
    
    # App
    APP_NAME: str = "GeoAI FastAPI"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = False
    API_V1_PREFIX: str = "/api/v1"
    
    # Database
    DATABASE_URL: str = "postgresql+asyncpg://user:pass@localhost:5432/geoai"
    DATABASE_POOL_SIZE: int = 10
    DATABASE_MAX_OVERFLOW: int = 20
    
    # PostGIS
    POSTGIS_SRID: int = 4326
    
    # Redis
    REDIS_URL: str = "redis://localhost:6379/0"
    CACHE_TTL: int = 3600
    
    # AI/ML
    MODEL_PATH: str = "./ml_models"
    DEVICE: str = "cuda"  # ÛŒØ§ "cpu"
    BATCH_SIZE: int = 32
    
    # Object Storage
    MINIO_ENDPOINT: str = "localhost:9000"
    MINIO_ACCESS_KEY: str = ""
    MINIO_SECRET_KEY: str = ""
    MINIO_BUCKET: str = "geoai"
    
    # OpenAI (for LLM features)
    OPENAI_API_KEY: Optional[str] = None
    
    # Security
    SECRET_KEY: str = "your-secret-key-here"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # CORS
    CORS_ORIGINS: list = ["*"]
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """Get cached settings"""
    return Settings()


settings = get_settings()</code></pre>
                </div>
            </div>

            <h3>ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ (main.py)</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/main.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
import logging

from app.config import settings
from app.api.v1.router import api_router
from app.db.session import engine, init_db

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan events"""
    # Startup
    logger.info("ğŸš€ Starting GeoAI FastAPI...")
    await init_db()
    logger.info("âœ… Database initialized")
    
    # Load ML models
    logger.info("ğŸ¤– Loading ML models...")
    # await load_ml_models()
    logger.info("âœ… ML models loaded")
    
    yield
    
    # Shutdown
    logger.info("ğŸ‘‹ Shutting down...")
    await engine.dispose()


# Create FastAPI app
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="""
    ğŸŒ GeoAI FastAPI - GeoSpatial API with AI capabilities
    
    ## Features
    - ğŸ—ºï¸ GeoSpatial operations (buffer, intersect, union)
    - ğŸ¤– AI-powered analysis (object detection, segmentation)
    - ğŸ“¡ Satellite imagery processing
    - ğŸ” Spatial queries and search
    - ğŸ“Š Analytics and predictions
    """,
    openapi_url=f"{settings.API_V1_PREFIX}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(api_router, prefix=settings.API_V1_PREFIX)


@app.get("/", tags=["Root"])
async def root():
    """Root endpoint"""
    return {
        "message": "Welcome to GeoAI FastAPI! ğŸŒğŸ¤–",
        "docs": "/docs",
        "version": settings.APP_VERSION
    }


@app.get("/health", tags=["Health"])
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": settings.APP_NAME,
        "version": settings.APP_VERSION
    }


# Exception handlers
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    logger.error(f"Global exception: {exc}")
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"}
    )</code></pre>
                </div>
            </div>

            <h3>Docker Compose</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon json">ğŸ³</div>
                        <span class="code-filename">docker/docker-compose.yml</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-yaml">version: '3.9'

services:
  # FastAPI Application
  api:
    build:
      context: ..
      dockerfile: docker/Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://geoai:geoai@db:5432/geoai
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis
    volumes:
      - ../ml_models:/app/ml_models
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]

  # PostgreSQL with PostGIS
  db:
    image: postgis/postgis:16-3.4
    environment:
      POSTGRES_USER: geoai
      POSTGRES_PASSWORD: geoai
      POSTGRES_DB: geoai
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Redis for caching
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # MinIO for object storage
  minio:
    image: minio/minio
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data

  # Martin - Vector Tile Server
  martin:
    image: maplibre/martin
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://geoai:geoai@db:5432/geoai
    depends_on:
      - db

volumes:
  postgres_data:
  redis_data:
  minio_data:</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 5: SATELLITE IMAGERY
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section ai-section" id="satellite">
            <div class="section-header">
                <div class="section-icon">ğŸ›°ï¸</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Ûµ</div>
                    <h2 class="section-title">Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h2>
                    <p class="section-subtitle">Rasterio, NDVI, Cloud Masking</p>
                </div>
            </div>

            <h3>Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/services/satellite.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">import rasterio
from rasterio.io import MemoryFile
from rasterio.warp import calculate_default_transform, reproject, Resampling
from rasterio.mask import mask as rasterio_mask
from rasterio.features import shapes
import numpy as np
from PIL import Image
from typing import Dict, Any, Optional, Tuple, List
from shapely.geometry import shape, mapping, box
import io
import logging

logger = logging.getLogger(__name__)


class SatelliteImageProcessor:
    """
    Satellite imagery processing service
    Supports: Sentinel-2, Landsat, custom GeoTIFF
    """
    
    # Band indices for common satellites
    SENTINEL2_BANDS = {
        'blue': 2, 'green': 3, 'red': 4,
        'nir': 8, 'swir1': 11, 'swir2': 12
    }
    
    LANDSAT8_BANDS = {
        'blue': 2, 'green': 3, 'red': 4,
        'nir': 5, 'swir1': 6, 'swir2': 7
    }
    
    def __init__(self):
        pass
    
    def read_geotiff(self, file_bytes: bytes) -> Dict[str, Any]:
        """Read GeoTIFF and return metadata and data"""
        with MemoryFile(file_bytes) as memfile:
            with memfile.open() as src:
                return {
                    'data': src.read(),
                    'profile': src.profile,
                    'bounds': src.bounds,
                    'crs': str(src.crs),
                    'transform': src.transform,
                    'width': src.width,
                    'height': src.height,
                    'count': src.count,
                    'dtypes': src.dtypes
                }
    
    def calculate_ndvi(
        self,
        red_band: np.ndarray,
        nir_band: np.ndarray
    ) -> np.ndarray:
        """
        Calculate Normalized Difference Vegetation Index
        
        NDVI = (NIR - Red) / (NIR + Red)
        Range: -1 to 1 (higher = more vegetation)
        """
        # Avoid division by zero
        np.seterr(divide='ignore', invalid='ignore')
        
        red = red_band.astype(np.float32)
        nir = nir_band.astype(np.float32)
        
        ndvi = (nir - red) / (nir + red)
        ndvi = np.nan_to_num(ndvi, nan=0.0, posinf=1.0, neginf=-1.0)
        
        return ndvi
    
    def calculate_ndwi(
        self,
        green_band: np.ndarray,
        nir_band: np.ndarray
    ) -> np.ndarray:
        """
        Calculate Normalized Difference Water Index
        
        NDWI = (Green - NIR) / (Green + NIR)
        Higher values indicate water bodies
        """
        np.seterr(divide='ignore', invalid='ignore')
        
        green = green_band.astype(np.float32)
        nir = nir_band.astype(np.float32)
        
        ndwi = (green - nir) / (green + nir)
        ndwi = np.nan_to_num(ndwi, nan=0.0, posinf=1.0, neginf=-1.0)
        
        return ndwi
    
    def calculate_ndbi(
        self,
        swir_band: np.ndarray,
        nir_band: np.ndarray
    ) -> np.ndarray:
        """
        Calculate Normalized Difference Built-up Index
        
        NDBI = (SWIR - NIR) / (SWIR + NIR)
        Higher values indicate built-up areas
        """
        np.seterr(divide='ignore', invalid='ignore')
        
        swir = swir_band.astype(np.float32)
        nir = nir_band.astype(np.float32)
        
        ndbi = (swir - nir) / (swir + nir)
        ndbi = np.nan_to_num(ndbi, nan=0.0, posinf=1.0, neginf=-1.0)
        
        return ndbi
    
    def create_rgb_composite(
        self,
        red: np.ndarray,
        green: np.ndarray,
        blue: np.ndarray,
        percentile_clip: Tuple[int, int] = (2, 98)
    ) -> np.ndarray:
        """Create RGB composite with histogram stretching"""
        
        def stretch_band(band):
            p_low, p_high = np.percentile(band, percentile_clip)
            band = np.clip(band, p_low, p_high)
            band = ((band - p_low) / (p_high - p_low) * 255).astype(np.uint8)
            return band
        
        rgb = np.dstack([
            stretch_band(red),
            stretch_band(green),
            stretch_band(blue)
        ])
        
        return rgb
    
    def create_false_color(
        self,
        nir: np.ndarray,
        red: np.ndarray,
        green: np.ndarray,
        percentile_clip: Tuple[int, int] = (2, 98)
    ) -> np.ndarray:
        """Create false color composite (NIR-R-G) for vegetation analysis"""
        return self.create_rgb_composite(nir, red, green, percentile_clip)
    
    def colorize_index(
        self,
        index: np.ndarray,
        colormap: str = 'ndvi'
    ) -> np.ndarray:
        """Apply colormap to index raster"""
        import matplotlib.pyplot as plt
        
        colormaps = {
            'ndvi': 'RdYlGn',
            'ndwi': 'Blues',
            'ndbi': 'YlOrRd',
            'temperature': 'coolwarm'
        }
        
        cmap = plt.get_cmap(colormaps.get(colormap, 'viridis'))
        
        # Normalize to 0-1
        normalized = (index - index.min()) / (index.max() - index.min())
        
        # Apply colormap
        colored = cmap(normalized)[:, :, :3]  # Remove alpha
        colored = (colored * 255).astype(np.uint8)
        
        return colored
    
    def clip_to_geometry(
        self,
        file_bytes: bytes,
        geometry: Dict[str, Any]
    ) -> bytes:
        """Clip raster to geometry boundary"""
        geom = shape(geometry)
        
        with MemoryFile(file_bytes) as memfile:
            with memfile.open() as src:
                out_image, out_transform = rasterio_mask(
                    src, [geom], crop=True
                )
                out_meta = src.meta.copy()
                
                out_meta.update({
                    "driver": "GTiff",
                    "height": out_image.shape[1],
                    "width": out_image.shape[2],
                    "transform": out_transform
                })
        
        # Write to memory
        output = io.BytesIO()
        with MemoryFile(output) as memfile:
            with memfile.open(**out_meta) as dest:
                dest.write(out_image)
        
        output.seek(0)
        return output.read()
    
    def reproject_raster(
        self,
        file_bytes: bytes,
        dst_crs: str = 'EPSG:4326'
    ) -> bytes:
        """Reproject raster to different CRS"""
        with MemoryFile(file_bytes) as memfile:
            with memfile.open() as src:
                transform, width, height = calculate_default_transform(
                    src.crs, dst_crs, src.width, src.height, *src.bounds
                )
                
                kwargs = src.meta.copy()
                kwargs.update({
                    'crs': dst_crs,
                    'transform': transform,
                    'width': width,
                    'height': height
                })
                
                output = io.BytesIO()
                with MemoryFile(output) as out_memfile:
                    with out_memfile.open(**kwargs) as dst:
                        for i in range(1, src.count + 1):
                            reproject(
                                source=rasterio.band(src, i),
                                destination=rasterio.band(dst, i),
                                src_transform=src.transform,
                                src_crs=src.crs,
                                dst_transform=transform,
                                dst_crs=dst_crs,
                                resampling=Resampling.bilinear
                            )
        
        output.seek(0)
        return output.read()
    
    def get_statistics(
        self,
        band: np.ndarray,
        nodata: Optional[float] = None
    ) -> Dict[str, float]:
        """Calculate band statistics"""
        if nodata is not None:
            band = np.ma.masked_equal(band, nodata)
        
        return {
            'min': float(np.min(band)),
            'max': float(np.max(band)),
            'mean': float(np.mean(band)),
            'std': float(np.std(band)),
            'median': float(np.median(band))
        }
    
    def classify_ndvi(
        self,
        ndvi: np.ndarray
    ) -> Tuple[np.ndarray, Dict[str, int]]:
        """
        Classify NDVI into land cover categories
        
        Returns classified raster and class counts
        """
        classes = {
            'water': (-1.0, 0.0),
            'bare_soil': (0.0, 0.2),
            'sparse_vegetation': (0.2, 0.4),
            'moderate_vegetation': (0.4, 0.6),
            'dense_vegetation': (0.6, 1.0)
        }
        
        classified = np.zeros_like(ndvi, dtype=np.uint8)
        counts = {}
        
        for i, (class_name, (low, high)) in enumerate(classes.items(), 1):
            mask = (ndvi >= low) & (ndvi < high)
            classified[mask] = i
            counts[class_name] = int(np.sum(mask))
        
        return classified, counts
    
    def detect_clouds(
        self,
        blue: np.ndarray,
        threshold: float = 0.3
    ) -> np.ndarray:
        """Simple cloud detection based on brightness"""
        # Normalize
        blue_norm = blue.astype(np.float32)
        if blue_norm.max() > 1:
            blue_norm = blue_norm / blue_norm.max()
        
        cloud_mask = blue_norm > threshold
        return cloud_mask.astype(np.uint8)


# Singleton
_processor: Optional[SatelliteImageProcessor] = None

def get_satellite_processor() -> SatelliteImageProcessor:
    global _processor
    if _processor is None:
        _processor = SatelliteImageProcessor()
    return _processor</code></pre>
                </div>
            </div>

            <h3>API Endpoints Ø¨Ø±Ø§ÛŒ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/api/v1/satellite.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from fastapi import APIRouter, HTTPException, UploadFile, File, Query
from fastapi.responses import StreamingResponse, Response
from typing import Optional, Literal
import io
import numpy as np
from PIL import Image

from app.services.satellite import get_satellite_processor

router = APIRouter(prefix="/satellite", tags=["Satellite Imagery"])


@router.post("/info")
async def get_raster_info(file: UploadFile = File(...)):
    """
    ğŸ“‹ Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙØ§ÛŒÙ„ GeoTIFF
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    info = processor.read_geotiff(contents)
    
    return {
        "filename": file.filename,
        "crs": info['crs'],
        "bounds": {
            "left": info['bounds'].left,
            "bottom": info['bounds'].bottom,
            "right": info['bounds'].right,
            "top": info['bounds'].top
        },
        "size": {
            "width": info['width'],
            "height": info['height']
        },
        "bands": info['count'],
        "dtypes": list(info['dtypes'])
    }


@router.post("/ndvi")
async def calculate_ndvi(
    file: UploadFile = File(...),
    red_band: int = Query(default=4, ge=1, description="Red band number"),
    nir_band: int = Query(default=8, ge=1, description="NIR band number"),
    return_image: bool = True
):
    """
    ğŸŒ¿ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø§Ø®Øµ NDVI
    
    - **red_band**: Ø´Ù…Ø§Ø±Ù‡ Ø¨Ø§Ù†Ø¯ Ù‚Ø±Ù…Ø² (Ù¾ÛŒØ´â€ŒÙØ±Ø¶: 4 Ø¨Ø±Ø§ÛŒ Sentinel-2)
    - **nir_band**: Ø´Ù…Ø§Ø±Ù‡ Ø¨Ø§Ù†Ø¯ NIR (Ù¾ÛŒØ´â€ŒÙØ±Ø¶: 8 Ø¨Ø±Ø§ÛŒ Sentinel-2)
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    
    if red_band > raster['count'] or nir_band > raster['count']:
        raise HTTPException(
            status_code=400,
            detail=f"Band number exceeds available bands ({raster['count']})"
        )
    
    red = raster['data'][red_band - 1]
    nir = raster['data'][nir_band - 1]
    
    ndvi = processor.calculate_ndvi(red, nir)
    stats = processor.get_statistics(ndvi)
    
    if return_image:
        colored = processor.colorize_index(ndvi, 'ndvi')
        img = Image.fromarray(colored)
        
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        
        return StreamingResponse(
            buffer,
            media_type="image/png",
            headers={"X-NDVI-Stats": str(stats)}
        )
    
    return {
        "statistics": stats,
        "classification": processor.classify_ndvi(ndvi)[1]
    }


@router.post("/ndwi")
async def calculate_ndwi(
    file: UploadFile = File(...),
    green_band: int = Query(default=3, ge=1),
    nir_band: int = Query(default=8, ge=1),
    return_image: bool = True
):
    """
    ğŸ’§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø§Ø®Øµ NDWI (ØªØ´Ø®ÛŒØµ Ø¢Ø¨)
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    
    green = raster['data'][green_band - 1]
    nir = raster['data'][nir_band - 1]
    
    ndwi = processor.calculate_ndwi(green, nir)
    stats = processor.get_statistics(ndwi)
    
    if return_image:
        colored = processor.colorize_index(ndwi, 'ndwi')
        img = Image.fromarray(colored)
        
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        
        return StreamingResponse(buffer, media_type="image/png")
    
    return {"statistics": stats}


@router.post("/ndbi")
async def calculate_ndbi(
    file: UploadFile = File(...),
    swir_band: int = Query(default=11, ge=1),
    nir_band: int = Query(default=8, ge=1),
    return_image: bool = True
):
    """
    ğŸ—ï¸ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø§Ø®Øµ NDBI (ØªØ´Ø®ÛŒØµ Ù…Ù†Ø§Ø·Ù‚ Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡)
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    
    swir = raster['data'][swir_band - 1]
    nir = raster['data'][nir_band - 1]
    
    ndbi = processor.calculate_ndbi(swir, nir)
    stats = processor.get_statistics(ndbi)
    
    if return_image:
        colored = processor.colorize_index(ndbi, 'ndbi')
        img = Image.fromarray(colored)
        
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        
        return StreamingResponse(buffer, media_type="image/png")
    
    return {"statistics": stats}


@router.post("/composite")
async def create_composite(
    file: UploadFile = File(...),
    composite_type: Literal["rgb", "false_color", "agriculture"] = "rgb",
    red_band: int = 4,
    green_band: int = 3,
    blue_band: int = 2,
    nir_band: int = 8
):
    """
    ğŸ¨ Ø§ÛŒØ¬Ø§Ø¯ ØªØ±Ú©ÛŒØ¨ Ø±Ù†Ú¯ÛŒ
    
    - **rgb**: ØªØ±Ú©ÛŒØ¨ Ø±Ù†Ú¯ Ø·Ø¨ÛŒØ¹ÛŒ
    - **false_color**: NIR-Red-Green Ø¨Ø±Ø§ÛŒ Ù¾ÙˆØ´Ø´ Ú¯ÛŒØ§Ù‡ÛŒ
    - **agriculture**: SWIR-NIR-Blue Ø¨Ø±Ø§ÛŒ Ú©Ø´Ø§ÙˆØ±Ø²ÛŒ
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    data = raster['data']
    
    if composite_type == "rgb":
        composite = processor.create_rgb_composite(
            data[red_band - 1],
            data[green_band - 1],
            data[blue_band - 1]
        )
    elif composite_type == "false_color":
        composite = processor.create_false_color(
            data[nir_band - 1],
            data[red_band - 1],
            data[green_band - 1]
        )
    else:  # agriculture
        composite = processor.create_rgb_composite(
            data[10],  # SWIR
            data[nir_band - 1],
            data[blue_band - 1]
        )
    
    img = Image.fromarray(composite)
    
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    buffer.seek(0)
    
    return StreamingResponse(buffer, media_type="image/png")


@router.post("/clip")
async def clip_raster(
    file: UploadFile = File(...),
    min_lon: float = Query(...),
    min_lat: float = Query(...),
    max_lon: float = Query(...),
    max_lat: float = Query(...)
):
    """
    âœ‚ï¸ Ø¨Ø±Ø´ ØªØµÙˆÛŒØ± Ø¨Ø§ Ù…Ø³ØªØ·ÛŒÙ„
    """
    from shapely.geometry import box
    
    contents = await file.read()
    processor = get_satellite_processor()
    
    bbox = box(min_lon, min_lat, max_lon, max_lat)
    
    clipped = processor.clip_to_geometry(contents, bbox.__geo_interface__)
    
    return Response(
        content=clipped,
        media_type="image/tiff",
        headers={"Content-Disposition": "attachment; filename=clipped.tif"}
    )


@router.post("/reproject")
async def reproject_raster(
    file: UploadFile = File(...),
    target_crs: str = Query(default="EPSG:4326")
):
    """
    ğŸ”„ ØªØ¨Ø¯ÛŒÙ„ Ø³ÛŒØ³ØªÙ… Ù…Ø®ØªØµØ§Øª
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    reprojected = processor.reproject_raster(contents, target_crs)
    
    return Response(
        content=reprojected,
        media_type="image/tiff",
        headers={"Content-Disposition": f"attachment; filename=reprojected_{target_crs.replace(':', '_')}.tif"}
    )


@router.post("/cloud-mask")
async def detect_clouds(
    file: UploadFile = File(...),
    blue_band: int = Query(default=2, ge=1),
    threshold: float = Query(default=0.3, ge=0, le=1)
):
    """
    â˜ï¸ ØªØ´Ø®ÛŒØµ Ø§Ø¨Ø±
    """
    contents = await file.read()
    processor = get_satellite_processor()
    
    raster = processor.read_geotiff(contents)
    blue = raster['data'][blue_band - 1]
    
    cloud_mask = processor.detect_clouds(blue, threshold)
    
    # Calculate cloud coverage
    total_pixels = cloud_mask.size
    cloud_pixels = np.sum(cloud_mask)
    cloud_percentage = (cloud_pixels / total_pixels) * 100
    
    # Create visualization
    mask_colored = np.zeros((*cloud_mask.shape, 3), dtype=np.uint8)
    mask_colored[cloud_mask == 1] = [255, 255, 255]  # White for clouds
    
    img = Image.fromarray(mask_colored)
    
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    buffer.seek(0)
    
    return StreamingResponse(
        buffer,
        media_type="image/png",
        headers={
            "X-Cloud-Percentage": str(round(cloud_percentage, 2)),
            "X-Cloud-Pixels": str(cloud_pixels)
        }
    )</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 6: PRACTICAL PROJECTS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="projects">
            <div class="section-header">
                <div class="section-icon">ğŸ“¦</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û¶</div>
                    <h2 class="section-title">Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ</h2>
                    <p class="section-subtitle">Ú©Ø§Ø±Ø¨Ø±Ø¯Ù‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ GeoAI</p>
                </div>
            </div>

            <h3>Ù¾Ø±ÙˆÚ˜Ù‡ Û±: Ø³ÛŒØ³ØªÙ… ØªØ´Ø®ÛŒØµ Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ ØºÛŒØ±Ù…Ø¬Ø§Ø²</h3>

            <div class="info-box info">
                <div class="info-box-title">
                    <span>ğŸ—ï¸</span>
                    Ø´Ø±Ø­ Ù¾Ø±ÙˆÚ˜Ù‡
                </div>
                <div class="info-box-content">
                    <p>
                        Ø³ÛŒØ³ØªÙ…ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ø®ÙˆØ¯Ú©Ø§Ø± Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…Ù‚Ø§ÛŒØ³Ù‡ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ
                        Ùˆ Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ù¾Ø±ÙˆØ§Ù†Ù‡ Ø³Ø§Ø®Øª Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ø´Ù‡Ø±Ø¯Ø§Ø±ÛŒ.
                    </p>
                </div>
            </div>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">projects/illegal_building_detector.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from fastapi import APIRouter, UploadFile, File, Depends, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from typing import List, Dict, Any
import numpy as np
from PIL import Image
from shapely.geometry import shape, mapping
from datetime import datetime

from app.api.deps import get_db
from app.ml.object_detection import get_detector
from app.services.geo_service import GeoService
from app.models.geo import Building, AIDetection

router = APIRouter(prefix="/projects/illegal-buildings", tags=["Projects"])


class IllegalBuildingDetector:
    """
    Detect potentially illegal buildings by:
    1. Detecting buildings in satellite imagery
    2. Comparing with registered buildings in database
    3. Flagging new/unregistered buildings
    """
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.detector = get_detector()
        self.geo_service = GeoService()
    
    async def detect_new_buildings(
        self,
        image: Image.Image,
        geo_transform: tuple,
        area_of_interest: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Detect buildings and compare with registered ones
        """
        # Step 1: Detect buildings in image
        detections = self.detector.detect_with_geo_coords(
            image, geo_transform, confidence_threshold=0.7
        )
        
        building_detections = [
            d for d in detections if d['class_name'] == 'building'
        ]
        
        # Step 2: Query registered buildings in area
        aoi_geom = shape(area_of_interest)
        
        query = select(Building).where(
            func.ST_Intersects(
                Building.geometry,
                func.ST_GeomFromText(aoi_geom.wkt, 4326)
            )
        )
        
        result = await self.db.execute(query)
        registered_buildings = result.scalars().all()
        
        # Create registered building geometries
        registered_geoms = []
        for b in registered_buildings:
            from geoalchemy2.shape import to_shape
            registered_geoms.append(to_shape(b.geometry))
        
        # Step 3: Find unregistered buildings
        unregistered = []
        
        for detection in building_detections:
            det_geom = shape(detection['geometry'])
            
            # Check if overlaps with any registered building
            is_registered = False
            for reg_geom in registered_geoms:
                if det_geom.intersects(reg_geom):
                    overlap = det_geom.intersection(reg_geom).area / det_geom.area
                    if overlap > 0.5:  # 50% overlap threshold
                        is_registered = True
                        break
            
            if not is_registered:
                detection['status'] = 'potentially_illegal'
                detection['detected_at'] = datetime.utcnow().isoformat()
                unregistered.append(detection)
        
        return unregistered
    
    async def generate_report(
        self,
        detections: List[Dict[str, Any]],
        area_name: str
    ) -> Dict[str, Any]:
        """Generate detection report"""
        
        total_area = sum(
            shape(d['geometry']).area for d in detections
        )
        
        return {
            "report_date": datetime.utcnow().isoformat(),
            "area_name": area_name,
            "total_detections": len(detections),
            "total_area_sq_degrees": total_area,
            "detections": detections,
            "recommendations": [
                "Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒØ¯Ø§Ù†ÛŒ Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡",
                "Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù¾Ø±ÙˆØ§Ù†Ù‡ Ø³Ø§Ø®Øª Ø§Ø² Ø´Ù‡Ø±Ø¯Ø§Ø±ÛŒ",
                "Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ ØªØµØ§ÙˆÛŒØ± Ù‚Ø¨Ù„ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ¹ÛŒÛŒÙ† ØªØ§Ø±ÛŒØ® Ø³Ø§Ø®Øª"
            ]
        }


@router.post("/detect")
async def detect_illegal_buildings(
    image: UploadFile = File(...),
    min_lon: float = 51.0,
    min_lat: float = 35.0,
    max_lon: float = 52.0,
    max_lat: float = 36.0,
    background_tasks: BackgroundTasks = None,
    db: AsyncSession = Depends(get_db)
):
    """
    ğŸ—ï¸ ØªØ´Ø®ÛŒØµ Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø§Ø­ØªÙ…Ø§Ù„Ø§Ù‹ ØºÛŒØ±Ù…Ø¬Ø§Ø²
    """
    import rasterio
    from rasterio.io import MemoryFile
    
    contents = await image.read()
    
    # Read GeoTIFF
    with MemoryFile(contents) as memfile:
        with memfile.open() as src:
            rgb = np.dstack([src.read(i) for i in [1, 2, 3]])
            if rgb.max() > 255:
                rgb = (rgb / rgb.max() * 255).astype(np.uint8)
            
            img = Image.fromarray(rgb)
            geo_transform = src.transform.to_gdal()
    
    # Area of interest
    from shapely.geometry import box
    aoi = box(min_lon, min_lat, max_lon, max_lat)
    
    # Detect
    detector = IllegalBuildingDetector(db)
    unregistered = await detector.detect_new_buildings(
        img, geo_transform, aoi.__geo_interface__
    )
    
    # Generate report
    report = await detector.generate_report(unregistered, "Ù…Ù†Ø·Ù‚Ù‡ Ù…ÙˆØ±Ø¯ Ø¨Ø±Ø±Ø³ÛŒ")
    
    # Save detections to database in background
    if background_tasks and unregistered:
        background_tasks.add_task(
            save_detections_to_db, db, unregistered
        )
    
    return report


async def save_detections_to_db(db: AsyncSession, detections: List[Dict]):
    """Save detections to database"""
    for det in detections:
        ai_detection = AIDetection(
            source_image="satellite_image",
            model_name="building_detector",
            model_version="1.0",
            detection_class="illegal_building",
            confidence=det['confidence'],
            metadata=det
        )
        db.add(ai_detection)
    await db.commit()</code></pre>
                </div>
            </div>

            <h3>Ù¾Ø±ÙˆÚ˜Ù‡ Û²: Ø³ÛŒØ³ØªÙ… Ù…Ø³ÛŒØ±ÛŒØ§Ø¨ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">projects/smart_routing.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from fastapi import APIRouter, Depends, Query, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field
import heapq
from datetime import datetime
import httpx

from app.api.deps import get_db
from app.schemas.geo import GeoJSONPoint

router = APIRouter(prefix="/projects/routing", tags=["Projects"])


class RouteRequest(BaseModel):
    """Route request model"""
    origin: GeoJSONPoint
    destination: GeoJSONPoint
    waypoints: Optional[List[GeoJSONPoint]] = None
    avoid: Optional[List[str]] = Field(
        default=None,
        description="Features to avoid: traffic, tolls, highways"
    )
    optimize: str = Field(
        default="time",
        description="Optimize for: time, distance, eco"
    )


class RouteStep(BaseModel):
    """Single step in route"""
    instruction: str
    distance_m: float
    duration_s: float
    geometry: Dict[str, Any]


class RouteResponse(BaseModel):
    """Route response model"""
    origin: Dict[str, float]
    destination: Dict[str, float]
    total_distance_km: float
    total_duration_min: float
    steps: List[RouteStep]
    geometry: Dict[str, Any]
    alternatives: Optional[List[Dict]] = None


class SmartRouter:
    """
    AI-enhanced routing service
    Features:
    - Real-time traffic integration
    - ML-based travel time prediction
    - Multi-modal routing
    """
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def find_route(
        self,
        origin: tuple,
        destination: tuple,
        optimize: str = "time"
    ) -> Dict[str, Any]:
        """
        Find optimal route using pgRouting
        """
        # Find nearest nodes
        origin_node = await self._find_nearest_node(origin)
        dest_node = await self._find_nearest_node(destination)
        
        # Cost column based on optimization
        cost_column = {
            "time": "cost_time",
            "distance": "cost_length",
            "eco": "cost_eco"
        }.get(optimize, "cost_time")
        
        # Run Dijkstra
        query = text(f"""
            SELECT 
                seq, node, edge, cost, agg_cost,
                ST_AsGeoJSON(geom) as geometry,
                name, road_type
            FROM pgr_dijkstra(
                'SELECT id, source, target, {cost_column} as cost FROM roads',
                :origin_node,
                :dest_node,
                directed := true
            ) AS route
            JOIN roads ON route.edge = roads.id
        """)
        
        result = await self.db.execute(
            query,
            {"origin_node": origin_node, "dest_node": dest_node}
        )
        rows = result.fetchall()
        
        if not rows:
            raise HTTPException(status_code=404, detail="No route found")
        
        # Build route
        steps = []
        total_distance = 0
        total_duration = 0
        geometries = []
        
        for row in rows:
            import json
            geom = json.loads(row.geometry)
            geometries.append(geom)
            
            step = RouteStep(
                instruction=self._generate_instruction(row.name, row.road_type),
                distance_m=row.cost * 1000 if optimize == "distance" else 0,
                duration_s=row.cost * 60 if optimize == "time" else 0,
                geometry=geom
            )
            steps.append(step)
            total_distance += row.cost
            total_duration += row.cost
        
        # Merge geometries
        from shapely.geometry import shape, LineString
        from shapely.ops import linemerge
        
        lines = [shape(g) for g in geometries if g['type'] == 'LineString']
        merged = linemerge(lines)
        
        return {
            "origin": {"lon": origin[0], "lat": origin[1]},
            "destination": {"lon": destination[0], "lat": destination[1]},
            "total_distance_km": round(total_distance, 2),
            "total_duration_min": round(total_duration, 1),
            "steps": steps,
            "geometry": merged.__geo_interface__
        }
    
    async def _find_nearest_node(self, point: tuple) -> int:
        """Find nearest network node to point"""
        query = text("""
            SELECT id FROM roads_vertices_pgr
            ORDER BY the_geom <-> ST_SetSRID(ST_MakePoint(:lon, :lat), 4326)
            LIMIT 1
        """)
        
        result = await self.db.execute(
            query, {"lon": point[0], "lat": point[1]}
        )
        row = result.fetchone()
        
        if not row:
            raise HTTPException(status_code=404, detail="No network node found")
        
        return row.id
    
    def _generate_instruction(self, name: str, road_type: str) -> str:
        """Generate turn-by-turn instruction"""
        if not name:
            return f"Ø§Ø¯Ø§Ù…Ù‡ Ù…Ø³ÛŒØ± Ø¯Ø± {road_type}"
        return f"Ø­Ø±Ú©Øª Ø¯Ø± {name}"
    
    async def get_traffic_data(self, bbox: tuple) -> Dict[str, Any]:
        """Get real-time traffic data"""
        # This would integrate with traffic API
        # For demo, return mock data
        return {
            "timestamp": datetime.utcnow().isoformat(),
            "congestion_level": "moderate",
            "incidents": []
        }
    
    async def predict_travel_time(
        self,
        origin: tuple,
        destination: tuple,
        departure_time: datetime
    ) -> Dict[str, Any]:
        """
        ML-based travel time prediction
        Considers: historical patterns, weather, events
        """
        # Get base route
        route = await self.find_route(origin, destination)
        
        # Apply time-of-day factor
        hour = departure_time.hour
        
        # Rush hour factors
        if 7 <= hour <= 9 or 17 <= hour <= 19:
            time_factor = 1.5  # 50% longer during rush hour
        elif 22 <= hour or hour <= 5:
            time_factor = 0.8  # 20% faster at night
        else:
            time_factor = 1.0
        
        predicted_duration = route['total_duration_min'] * time_factor
        
        return {
            "base_duration_min": route['total_duration_min'],
            "predicted_duration_min": round(predicted_duration, 1),
            "time_factor": time_factor,
            "confidence": 0.85,
            "factors": {
                "time_of_day": "rush_hour" if time_factor > 1 else "normal",
                "weather": "clear",
                "events": []
            }
        }


@router.post("/find", response_model=RouteResponse)
async def find_route(
    request: RouteRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    ğŸ—ºï¸ ÛŒØ§ÙØªÙ† Ù…Ø³ÛŒØ± Ø¨Ù‡ÛŒÙ†Ù‡
    """
    router_service = SmartRouter(db)
    
    origin = (
        request.origin.coordinates[0],
        request.origin.coordinates[1]
    )
    destination = (
        request.destination.coordinates[0],
        request.destination.coordinates[1]
    )
    
    route = await router_service.find_route(
        origin, destination, request.optimize
    )
    
    return route


@router.post("/predict-time")
async def predict_travel_time(
    origin: GeoJSONPoint,
    destination: GeoJSONPoint,
    departure_time: Optional[datetime] = None,
    db: AsyncSession = Depends(get_db)
):
    """
    â±ï¸ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø²Ù…Ø§Ù† Ø³ÙØ± Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ
    """
    router_service = SmartRouter(db)
    
    if not departure_time:
        departure_time = datetime.utcnow()
    
    prediction = await router_service.predict_travel_time(
        (origin.coordinates[0], origin.coordinates[1]),
        (destination.coordinates[0], destination.coordinates[1]),
        departure_time
    )
    
    return prediction


@router.get("/traffic")
async def get_traffic(
    min_lon: float = Query(...),
    min_lat: float = Query(...),
    max_lon: float = Query(...),
    max_lat: float = Query(...),
    db: AsyncSession = Depends(get_db)
):
    """
    ğŸš¦ Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª ØªØ±Ø§ÙÛŒÚ©
    """
    router_service = SmartRouter(db)
    
    traffic = await router_service.get_traffic_data(
        (min_lon, min_lat, max_lon, max_lat)
    )
    
    return traffic</code></pre>
                </div>
            </div>

            <h3>Ù¾Ø±ÙˆÚ˜Ù‡ Û³: Ø³ÛŒØ³ØªÙ… Ù¾Ø§ÛŒØ´ Ù…Ø­ÛŒØ· Ø²ÛŒØ³Øª</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">projects/environmental_monitoring.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from fastapi import APIRouter, UploadFile, File, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import numpy as np
from PIL import Image

from app.api.deps import get_db
from app.services.satellite import get_satellite_processor
from app.ml.segmentation import get_segmentation

router = APIRouter(prefix="/projects/environment", tags=["Projects"])


class EnvironmentalMonitor:
    """
    Environmental monitoring system using satellite imagery
    
    Features:
    - Vegetation health monitoring (NDVI trends)
    - Water body detection and change
    - Urban sprawl detection
    - Deforestation alerts
    """
    
    def __init__(self):
        self.satellite = get_satellite_processor()
        self.segmentation = get_segmentation()
    
    def analyze_vegetation_health(
        self,
        ndvi_current: np.ndarray,
        ndvi_previous: Optional[np.ndarray] = None
    ) -> Dict[str, Any]:
        """Analyze vegetation health and changes"""
        
        # Current statistics
        current_stats = {
            "mean_ndvi": float(np.mean(ndvi_current)),
            "healthy_vegetation_percent": float(
                np.sum(ndvi_current > 0.4) / ndvi_current.size * 100
            ),
            "stressed_vegetation_percent": float(
                np.sum((ndvi_current > 0.2) & (ndvi_current <= 0.4)) / ndvi_current.size * 100
            ),
            "bare_soil_percent": float(
                np.sum(ndvi_current <= 0.2) / ndvi_current.size * 100
            )
        }
        
        # Change analysis if previous data available
        if ndvi_previous is not None:
            change = ndvi_current - ndvi_previous
            current_stats["change_analysis"] = {
                "mean_change": float(np.mean(change)),
                "improvement_percent": float(
                    np.sum(change > 0.1) / change.size * 100
                ),
                "degradation_percent": float(
                    np.sum(change < -0.1) / change.size * 100
                ),
                "stable_percent": float(
                    np.sum(np.abs(change) <= 0.1) / change.size * 100
                )
            }
            
            # Generate alerts
            if current_stats["change_analysis"]["degradation_percent"] > 10:
                current_stats["alert"] = {
                    "level": "warning",
                    "message": "Ú©Ø§Ù‡Ø´ Ù‚Ø§Ø¨Ù„ ØªÙˆØ¬Ù‡ Ù¾ÙˆØ´Ø´ Ú¯ÛŒØ§Ù‡ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯",
                    "recommendation": "Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ù„Ù„ ØªØ®Ø±ÛŒØ¨ Ùˆ Ø§Ù‚Ø¯Ø§Ù… Ø§ØµÙ„Ø§Ø­ÛŒ"
                }
        
        return current_stats
    
    def detect_water_changes(
        self,
        ndwi_current: np.ndarray,
        ndwi_previous: Optional[np.ndarray] = None,
        threshold: float = 0.3
    ) -> Dict[str, Any]:
        """Detect water body changes"""
        
        water_mask_current = ndwi_current > threshold
        water_percent_current = np.sum(water_mask_current) / water_mask_current.size * 100
        
        result = {
            "water_coverage_percent": float(water_percent_current),
            "water_pixels": int(np.sum(water_mask_current)),
            "total_pixels": int(water_mask_current.size)
        }
        
        if ndwi_previous is not None:
            water_mask_previous = ndwi_previous > threshold
            water_percent_previous = np.sum(water_mask_previous) / water_mask_previous.size * 100
            
            change = water_percent_current - water_percent_previous
            
            result["change_analysis"] = {
                "previous_coverage_percent": float(water_percent_previous),
                "change_percent": float(change),
                "trend": "increasing" if change > 1 else "decreasing" if change < -1 else "stable"
            }
            
            # Drought alert
            if change < -5:
                result["alert"] = {
                    "level": "critical",
                    "message": "Ú©Ø§Ù‡Ø´ Ø´Ø¯ÛŒØ¯ Ù…Ù†Ø§Ø¨Ø¹ Ø¢Ø¨ÛŒ",
                    "recommendation": "Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø®Ø´Ú©Ø³Ø§Ù„ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ù†Ø§Ø¨Ø¹ Ø¢Ø¨"
                }
        
        return result
    
    def detect_urban_expansion(
        self,
        segmentation_current: np.ndarray,
        segmentation_previous: Optional[np.ndarray] = None,
        building_class_id: int = 1
    ) -> Dict[str, Any]:
        """Detect urban expansion"""
        
        urban_mask_current = segmentation_current == building_class_id
        urban_percent_current = np.sum(urban_mask_current) / urban_mask_current.size * 100
        
        result = {
            "urban_coverage_percent": float(urban_percent_current),
            "timestamp": datetime.utcnow().isoformat()
        }
        
        if segmentation_previous is not None:
            urban_mask_previous = segmentation_previous == building_class_id
            urban_percent_previous = np.sum(urban_mask_previous) / urban_mask_previous.size * 100
            
            # Find new urban areas
            new_urban = urban_mask_current & ~urban_mask_previous
            new_urban_percent = np.sum(new_urban) / new_urban.size * 100
            
            result["expansion_analysis"] = {
                "previous_coverage_percent": float(urban_percent_previous),
                "new_urban_percent": float(new_urban_percent),
                "growth_rate": float(
                    (urban_percent_current - urban_percent_previous) / urban_percent_previous * 100
                ) if urban_percent_previous > 0 else 0
            }
        
        return result
    
    def generate_environmental_report(
        self,
        vegetation_analysis: Dict,
        water_analysis: Dict,
        urban_analysis: Dict,
        area_name: str
    ) -> Dict[str, Any]:
        """Generate comprehensive environmental report"""
        
        # Calculate overall health score (0-100)
        health_score = 0
        
        # Vegetation contribution (40%)
        health_score += vegetation_analysis.get("healthy_vegetation_percent", 0) * 0.4
        
        # Water contribution (30%)
        water_score = min(water_analysis.get("water_coverage_percent", 0) * 3, 30)
        health_score += water_score
        
        # Urban balance contribution (30%)
        urban_percent = urban_analysis.get("urban_coverage_percent", 0)
        if urban_percent < 30:
            health_score += 30
        elif urban_percent < 50:
            health_score += 20
        else:
            health_score += 10
        
        # Collect all alerts
        alerts = []
        for analysis in [vegetation_analysis, water_analysis, urban_analysis]:
            if "alert" in analysis:
                alerts.append(analysis["alert"])
        
        return {
            "report_date": datetime.utcnow().isoformat(),
            "area_name": area_name,
            "overall_health_score": round(health_score, 1),
            "health_status": "Ø®ÙˆØ¨" if health_score >= 70 else "Ù…ØªÙˆØ³Ø·" if health_score >= 50 else "Ù†Ú¯Ø±Ø§Ù†â€ŒÚ©Ù†Ù†Ø¯Ù‡",
            "vegetation": vegetation_analysis,
            "water_resources": water_analysis,
            "urbanization": urban_analysis,
            "alerts": alerts,
            "recommendations": self._generate_recommendations(
                vegetation_analysis, water_analysis, urban_analysis
            )
        }
    
    def _generate_recommendations(
        self,
        vegetation: Dict,
        water: Dict,
        urban: Dict
    ) -> List[str]:
        """Generate actionable recommendations"""
        recommendations = []
        
        if vegetation.get("stressed_vegetation_percent", 0) > 20:
            recommendations.append("Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø¢Ø¨ÛŒØ§Ø±ÛŒ Ùˆ Ø³Ù„Ø§Ù…Øª Ø®Ø§Ú© Ø¯Ø± Ù…Ù†Ø§Ø·Ù‚ Ø¨Ø§ Ù¾ÙˆØ´Ø´ Ú¯ÛŒØ§Ù‡ÛŒ Ø¶Ø¹ÛŒÙ")
        
        if water.get("change_analysis", {}).get("trend") == "decreasing":
            recommendations.append("Ù¾Ø§ÛŒØ´ Ù…Ù†Ø§Ø¨Ø¹ Ø¢Ø¨ÛŒ Ùˆ Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ù‡ÛŒÙ†Ù‡ Ø¢Ø¨")
        
        if urban.get("expansion_analysis", {}).get("growth_rate", 0) > 5:
            recommendations.append("Ø¨Ø±Ø±Ø³ÛŒ ØªÙˆØ³Ø¹Ù‡ Ø´Ù‡Ø±ÛŒ Ùˆ ØªØ£Ø«ÛŒØ± Ø¢Ù† Ø¨Ø± Ø§Ú©ÙˆØ³ÛŒØ³ØªÙ… Ù…Ù†Ø·Ù‚Ù‡")
        
        if not recommendations:
            recommendations.append("Ø§Ø¯Ø§Ù…Ù‡ Ù¾Ø§ÛŒØ´ Ø¯ÙˆØ±Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ø­ÙØ¸ ÙˆØ¶Ø¹ÛŒØª Ù…Ø·Ù„ÙˆØ¨")
        
        return recommendations


@router.post("/analyze")
async def analyze_environment(
    current_image: UploadFile = File(..., description="ØªØµÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ ÙØ¹Ù„ÛŒ"),
    previous_image: Optional[UploadFile] = File(None, description="ØªØµÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ Ù‚Ø¨Ù„ÛŒ"),
    area_name: str = Query(default="Ù…Ù†Ø·Ù‚Ù‡ Ù…ÙˆØ±Ø¯ Ø¨Ø±Ø±Ø³ÛŒ"),
    db: AsyncSession = Depends(get_db)
):
    """
    ğŸŒ ØªØ­Ù„ÛŒÙ„ Ø¬Ø§Ù…Ø¹ Ù…Ø­ÛŒØ· Ø²ÛŒØ³Øª
    
    Ø´Ø§Ù…Ù„: Ù¾ÙˆØ´Ø´ Ú¯ÛŒØ§Ù‡ÛŒØŒ Ù…Ù†Ø§Ø¨Ø¹ Ø¢Ø¨ÛŒØŒ ØªÙˆØ³Ø¹Ù‡ Ø´Ù‡Ø±ÛŒ
    """
    import rasterio
    from rasterio.io import MemoryFile
    
    monitor = EnvironmentalMonitor()
    
    # Read current image
    current_contents = await current_image.read()
    
    with MemoryFile(current_contents) as memfile:
        with memfile.open() as src:
            current_data = src.read()
    
    # Calculate indices for current image
    red = current_data[3]  # Band 4
    nir = current_data[7]  # Band 8
    green = current_data[2]  # Band 3
    
    ndvi_current = monitor.satellite.calculate_ndvi(red, nir)
    ndwi_current = monitor.satellite.calculate_ndwi(green, nir)
    
    # Segmentation
    rgb = np.dstack([current_data[3], current_data[2], current_data[1]])
    if rgb.max() > 255:
        rgb = (rgb / rgb.max() * 255).astype(np.uint8)
    
    segmentation_current = monitor.segmentation.segment(Image.fromarray(rgb))
    
    # Process previous image if provided
    ndvi_previous = None
    ndwi_previous = None
    segmentation_previous = None
    
    if previous_image:
        previous_contents = await previous_image.read()
        
        with MemoryFile(previous_contents) as memfile:
            with memfile.open() as src:
                previous_data = src.read()
        
        red_prev = previous_data[3]
        nir_prev = previous_data[7]
        green_prev = previous_data[2]
        
        ndvi_previous = monitor.satellite.calculate_ndvi(red_prev, nir_prev)
        ndwi_previous = monitor.satellite.calculate_ndwi(green_prev, nir_prev)
        
        rgb_prev = np.dstack([previous_data[3], previous_data[2], previous_data[1]])
        if rgb_prev.max() > 255:
            rgb_prev = (rgb_prev / rgb_prev.max() * 255).astype(np.uint8)
        
        segmentation_previous = monitor.segmentation.segment(Image.fromarray(rgb_prev))
    
    # Analyze
    vegetation_analysis = monitor.analyze_vegetation_health(ndvi_current, ndvi_previous)
    water_analysis = monitor.detect_water_changes(ndwi_current, ndwi_previous)
    urban_analysis = monitor.detect_urban_expansion(
        segmentation_current, segmentation_previous
    )
    
    # Generate report
    report = monitor.generate_environmental_report(
        vegetation_analysis,
        water_analysis,
        urban_analysis,
        area_name
    )
    
    return report


@router.post("/deforestation-alert")
async def check_deforestation(
    current_image: UploadFile = File(...),
    baseline_image: UploadFile = File(...),
    threshold_percent: float = Query(default=5.0, ge=1.0, le=50.0)
):
    """
    ğŸŒ² ØªØ´Ø®ÛŒØµ Ø¬Ù†Ú¯Ù„â€ŒØ²Ø¯Ø§ÛŒÛŒ
    
    Ù…Ù‚Ø§ÛŒØ³Ù‡ ØªØµØ§ÙˆÛŒØ± Ùˆ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù…Ù†Ø§Ø·Ù‚ Ø¨Ø§ Ú©Ø§Ù‡Ø´ Ù¾ÙˆØ´Ø´ Ø¬Ù†Ú¯Ù„ÛŒ
    """
    import rasterio
    from rasterio.io import MemoryFile
    
    processor = get_satellite_processor()
    
    # Read images
    current_contents = await current_image.read()
    baseline_contents = await baseline_image.read()
    
    with MemoryFile(current_contents) as memfile:
        with memfile.open() as src:
            current_data = src.read()
            geo_transform = src.transform.to_gdal()
    
    with MemoryFile(baseline_contents) as memfile:
        with memfile.open() as src:
            baseline_data = src.read()
    
    # Calculate NDVI
    ndvi_current = processor.calculate_ndvi(current_data[3], current_data[7])
    ndvi_baseline = processor.calculate_ndvi(baseline_data[3], baseline_data[7])
    
    # Forest mask (NDVI > 0.5 typically indicates forest)
    forest_threshold = 0.5
    forest_current = ndvi_current > forest_threshold
    forest_baseline = ndvi_baseline > forest_threshold
    
    # Deforestation = was forest, now not forest
    deforestation_mask = forest_baseline & ~forest_current
    
    # Calculate statistics
    total_baseline_forest = np.sum(forest_baseline)
    deforested_pixels = np.sum(deforestation_mask)
    deforestation_percent = (deforested_pixels / total_baseline_forest * 100) if total_baseline_forest > 0 else 0
    
    # Generate alert if threshold exceeded
    alert_level = "normal"
    if deforestation_percent >= threshold_percent:
        alert_level = "critical"
    elif deforestation_percent >= threshold_percent / 2:
        alert_level = "warning"
    
    return {
        "analysis_date": datetime.utcnow().isoformat(),
        "baseline_forest_pixels": int(total_baseline_forest),
        "current_forest_pixels": int(np.sum(forest_current)),
        "deforested_pixels": int(deforested_pixels),
        "deforestation_percent": round(deforestation_percent, 2),
        "alert": {
            "level": alert_level,
            "threshold_percent": threshold_percent,
            "exceeded": deforestation_percent >= threshold_percent
        },
        "recommendations": [
            "Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒØ¯Ø§Ù†ÛŒ Ù…Ù†Ø§Ø·Ù‚ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡",
            "ØªØ­Ù„ÛŒÙ„ Ø¹Ù„Ù„ Ø¬Ù†Ú¯Ù„â€ŒØ²Ø¯Ø§ÛŒÛŒ",
            "Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø­ÛŒØ§ÛŒ Ù¾ÙˆØ´Ø´ Ø¬Ù†Ú¯Ù„ÛŒ"
        ] if alert_level != "normal" else ["Ø§Ø¯Ø§Ù…Ù‡ Ù¾Ø§ÛŒØ´ Ø¯ÙˆØ±Ù‡â€ŒØ§ÛŒ"]
    }</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 7: DEPLOYMENT
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="deployment">
            <div class="section-header">
                <div class="section-icon">ğŸš€</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û·</div>
                    <h2 class="section-title">Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ùˆ Production</h2>
                    <p class="section-subtitle">Docker, Kubernetes, Monitoring</p>
                </div>
            </div>

            <h3>Dockerfile Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ´Ø¯Ù‡</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon json">ğŸ³</div>
                        <span class="code-filename">docker/Dockerfile</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-dockerfile"># â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Stage 1: Builder
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FROM python:3.11-slim as builder

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libgdal-dev \
    libgeos-dev \
    libproj-dev \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip wheel --no-cache-dir --no-deps --wheel-dir /app/wheels -r requirements.txt


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Stage 2: Runtime
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FROM python:3.11-slim as runtime

WORKDIR /app

# Install runtime dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    libgdal32 \
    libgeos-c1v5 \
    libproj25 \
    libgl1-mesa-glx \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# Copy wheels and install
COPY --from=builder /app/wheels /wheels
RUN pip install --no-cache /wheels/*

# Copy application
COPY app/ ./app/
COPY ml_models/ ./ml_models/

# Create non-root user
RUN useradd -m -u 1000 appuser && \
    chown -R appuser:appuser /app
USER appuser

# Environment
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PORT=8000

EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import httpx; httpx.get('http://localhost:8000/health')" || exit 1

# Run
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]</code></pre>
                </div>
            </div>

            <h3>Kubernetes Deployment</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon json">â˜¸ï¸</div>
                        <span class="code-filename">k8s/deployment.yaml</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: geoai-api
  labels:
    app: geoai-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: geoai-api
  template:
    metadata:
      labels:
        app: geoai-api
    spec:
      containers:
      - name: geoai-api
        image: geoai-fastapi:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: geoai-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: geoai-secrets
              key: redis-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
            nvidia.com/gpu: 1  # GPU for AI inference
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: ml-models
          mountPath: /app/ml_models
          readOnly: true
      volumes:
      - name: ml-models
        persistentVolumeClaim:
          claimName: ml-models-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: geoai-api-service
spec:
  selector:
    app: geoai-api
  ports:
  - port: 80
    targetPort: 8000
  type: LoadBalancer
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: geoai-api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: geoai-api
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80</code></pre>
                </div>
            </div>

            <h3>Celery Worker Ø¨Ø±Ø§ÛŒ ØªØ³Ú©â€ŒÙ‡Ø§ÛŒ Ø³Ù†Ú¯ÛŒÙ†</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/worker.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from celery import Celery
from celery.signals import worker_ready
import logging

from app.config import settings

logger = logging.getLogger(__name__)

# Create Celery app
celery_app = Celery(
    "geoai_worker",
    broker=settings.REDIS_URL,
    backend=settings.REDIS_URL
)

# Configuration
celery_app.conf.update(
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="UTC",
    enable_utc=True,
    task_track_started=True,
    task_time_limit=3600,  # 1 hour max
    worker_prefetch_multiplier=1,  # For GPU tasks
    task_routes={
        "app.worker.process_satellite_image": {"queue": "gpu"},
        "app.worker.run_object_detection": {"queue": "gpu"},
        "app.worker.run_segmentation": {"queue": "gpu"},
        "app.worker.spatial_analysis": {"queue": "cpu"},
    }
)


@worker_ready.connect
def load_models(**kwargs):
    """Load ML models when worker starts"""
    logger.info("Loading ML models...")
    from app.ml.object_detection import get_detector
    from app.ml.segmentation import get_segmentation
    
    get_detector()
    get_segmentation()
    logger.info("ML models loaded!")


@celery_app.task(bind=True, max_retries=3)
def process_satellite_image(self, image_path: str, operations: list):
    """
    Process satellite image with multiple operations
    """
    try:
        from app.services.satellite import get_satellite_processor
        import rasterio
        
        processor = get_satellite_processor()
        results = {}
        
        with rasterio.open(image_path) as src:
            data = src.read()
            
            for op in operations:
                if op == "ndvi":
                    ndvi = processor.calculate_ndvi(data[3], data[7])
                    results["ndvi"] = processor.get_statistics(ndvi)
                
                elif op == "ndwi":
                    ndwi = processor.calculate_ndwi(data[2], data[7])
                    results["ndwi"] = processor.get_statistics(ndwi)
                
                elif op == "classification":
                    ndvi = processor.calculate_ndvi(data[3], data[7])
                    _, counts = processor.classify_ndvi(ndvi)
                    results["classification"] = counts
        
        return {"status": "success", "results": results}
        
    except Exception as e:
        logger.error(f"Error processing image: {e}")
        self.retry(exc=e, countdown=60)


@celery_app.task(bind=True, max_retries=3)
def run_object_detection(self, image_path: str, confidence: float = 0.5):
    """
    Run object detection on image
    """
    try:
        from app.ml.object_detection import get_detector
        from PIL import Image
        
        detector = get_detector()
        image = Image.open(image_path)
        
        detections = detector.detect(image, confidence_threshold=confidence)
        
        return {
            "status": "success",
            "detections": detections,
            "count": len(detections)
        }
        
    except Exception as e:
        logger.error(f"Error in detection: {e}")
        self.retry(exc=e, countdown=60)


@celery_app.task(bind=True)
def run_segmentation(self, image_path: str):
    """
    Run semantic segmentation on image
    """
    try:
        from app.ml.segmentation import get_segmentation
        from PIL import Image
        import numpy as np
        
        segmentation = get_segmentation()
        image = Image.open(image_path)
        
        mask = segmentation.segment(image)
        stats = segmentation.get_statistics(mask)
        
        return {
            "status": "success",
            "statistics": stats
        }
        
    except Exception as e:
        logger.error(f"Error in segmentation: {e}")
        raise


@celery_app.task
def spatial_analysis(layer_name: str, operation: str, params: dict):
    """
    Run spatial analysis on database layer
    """
    import asyncio
    from app.db.session import async_session
    from app.services.geo_service import GeoService
    
    async def run_analysis():
        async with async_session() as db:
            geo_service = GeoService(db)
            
            if operation == "buffer":
                result = geo_service.buffer(
                    params["geometry"],
                    params["distance"]
                )
            elif operation == "intersection":
                result = geo_service.intersection(
                    params["geometry1"],
                    params["geometry2"]
                )
            else:
                raise ValueError(f"Unknown operation: {operation}")
            
            return result
    
    return asyncio.run(run_analysis())


@celery_app.task
def generate_report(report_type: str, params: dict):
    """
    Generate various reports
    """
    from datetime import datetime
    import json
    
    report = {
        "type": report_type,
        "generated_at": datetime.utcnow().isoformat(),
        "params": params
    }
    
    if report_type == "environmental":
        # Generate environmental report
        report["content"] = {
            "summary": "Environmental analysis report",
            "data": params
        }
    
    elif report_type == "urban":
        # Generate urban analysis report
        report["content"] = {
            "summary": "Urban development report",
            "data": params
        }
    
    # Save report
    report_path = f"/tmp/reports/{report_type}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
    
    import os
    os.makedirs(os.path.dirname(report_path), exist_ok=True)
    
    with open(report_path, 'w') as f:
        json.dump(report, f, indent=2)
    
    return {"status": "success", "report_path": report_path}</code></pre>
                </div>
            </div>

            <h3>Monitoring Ø¨Ø§ Prometheus</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">app/core/monitoring.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">from prometheus_client import Counter, Histogram, Gauge, generate_latest
from fastapi import APIRouter, Response
from functools import wraps
import time

router = APIRouter(tags=["Monitoring"])

# Metrics
REQUEST_COUNT = Counter(
    'geoai_requests_total',
    'Total request count',
    ['method', 'endpoint', 'status']
)

REQUEST_LATENCY = Histogram(
    'geoai_request_latency_seconds',
    'Request latency in seconds',
    ['method', 'endpoint'],
    buckets=[0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 30.0]
)

ACTIVE_REQUESTS = Gauge(
    'geoai_active_requests',
    'Number of active requests'
)

ML_INFERENCE_TIME = Histogram(
    'geoai_ml_inference_seconds',
    'ML model inference time',
    ['model_name'],
    buckets=[0.1, 0.5, 1.0, 2.0, 5.0, 10.0]
)

SPATIAL_OPERATION_TIME = Histogram(
    'geoai_spatial_operation_seconds',
    'Spatial operation time',
    ['operation'],
    buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 5.0]
)

GPU_MEMORY_USAGE = Gauge(
    'geoai_gpu_memory_bytes',
    'GPU memory usage in bytes'
)


def track_request(func):
    """Decorator to track request metrics"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        ACTIVE_REQUESTS.inc()
        start_time = time.time()
        
        try:
            response = await func(*args, **kwargs)
            status = "success"
            return response
        except Exception as e:
            status = "error"
            raise
        finally:
            ACTIVE_REQUESTS.dec()
            duration = time.time() - start_time
            
            REQUEST_COUNT.labels(
                method="POST",
                endpoint=func.__name__,
                status=status
            ).inc()
            
            REQUEST_LATENCY.labels(
                method="POST",
                endpoint=func.__name__
            ).observe(duration)
    
    return wrapper


def track_ml_inference(model_name: str):
    """Decorator to track ML inference time"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            duration = time.time() - start_time
            
            ML_INFERENCE_TIME.labels(model_name=model_name).observe(duration)
            
            return result
        return wrapper
    return decorator


def track_spatial_operation(operation: str):
    """Decorator to track spatial operation time"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            duration = time.time() - start_time
            
            SPATIAL_OPERATION_TIME.labels(operation=operation).observe(duration)
            
            return result
        return wrapper
    return decorator


def update_gpu_metrics():
    """Update GPU memory metrics"""
    try:
        import torch
        if torch.cuda.is_available():
            memory_allocated = torch.cuda.memory_allocated()
            GPU_MEMORY_USAGE.set(memory_allocated)
    except:
        pass


@router.get("/metrics")
async def metrics():
    """Prometheus metrics endpoint"""
    update_gpu_metrics()
    return Response(
        content=generate_latest(),
        media_type="text/plain"
    )</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SECTION 8: BEST PRACTICES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="best-practices">
            <div class="section-header">
                <div class="section-icon">âœ¨</div>
                <div class="section-title-group">
                    <div class="section-number">ÙØµÙ„ Û¸</div>
                    <h2 class="section-title">Ø¨Ù‡ØªØ±ÛŒÙ† Ø´ÛŒÙˆÙ‡â€ŒÙ‡Ø§</h2>
                    <p class="section-subtitle">Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ Ùˆ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ø·Ø±Ø§Ø­ÛŒ</p>
                </div>
            </div>

            <div class="best-practices-grid">
                <div class="practice-card">
                    <div class="practice-icon">ğŸ”’</div>
                    <h4>Ø§Ù…Ù†ÛŒØª</h4>
                    <ul>
                        <li>Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² JWT Ø¨Ø±Ø§ÛŒ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª</li>
                        <li>Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§ÛŒ GeoJSON</li>
                        <li>Ù…Ø­Ø¯ÙˆØ¯Ø³Ø§Ø²ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¢Ù¾Ù„ÙˆØ¯</li>
                        <li>Rate Limiting Ø¨Ø±Ø§ÛŒ API</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <div class="practice-icon">âš¡</div>
                    <h4>Ø¹Ù…Ù„Ú©Ø±Ø¯</h4>
                    <ul>
                        <li>Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Spatial Index Ø¯Ø± PostGIS</li>
                        <li>Cache Ú©Ø±Ø¯Ù† Ù†ØªØ§ÛŒØ¬ Ø¨Ø§ Redis</li>
                        <li>Async/Await Ø¨Ø±Ø§ÛŒ I/O</li>
                        <li>Batch Processing Ø¨Ø±Ø§ÛŒ AI</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <div class="practice-icon">ğŸ“</div>
                    <h4>Ù…Ø¹Ù…Ø§Ø±ÛŒ</h4>
                    <ul>
                        <li>Ø¬Ø¯Ø§Ø³Ø§Ø²ÛŒ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§ (API, Service, Repository)</li>
                        <li>Dependency Injection</li>
                        <li>Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Pydantic Ø¨Ø±Ø§ÛŒ Validation</li>
                        <li>Error Handling ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <div class="practice-icon">ğŸ§ª</div>
                    <h4>ØªØ³Øª</h4>
                    <ul>
                        <li>Unit Test Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§</li>
                        <li>Integration Test Ø¨Ø±Ø§ÛŒ API</li>
                        <li>Test Fixtures Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ GeoJSON</li>
                        <li>Mock Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ø®Ø§Ø±Ø¬ÛŒ</li>
                    </ul>
                </div>
            </div>

            <h3>Ù†Ù…ÙˆÙ†Ù‡ ØªØ³Øª</h3>

            <div class="code-block">
                <div class="code-header">
                    <div class="code-lang">
                        <div class="code-lang-icon python">ğŸ</div>
                        <span class="code-filename">tests/test_geo.py</span>
                    </div>
                    <div class="code-actions">
                        <button class="code-btn" onclick="copyCode(this)">ğŸ“‹ Ú©Ù¾ÛŒ</button>
                    </div>
                </div>
                <div class="code-body">
<pre><code class="language-python">import pytest
from httpx import AsyncClient
from app.main import app
from app.services.geo_service import GeoService


# Fixtures
@pytest.fixture
def sample_point():
    return {
        "type": "Point",
        "coordinates": [51.389, 35.689]
    }


@pytest.fixture
def sample_polygon():
    return {
        "type": "Polygon",
        "coordinates": [[[51.0, 35.0], [52.0, 35.0], [52.0, 36.0], [51.0, 36.0], [51.0, 35.0]]]
    }


# Unit Tests
class TestGeoService:
    
    def test_buffer_point(self, sample_point):
        """Test buffer operation on point"""
        result = GeoService.buffer(sample_point, 1000)
        
        assert result["type"] == "Polygon"
        assert len(result["coordinates"]) > 0
    
    def test_calculate_area(self, sample_polygon):
        """Test area calculation"""
        result = GeoService.calculate_area(sample_polygon)
        
        assert result.area_sq_meters > 0
        assert result.area_sq_kilometers > 0
        assert result.area_hectares > 0
    
    def test_calculate_distance(self):
        """Test distance calculation"""
        point1 = {"type": "Point", "coordinates": [51.389, 35.689]}
        point2 = {"type": "Point", "coordinates": [51.489, 35.789]}
        
        result = GeoService.calculate_distance(point1, point2)
        
        assert result.distance_meters > 0
        assert result.distance_kilometers == result.distance_meters / 1000
    
    def test_intersects(self, sample_polygon):
        """Test intersection check"""
        point_inside = {"type": "Point", "coordinates": [51.5, 35.5]}
        point_outside = {"type": "Point", "coordinates": [50.0, 34.0]}
        
        assert GeoService.intersects(sample_polygon, point_inside) == True
        assert GeoService.intersects(sample_polygon, point_outside) == False


# Integration Tests
@pytest.mark.asyncio
class TestGeoAPI:
    
    async def test_buffer_endpoint(self, sample_point):
        """Test buffer API endpoint"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post(
                "/api/v1/geo/buffer",
                json={
                    "geometry": sample_point,
                    "distance": 500,
                    "resolution": 16
                }
            )
        
        assert response.status_code == 200
        data = response.json()
        assert data["type"] == "Feature"
        assert data["geometry"]["type"] == "Polygon"
    
    async def test_area_endpoint(self, sample_polygon):
        """Test area calculation endpoint"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post(
                "/api/v1/geo/area",
                json=sample_polygon
            )
        
        assert response.status_code == 200
        data = response.json()
        assert "area_sq_meters" in data
    
    async def test_invalid_geometry(self):
        """Test error handling for invalid geometry"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post(
                "/api/v1/geo/area",
                json={"type": "Point", "coordinates": [51.0, 35.0]}
            )
        
        assert response.status_code == 400</code></pre>
                </div>
            </div>
        </section>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             SUMMARY
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <section class="section" id="summary">
            <div class="section-header">
                <div class="section-icon">ğŸ“‹</div>
                <div class="section-title-group">
                    <div class="section-number">Ø®Ù„Ø§ØµÙ‡</div>
                    <h2 class="section-title">Ø¬Ù…Ø¹â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ Ù…Ù†Ø§Ø¨Ø¹</h2>
                    <p class="section-subtitle">Ø¢Ù†Ú†Ù‡ Ø¢Ù…ÙˆØ®ØªÛŒÙ… Ùˆ Ú¯Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ø¨Ø¹Ø¯ÛŒ</p>
                </div>
            </div>

            <div class="summary-grid">
                <div class="summary-card">
                    <h4>ğŸ—ºï¸ GeoSpatial</h4>
                    <ul>
                        <li>PostGIS Ùˆ GeoAlchemy2</li>
                        <li>Shapely Ø¨Ø±Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù‡Ù†Ø¯Ø³ÛŒ</li>
                        <li>GeoJSON Ùˆ Pydantic</li>
                        <li>Spatial Queries</li>
                    </ul>
                </div>

                <div class="summary-card">
                    <h4>ğŸ¤– Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h4>
                    <ul>
                        <li>Object Detection (YOLO, Faster R-CNN)</li>
                        <li>Semantic Segmentation (DeepLab)</li>
                        <li>LLM Ø¨Ø±Ø§ÛŒ Ú©ÙˆØ¦Ø±ÛŒ Ø·Ø¨ÛŒØ¹ÛŒ</li>
                        <li>Change Detection</li>
                    </ul>
                </div>

                <div class="summary-card">
                    <h4>ğŸ›°ï¸ ØªØµØ§ÙˆÛŒØ± Ù…Ø§Ù‡ÙˆØ§Ø±Ù‡â€ŒØ§ÛŒ</h4>
                    <ul>
                        <li>Rasterio Ùˆ GeoTIFF</li>
                        <li>Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ NDVI, NDWI, NDBI</li>
                        <li>ØªØ±Ú©ÛŒØ¨â€ŒÙ‡Ø§ÛŒ Ø±Ù†Ú¯ÛŒ</li>
                        <li>Cloud Masking</li>
                    </ul>
                </div>

                <div class="summary-card">
                    <h4>ğŸš€ Production</h4>
                    <ul>
                        <li>Docker Ùˆ Kubernetes</li>
                        <li>Celery Ø¨Ø±Ø§ÛŒ ØªØ³Ú©â€ŒÙ‡Ø§ÛŒ Ø³Ù†Ú¯ÛŒÙ†</li>
                        <li>Monitoring Ø¨Ø§ Prometheus</li>
                        <li>Auto-scaling</li>
                    </ul>
                </div>
            </div>

            <h3>Ù…Ù†Ø§Ø¨Ø¹ Ù…ÙÛŒØ¯</h3>

            <div class="resources-list">
                <div class="resource-item">
                    <span class="resource-icon">ğŸ“š</span>
                    <div class="resource-content">
                        <a href="https://fastapi.tiangolo.com/" target="_blank">FastAPI Documentation</a>
                        <p>Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø±Ø³Ù…ÛŒ FastAPI</p>
                    </div>
                </div>

                <div class="resource-item">
                    <span class="resource-icon">ğŸ—ºï¸</span>
                    <div class="resource-content">
                        <a href="https://postgis.net/documentation/" target="_blank">PostGIS Documentation</a>
                        <p>Ù…Ø³ØªÙ†Ø¯Ø§Øª PostGIS</p>
                    </div>
                </div>

                <div class="resource-item">
                    <span class="resource-icon">ğŸ”·</span>
                    <div class="resource-content">
                        <a href="https://shapely.readthedocs.io/" target="_blank">Shapely Documentation</a>
                        <p>Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Ø¹Ù…Ù„ÛŒØ§Øª Ù‡Ù†Ø¯Ø³ÛŒ</p>
                    </div>
                </div>

                <div class="resource-item">
                    <span class="resource-icon">ğŸ›°ï¸</span>
                    <div class="resource-content">
                        <a href="https://rasterio.readthedocs.io/" target="_blank">Rasterio Documentation</a>
                        <p>Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø±Ø³ØªØ±ÛŒ</p>
                    </div>
                </div>

                <div class="resource-item">
                    <span class="resource-icon">ğŸ¤–</span>
                    <div class="resource-content">
                        <a href="https://pytorch.org/tutorials/" target="_blank">PyTorch Tutorials</a>
                        <p>Ø¢Ù…ÙˆØ²Ø´â€ŒÙ‡Ø§ÛŒ PyTorch</p>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         FOOTER
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>ğŸŒ GeoAI FastAPI Tutorial</h4>
                <p>Ø¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹ ØªÙˆØ³Ø¹Ù‡ API Ù‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</p>
            </div>
            <div class="footer-section">
                <h4>ØªÚ©Ù†ÙˆÙ„ÙˆÚ˜ÛŒâ€ŒÙ‡Ø§</h4>
                <div class="tech-tags">
                    <span class="tech-tag">FastAPI</span>
                    <span class="tech-tag">PostGIS</span>
                    <span class="tech-tag">PyTorch</span>
                    <span class="tech-tag">Shapely</span>
                    <span class="tech-tag">Rasterio</span>
                </div>
            </div>
            <div class="footer-section">
                <h4>Ù†Ø³Ø®Ù‡</h4>
                <p>v1.0.0 - Ø¯ÛŒ Û±Û´Û°Û´</p>
            </div>
        </div>
        <div class="footer-bottom">
            <p>Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡ Ø¨Ø§ â¤ï¸ Ø¨Ø±Ø§ÛŒ Ø¬Ø§Ù…Ø¹Ù‡ GIS Ø§ÛŒØ±Ø§Ù†</p>
        </div>
    </footer>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         SCRIPTS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/dockerfile.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>
    
    <script>
        // Initialize syntax highlighting
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });

        // Copy code function
        function copyCode(button) {
            const codeBlock = button.closest('.code-block');
            const code = codeBlock.querySelector('code').textContent;
            
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.textContent;
                button.textContent = 'âœ… Ú©Ù¾ÛŒ Ø´Ø¯!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                button.textContent = 'âŒ Ø®Ø·Ø§';
            });
        }

        // Smooth scroll for navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Active section highlighting
        const sections = document.querySelectorAll('.section');
        const navLinks = document.querySelectorAll('.nav-link');

        const observerOptions = {
            root: null,
            rootMargin: '-20% 0px -80% 0px',
            threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    
                    navLinks.forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === `#${id}`) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }, observerOptions);

        sections.forEach(section => {
            observer.observe(section);
        });

        // Progress bar
        const progressBar = document.createElement('div');
        progressBar.className = 'reading-progress';
        progressBar.innerHTML = '<div class="reading-progress-bar"></div>';
        document.body.appendChild(progressBar);

        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            
            document.querySelector('.reading-progress-bar').style.width = scrolled + '%';
        });

        // Theme toggle (optional)
        function toggleTheme() {
            document.body.classList.toggle('dark-theme');
            localStorage.setItem('theme', document.body.classList.contains('dark-theme') ? 'dark' : 'light');
        }

        // Load saved theme
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-theme');
        }

        // Back to top button
        const backToTop = document.createElement('button');
        backToTop.className = 'back-to-top';
        backToTop.innerHTML = 'â¬†ï¸';
        backToTop.title = 'Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø¨Ø§Ù„Ø§';
        document.body.appendChild(backToTop);

        backToTop.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        window.addEventListener('scroll', () => {
            if (window.scrollY > 500) {
                backToTop.classList.add('visible');
            } else {
                backToTop.classList.remove('visible');
            }
        });

        // Print-friendly
        window.addEventListener('beforeprint', () => {
            document.querySelectorAll('.code-block').forEach(block => {
                block.style.maxHeight = 'none';
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + K for search (placeholder)
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                console.log('Search functionality can be added here');
            }
            
            // Escape to close modals
            if (e.key === 'Escape') {
                // Close any open modals
            }
        });

        // Code block line numbers (optional enhancement)
        document.querySelectorAll('pre code').forEach((block) => {
            const lines = block.innerHTML.split('\n');
            if (lines.length > 3) {
                // Could add line numbers here if needed
            }
        });

        // Lazy loading for images
        if ('IntersectionObserver' in window) {
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                        }
                        observer.unobserve(img);
                    }
                });
            });

            document.querySelectorAll('img[data-src]').forEach(img => {
                imageObserver.observe(img);
            });
        }

        // Console welcome message
        console.log('%cğŸŒ GeoAI FastAPI Tutorial', 'font-size: 24px; font-weight: bold; color: #059669;');
        console.log('%cØ¢Ù…ÙˆØ²Ø´ Ø¬Ø§Ù…Ø¹ ØªÙˆØ³Ø¹Ù‡ API Ù‡Ø§ÛŒ Ù…Ú©Ø§Ù†ÛŒ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ', 'font-size: 14px; color: #6b7280;');
        console.log('%câ­ Star us on GitHub!', 'font-size: 12px; color: #3b82f6;');
    </script>

    <!-- Additional Styles for new elements -->
    <style>
        /* Reading Progress Bar */
        .reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(5, 150, 105, 0.2);
            z-index: 10000;
        }

        .reading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #059669, #10b981, #34d399);
            width: 0%;
            transition: width 0.1s ease;
        }

        /* Back to Top Button */
        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #059669, #10b981);
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(5, 150, 105, 0.4);
            z-index: 1000;
        }

        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .back-to-top:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(5, 150, 105, 0.5);
        }

        /* Summary Grid */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .summary-card {
            background: linear-gradient(135deg, #f0fdf4, #dcfce7);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #bbf7d0;
        }

        .summary-card h4 {
            color: #059669;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .summary-card ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .summary-card li {
            padding: 0.5rem 0;
            padding-right: 1.5rem;
            position: relative;
            color: #374151;
            border-bottom: 1px dashed #d1fae5;
        }

        .summary-card li:last-child {
            border-bottom: none;
        }

        .summary-card li::before {
            content: 'âœ“';
            position: absolute;
            right: 0;
            color: #10b981;
            font-weight: bold;
        }

        /* Resources List */
        .resources-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 2rem 0;
        }

        .resource-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 1.5rem;
            background: white;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .resource-item:hover {
            border-color: #10b981;
            box-shadow: 0 4px 12px rgba(5, 150, 105, 0.15);
            transform: translateX(-5px);
        }

        .resource-icon {
            font-size: 2rem;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0fdf4;
            border-radius: 10px;
        }

        .resource-content {
            flex: 1;
        }

        .resource-content a {
            color: #059669;
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .resource-content a:hover {
            text-decoration: underline;
        }

        .resource-content p {
            margin: 0.25rem 0 0 0;
            color: #6b7280;
            font-size: 0.9rem;
        }

        /* Best Practices Grid */
        .best-practices-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .practice-card {
            background: white;
            border-radius: 16px;
            padding: 1.5rem;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .practice-card:hover {
            border-color: #10b981;
            box-shadow: 0 8px 25px rgba(5, 150, 105, 0.15);
            transform: translateY(-5px);
        }

        .practice-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .practice-card h4 {
            color: #1f2937;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .practice-card ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .practice-card li {
            padding: 0.5rem 0;
            padding-right: 1.2rem;
            position: relative;
            color: #4b5563;
            font-size: 0.95rem;
        }

        .practice-card li::before {
            content: 'â€¢';
            position: absolute;
            right: 0;
            color: #10b981;
            font-weight: bold;
        }

        /* Footer Styles */
        .footer {
            background: linear-gradient(135deg, #064e3b, #065f46);
            color: white;
            padding: 3rem 2rem 1rem;
            margin-top: 4rem;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
        }

        .footer-section h4 {
            color: #34d399;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .footer-section p {
            color: #a7f3d0;
            line-height: 1.6;
        }

        .tech-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .tech-tag {
            background: rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .footer-bottom {
            text-align: center;
            padding-top: 2rem;
            margin-top: 2rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .footer-bottom p {
            color: #a7f3d0;
        }

        /* Dark Theme (Optional) */
        .dark-theme {
            --bg-color: #111827;
            --text-color: #f3f4f6;
            --card-bg: #1f2937;
            --border-color: #374151;
        }

        .dark-theme body {
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .dark-theme .section {
            background: var(--card-bg);
            border-color: var(--border-color);
        }

        .dark-theme .code-block {
            background: #0d1117;
        }

        .dark-theme .info-box {
            background: var(--card-bg);
            border-color: var(--border-color);
        }

        /* Print Styles */
        @media print {
            .sidebar,
            .back-to-top,
            .reading-progress,
            .code-actions {
                display: none !important;
            }

            .main-content {
                margin: 0;
                padding: 1rem;
            }

            .section {
                break-inside: avoid;
                page-break-inside: avoid;
            }

            .code-block {
                max-height: none !important;
                overflow: visible !important;
            }

            body {
                font-size: 12pt;
            }

            a {
                text-decoration: none;
                color: inherit;
            }

            a[href]::after {
                content: " (" attr(href) ")";
                font-size: 0.8em;
                color: #666;
            }
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .summary-grid,
            .best-practices-grid {
                grid-template-columns: 1fr;
            }

            .footer-content {
                grid-template-columns: 1fr;
                text-align: center;
            }

            .tech-tags {
                justify-content: center;
            }

            .back-to-top {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
            }

            .resource-item {
                flex-direction: column;
                text-align: center;
            }
        }

        /* Animation for section entry */
        .section {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.6s ease forwards;
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section:nth-child(1) { animation-delay: 0.1s; }
        .section:nth-child(2) { animation-delay: 0.2s; }
        .section:nth-child(3) { animation-delay: 0.3s; }
        .section:nth-child(4) { animation-delay: 0.4s; }
        .section:nth-child(5) { animation-delay: 0.5s; }
        .section:nth-child(6) { animation-delay: 0.6s; }
        .section:nth-child(7) { animation-delay: 0.7s; }
        .section:nth-child(8) { animation-delay: 0.8s; }

        /* Tooltip styles */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1f2937;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
            bottom: calc(100% + 10px);
        }

        /* Code highlight improvements */
        .hljs {
            background: transparent !important;
            padding: 0 !important;
        }

        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em !important;
        }

        /* Custom scrollbar for code blocks */
        .code-body::-webkit-scrollbar {
            height: 8px;
        }

        .code-body::-webkit-scrollbar-track {
            background: #1e293b;
            border-radius: 4px;
        }

        .code-body::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        .code-body::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Selection styling */
        ::selection {
            background: #10b981;
            color: white;
        }

        ::-moz-selection {
            background: #10b981;
            color: white;
        }

        /* Focus styles for accessibility */
        a:focus,
        button:focus {
            outline: 2px solid #10b981;
            outline-offset: 2px;
        }

        /* Skip to content link for accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #059669;
            color: white;
            padding: 8px 16px;
            z-index: 10001;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
        }
    </style>

    <!-- Skip to content link -->
    <a href="#intro" class="skip-link">Ø±ÙØªÙ† Ø¨Ù‡ Ù…Ø­ØªÙˆØ§ÛŒ Ø§ØµÙ„ÛŒ</a>

</body>
</html>

