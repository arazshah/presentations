<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>پیاده‌سازی سیستم احراز هویت و کنترل دسترسی مکانی - Django & DRF</title>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Vazirmatn', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #2e7d32 0%, #43a047 100%);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .section {
            background: white;
            margin: 30px 0;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            overflow: hidden;
            border-top: 5px solid #43a047;
        }

        .section-header {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 25px;
            border-bottom: 2px solid #e0e0e0;
        }

        .section-header h2 {
            color: #2e7d32;
            font-size: 1.8em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .section-header .icon {
            background: #43a047;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 15px;
            font-size: 1.2em;
        }

        .section-content {
            padding: 30px;
        }

        .code-container {
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .code-header {
            background: #2d3748;
            color: white;
            padding: 15px 20px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .code-header .file-name {
            font-family: 'Courier New', monospace;
            color: #68d391;
        }

        .code-header .copy-btn {
            background: #43a047;
            border: none;
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .code-header .copy-btn:hover {
            background: #2e7d32;
        }

        pre {
            margin: 0;
            background: #1a202c !important;
            padding: 20px;
            overflow-x: auto;
            font-size: 14px;
            line-height: 1.5;
        }

        .explanation {
            background: #f8f9fa;
            border-right: 4px solid #43a047;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
        }

        .explanation h4 {
            color: #2e7d32;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .file-structure {
            background: #263238;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            line-height: 1.8;
        }

        .file-structure .folder {
            color: #ffd54f;
        }

        .file-structure .file {
            color: #81c784;
        }

        .file-structure .comment {
            color: #90a4ae;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .feature-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .feature-card:hover {
            border-color: #43a047;
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(67, 160, 71, 0.2);
        }

        .feature-card h3 {
            color: #2e7d32;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .feature-card .feature-icon {
            background: #43a047;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            font-size: 0.9em;
        }

        .steps {
            counter-reset: step-counter;
        }

        .step {
            counter-increment: step-counter;
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border-right: 5px solid #43a047;
            position: relative;
        }

        .step::before {
            content: counter(step-counter);
            position: absolute;
            right: -15px;
            top: 20px;
            background: #43a047;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .step h3 {
            color: #2e7d32;
            margin-bottom: 15px;
            margin-right: 20px;
        }

        .warning {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            color: #e65100;
        }

        .success {
            background: #e8f5e9;
            border: 2px solid #43a047;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            color: #1b5e20;
        }

        .info {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            color: #0d47a1;
        }

        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        th {
            background: #43a047;
            color: white;
            padding: 15px;
            text-align: right;
            font-weight: 600;
        }

        td {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .navigation-menu {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            padding: 10px;
            z-index: 1000;
        }

        .nav-item {
            display: block;
            padding: 10px 15px;
            color: #666;
            text-decoration: none;
            border-radius: 5px;
            margin: 5px 0;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .nav-item:hover,
        .nav-item.active {
            background: #43a047;
            color: white;
        }

        @media (max-width: 768px) {
            .navigation-menu {
                display: none;
            }
            
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .feature-grid {
                grid-template-columns: 1fr;
            }
            
            pre {
                font-size: 12px;
            }
        }

        .highlight {
            background: #fff59d;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <nav class="navigation-menu">
        <a href="#structure" class="nav-item">ساختار پروژه</a>
        <a href="#models" class="nav-item">مدل‌ها</a>
        <a href="#serializers" class="nav-item">سریالایزرها</a>
        <a href="#views" class="nav-item">ویوها</a>
        <a href="#permissions" class="nav-item">مجوزها</a>
        <a href="#urls" class="nav-item">URLها</a>
        <a href="#settings" class="nav-item">تنظیمات</a>
        <a href="#deployment" class="nav-item">استقرار</a>
    </nav>

    <div class="container">
        <div class="header">
            <h1>🏗️ پیاده‌سازی سیستم احراز هویت و کنترل دسترسی مکانی</h1>
            <p>راهنمای کامل توسعه با Django & Django REST Framework</p>
        </div>

        <!-- ساختار پروژه -->
        <div class="section" id="structure">
            <div class="section-header">
                <h2><span class="icon">📁</span>ساختار پروژه</h2>
            </div>
            <div class="section-content">
                <div class="explanation">
                    <h4>ساختار پیشنهادی پروژه Django</h4>
                    <p>این ساختار بر اساس بهترین شیوه‌های Django طراحی شده و امکان مقیاس‌پذیری بالا را فراهم می‌کند.</p>
                </div>

                <div class="file-structure">
location_auth_system/
├── manage.py
├── requirements.txt
├── .env                          <span class="comment"># متغیرهای محیطی</span>
├── location_auth_system/
│   ├── __init__.py
│   ├── settings/
│   │   ├── __init__.py
│   │   ├── base.py              <span class="comment"># تنظیمات پایه</span>
│   │   ├── development.py       <span class="comment"># تنظیمات توسعه</span>
│   │   └── production.py        <span class="comment"># تنظیمات تولید</span>
│   ├── urls.py
│   └── wsgi.py
├── apps/
│   ├── __init__.py
│   ├── authentication/          <span class="comment"># احراز هویت</span>
│   │   ├── __init__.py
│   │   ├── models.py
│   │   ├── serializers.py
│   │   ├── views.py
│   │   ├── permissions.py
│   │   └── urls.py
│   ├── locations/               <span class="comment"># مدیریت مکان‌ها</span>
│   │   ├── __init__.py
│   │   ├── models.py
│   │   ├── serializers.py
│   │   ├── views.py
│   │   ├── permissions.py
│   │   └── urls.py
│   └── audit/                   <span class="comment"># لاگ‌های امنیتی</span>
│       ├── __init__.py
│       ├── models.py
│       ├── serializers.py
│       ├── views.py
│       └── urls.py
├── static/
├── media/
└── templates/
                </div>

                <div class="steps">
                    <div class="step">
                        <h3>ایجاد پروژه Django</h3>
                        <div class="code-container">
                            <div class="code-header">
                                <span class="file-name">Terminal Commands</span>
                                <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                            </div>
                            <pre><code class="language-bash"># ایجاد محیط مجازی
python -m venv location_auth_env
source location_auth_env/bin/activate  # Linux/Mac
# location_auth_env\Scripts\activate  # Windows

# نصب Django و پکیج‌های مورد نیاز
pip install django djangorestframework
pip install django-cors-headers
pip install djangorestframework-simplejwt
pip install psycopg2-binary  # برای PostgreSQL
pip install redis
pip install celery

# ایجاد پروژه
django-admin startproject location_auth_system
cd location_auth_system

# ایجاد اپلیکیشن‌ها
python manage.py startapp authentication
python manage.py startapp locations
python manage.py startapp audit</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- مدل‌ها -->
        <div class="section" id="models">
            <div class="section-header">
                <h2><span class="icon">🗃️</span>مدل‌های Django</h2>
            </div>
            <div class="section-content">
                <div class="explanation">
                    <h4>طراحی مدل‌های پایگاه داده</h4>
                    <p>مدل‌های زیر برای مدیریت کاربران، مکان‌ها و دسترسی‌ها طراحی شده‌اند.</p>
                </div>

                <!-- مدل کاربر -->
                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">apps/authentication/models.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from django.contrib.auth.models import AbstractUser
from django.contrib.gis.db import models
from django.core.validators import RegexValidator
import uuid


class CustomUser(AbstractUser):
    """مدل کاربر سفارشی با قابلیت‌های اضافی"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # اطلاعات شخصی
    national_code = models.CharField(
        max_length=10,
        unique=True,
        validators=[RegexValidator(r'^\d{10}$', 'کد ملی باید 10 رقم باشد')]
    )
    phone_number = models.CharField(
        max_length=11,
        validators=[RegexValidator(r'^09\d{9}$', 'شماره موبایل معتبر وارد کنید')]
    )
    
    # اطلاعات سازمانی
    employee_id = models.CharField(max_length=20, unique=True, null=True, blank=True)
    department = models.CharField(max_length=100, blank=True)
    position = models.CharField(max_length=100, blank=True)
    
    # وضعیت حساب
    is_verified = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_login_ip = models.GenericIPAddressField(null=True, blank=True)
    
    # تنظیمات امنیتی
    failed_login_attempts = models.PositiveIntegerField(default=0)
    account_locked_until = models.DateTimeField(null=True, blank=True)
    password_changed_at = models.DateTimeField(auto_now_add=True)
    
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username', 'national_code']
    
    class Meta:
        db_table = 'auth_users'
        verbose_name = 'کاربر'
        verbose_name_plural = 'کاربران'
    
    def __str__(self):
        return f"{self.get_full_name()} ({self.email})"
    
    @property
    def is_account_locked(self):
        """بررسی قفل بودن حساب"""
        if self.account_locked_until:
            from django.utils import timezone
            return timezone.now() < self.account_locked_until
        return False


class Role(models.Model):
    """نقش‌های سازمانی"""
    
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    permissions = models.JSONField(default=dict)  # مجوزهای خاص نقش
    
    # سطح دسترسی پیش‌فرض
    default_read_access = models.BooleanField(default=True)
    default_write_access = models.BooleanField(default=False)
    default_delete_access = models.BooleanField(default=False)
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'auth_roles'
        verbose_name = 'نقش'
        verbose_name_plural = 'نقش‌ها'
    
    def __str__(self):
        return self.name


class UserRole(models.Model):
    """ارتباط کاربر و نقش"""
    
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='user_roles')
    role = models.ForeignKey(Role, on_delete=models.CASCADE, related_name='role_users')
    
    # محدودیت زمانی
    valid_from = models.DateTimeField()
    valid_until = models.DateTimeField(null=True, blank=True)
    
    # وضعیت
    is_active = models.BooleanField(default=True)
    assigned_by = models.ForeignKey(
        CustomUser, 
        on_delete=models.SET_NULL, 
        null=True, 
        related_name='assigned_roles'
    )
    assigned_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'auth_user_roles'
        unique_together = ['user', 'role']
        verbose_name = 'نقش کاربر'
        verbose_name_plural = 'نقش‌های کاربران'
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.role.name}"</code></pre>
                </div>

                <!-- مدل مکان -->
                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">apps/locations/models.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from django.contrib.gis.db import models
from django.contrib.gis.geos import Point, Polygon
from django.core.exceptions import ValidationError
from apps.authentication.models import CustomUser
import uuid


class LocationHierarchy(models.Model):
    """سلسله‌مراتب مکانی"""
    
    LOCATION_TYPES = [
        ('city', 'شهر'),
        ('district', 'منطقه'),
        ('neighborhood', 'محله'),
        ('street', 'خیابان'),
        ('building', 'ساختمان'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=200)
    code = models.CharField(max_length=50, unique=True)
    type = models.CharField(max_length=20, choices=LOCATION_TYPES)
    
    # سلسله‌مراتب
    parent = models.ForeignKey(
        'self', 
        on_delete=models.CASCADE, 
        null=True, 
        blank=True, 
        related_name='children'
    )
    level = models.PositiveIntegerField()  # سطح در درخت
    path = models.CharField(max_length=500)  # مسیر کامل
    
    # اطلاعات جغرافیایی
    geometry = models.GeometryField(null=True, blank=True)
    center_point = models.PointField(null=True, blank=True)
    area = models.FloatField(null=True, blank=True)  # مساحت به متر مربع
    
    # اطلاعات اضافی
    description = models.TextField(blank=True)
    metadata = models.JSONField(default=dict)
    
    # وضعیت
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    created_by = models.ForeignKey(
        CustomUser, 
        on_delete=models.SET_NULL, 
        null=True, 
        related_name='created_locations'
    )
    
    class Meta:
        db_table = 'locations_hierarchy'
        verbose_name = 'مکان'
        verbose_name_plural = 'مکان‌ها'
        indexes = [
            models.Index(fields=['parent', 'level']),
            models.Index(fields=['type', 'is_active']),
        ]
    
    def __str__(self):
        return f"{self.name} ({self.get_type_display()})"
    
    def save(self, *args, **kwargs):
        # محاسبه سطح و مسیر
        if self.parent:
            self.level = self.parent.level + 1
            self.path = f"{self.parent.path}/{self.code}"
        else:
            self.level = 0
            self.path = self.code
        
        # محاسبه نقطه مرکزی از geometry
        if self.geometry and not self.center_point:
            self.center_point = self.geometry.centroid
        
        super().save(*args, **kwargs)
    
    def get_ancestors(self):
        """دریافت تمام والدین"""
        ancestors = []
        current = self.parent
        while current:
            ancestors.append(current)
            current = current.parent
        return ancestors
    
    def get_descendants(self):
        """دریافت تمام فرزندان"""
        return LocationHierarchy.objects.filter(
            path__startswith=f"{self.path}/",
            is_active=True
        )
    
    def is_within(self, other_location):
        """بررسی اینکه آیا این مکان درون مکان دیگری قرار دارد"""
        if not self.geometry or not other_location.geometry:
            return False
        return other_location.geometry.contains(self.geometry)


class UserLocationAccess(models.Model):
    """دسترسی کاربران به مکان‌ها"""
    
    ACCESS_TYPES = [
        ('read', 'خواندن'),
        ('write', 'نوشتن'),
        ('delete', 'حذف'),
        ('admin', 'مدیریت'),
    ]
    
    user = models.ForeignKey(
        CustomUser, 
        on_delete=models.CASCADE, 
        related_name='location_accesses'
    )
    location = models.ForeignKey(
        LocationHierarchy, 
        on_delete=models.CASCADE, 
        related_name='user_accesses'
    )
    
    # انواع دسترسی
    can_read = models.BooleanField(default=True)
    can_write = models.BooleanField(default=False)
    can_delete = models.BooleanField(default=False)
    can_admin = models.BooleanField(default=False)
    
    # دسترسی فیلدی
    accessible_fields = models.JSONField(default=list)  # فیلدهای قابل دسترسی
    restricted_fields = models.JSONField(default=list)  # فیلدهای محدود
    
    # ارث‌بری به فرزندان
    inherit_to_children = models.BooleanField(default=True)
    
    # محدودیت زمانی
    valid_from = models.DateTimeField()
    valid_until = models.DateTimeField(null=True, blank=True)
    
    # وضعیت
    is_active = models.BooleanField(default=True)
    granted_by = models.ForeignKey(
        CustomUser, 
        on_delete=models.SET_NULL, 
        null=True, 
        related_name='granted_accesses'
    )
    granted_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'location_user_accesses'
        unique_together = ['user', 'location']
        verbose_name = 'دسترسی مکانی'
        verbose_name_plural = 'دسترسی‌های مکانی'
        indexes = [
            models.Index(fields=['user', 'is_active']),
            models.Index(fields=['location', 'inherit_to_children']),
        ]
    
    def __str__(self):
        return f"{self.user.get_full_name()} -> {self.location.name}"
    
    def clean(self):
        """اعتبارسنجی دسترسی"""
        if self.valid_until and self.valid_from >= self.valid_until:
            raise ValidationError('تاریخ پایان باید از تاریخ شروع بزرگ‌تر باشد')
    
    @property
    def is_valid(self):
        """بررسی معتبر بودن دسترسی"""
        from django.utils import timezone
        now = timezone.now()
        
        if not self.is_active:
            return False
        
        if self.valid_from > now:
            return False
        
        if self.valid_until and self.valid_until < now:
            return False
        
        return True</code></pre>
                </div>

                <!-- مدل Audit -->
                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">apps/audit/models.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from django.contrib.gis.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from apps.authentication.models import CustomUser
import uuid


class AuditLog(models.Model):
    """لاگ‌های امنیتی و فعالیت‌ها"""
    
    ACTION_TYPES = [
        ('login', 'ورود'),
        ('logout', 'خروج'),
        ('create', 'ایجاد'),
        ('read', 'خواندن'),
        ('update', 'ویرایش'),
        ('delete', 'حذف'),
        ('access_denied', 'رد دسترسی'),
        ('permission_changed', 'تغییر مجوز'),
    ]
    
    RISK_LEVELS = [
        ('low', 'کم'),
        ('medium', 'متوسط'),
        ('high',
        ('high', 'بالا'),
        ('critical', 'بحرانی'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # اطلاعات کاربر
    user = models.ForeignKey(
        CustomUser, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='audit_logs'
    )
    user_email = models.EmailField()  # ذخیره ایمیل برای حفظ تاریخچه
    
    # اطلاعات عملیات
    action = models.CharField(max_length=50, choices=ACTION_TYPES)
    resource_type = models.CharField(max_length=100)  # نوع منبع
    resource_id = models.CharField(max_length=100, blank=True)  # شناسه منبع
    
    # اطلاعات Generic برای ارتباط با هر مدل
    content_type = models.ForeignKey(ContentType, on_delete=models.SET_NULL, null=True, blank=True)
    object_id = models.CharField(max_length=100, blank=True)
    content_object = GenericForeignKey('content_type', 'object_id')
    
    # جزئیات
    description = models.TextField()
    old_values = models.JSONField(default=dict, blank=True)  # مقادیر قبلی
    new_values = models.JSONField(default=dict, blank=True)  # مقادیر جدید
    
    # اطلاعات درخواست
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField(blank=True)
    request_path = models.CharField(max_length=500)
    request_method = models.CharField(max_length=10)
    
    # سطح ریسک
    risk_level = models.CharField(max_length=20, choices=RISK_LEVELS, default='low')
    
    # زمان‌بندی
    timestamp = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'audit_logs'
        verbose_name = 'لاگ امنیتی'
        verbose_name_plural = 'لاگ‌های امنیتی'
        indexes = [
            models.Index(fields=['user', 'timestamp']),
            models.Index(fields=['action', 'timestamp']),
            models.Index(fields=['risk_level', 'timestamp']),
            models.Index(fields=['ip_address', 'timestamp']),
        ]
        ordering = ['-timestamp']
    
    def __str__(self):
        return f"{self.user_email} - {self.get_action_display()} - {self.timestamp}"


class SecurityAlert(models.Model):
    """هشدارهای امنیتی"""
    
    ALERT_TYPES = [
        ('suspicious_login', 'ورود مشکوک'),
        ('multiple_failed_login', 'ورود ناموفق متعدد'),
        ('unauthorized_access', 'دسترسی غیرمجاز'),
        ('data_breach_attempt', 'تلاش نفوذ به داده'),
        ('unusual_activity', 'فعالیت غیرعادی'),
    ]
    
    SEVERITY_LEVELS = [
        ('info', 'اطلاعاتی'),
        ('warning', 'هشدار'),
        ('error', 'خطا'),
        ('critical', 'بحرانی'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    alert_type = models.CharField(max_length=50, choices=ALERT_TYPES)
    severity = models.CharField(max_length=20, choices=SEVERITY_LEVELS)
    
    # اطلاعات مرتبط
    user = models.ForeignKey(CustomUser, on_delete=models.SET_NULL, null=True, blank=True)
    ip_address = models.GenericIPAddressField()
    
    # پیام و جزئیات
    title = models.CharField(max_length=200)
    message = models.TextField()
    details = models.JSONField(default=dict)
    
    # وضعیت پردازش
    is_resolved = models.BooleanField(default=False)
    resolved_by = models.ForeignKey(
        CustomUser, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='resolved_alerts'
    )
    resolved_at = models.DateTimeField(null=True, blank=True)
    resolution_notes = models.TextField(blank=True)
    
    # زمان‌بندی
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'security_alerts'
        verbose_name = 'هشدار امنیتی'
        verbose_name_plural = 'هشدارهای امنیتی'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.title} - {self.get_severity_display()}"</code></pre>
                </div>

                <div class="explanation">
                    <h4>💡 نکات مهم در طراحی مدل‌ها:</h4>
                    <ul>
                        <li><span class="highlight">UUID</span> به عنوان کلید اصلی برای امنیت بیشتر</li>
                        <li><span class="highlight">JSONField</span> برای ذخیره داده‌های انعطاف‌پذیر</li>
                        <li><span class="highlight">GeometryField</span> برای قابلیت‌های GIS</li>
                        <li><span class="highlight">Index</span> برای بهبود عملکرد کوئری‌ها</li>
                        <li><span class="highlight">Soft Delete</span> با فیلد is_active</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- سریالایزرها -->
        <div class="section" id="serializers">
            <div class="section-header">
                <h2><span class="icon">🔄</span>سریالایزرهای DRF</h2>
            </div>
            <div class="section-content">
                <div class="explanation">
                    <h4>سریالایزرها برای API</h4>
                    <p>سریالایزرها مسئول تبدیل داده‌ها بین JSON و مدل‌های Django هستند.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">apps/authentication/serializers.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from rest_framework import serializers
from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from .models import CustomUser, Role, UserRole


class UserRegistrationSerializer(serializers.ModelSerializer):
    """سریالایزر ثبت‌نام کاربر"""
    
    password = serializers.CharField(write_only=True, validators=[validate_password])
    password_confirm = serializers.CharField(write_only=True)
    
    class Meta:
        model = CustomUser
        fields = [
            'email', 'username', 'first_name', 'last_name',
            'national_code', 'phone_number', 'employee_id',
            'department', 'position', 'password', 'password_confirm'
        ]
        extra_kwargs = {
            'email': {'required': True},
            'first_name': {'required': True},
            'last_name': {'required': True},
        }
    
    def validate(self, attrs):
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError("رمزهای عبور مطابقت ندارند")
        return attrs
    
    def create(self, validated_data):
        validated_data.pop('password_confirm')
        password = validated_data.pop('password')
        
        user = CustomUser.objects.create_user(
            password=password,
            **validated_data
        )
        return user


class UserLoginSerializer(serializers.Serializer):
    """سریالایزر ورود کاربر"""
    
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True)
    
    def validate(self, attrs):
        email = attrs.get('email')
        password = attrs.get('password')
        
        if email and password:
            user = authenticate(
                request=self.context.get('request'),
                username=email,
                password=password
            )
            
            if not user:
                raise serializers.ValidationError('اطلاعات ورود نامعتبر است')
            
            if not user.is_active:
                raise serializers.ValidationError('حساب کاربری غیرفعال است')
            
            if user.is_account_locked:
                raise serializers.ValidationError('حساب کاربری قفل شده است')
            
            attrs['user'] = user
            return attrs
        
        raise serializers.ValidationError('ایمیل و رمز عبور الزامی است')


class UserProfileSerializer(serializers.ModelSerializer):
    """سریالایزر پروفایل کاربر"""
    
    full_name = serializers.SerializerMethodField()
    roles = serializers.SerializerMethodField()
    
    class Meta:
        model = CustomUser
        fields = [
            'id', 'email', 'username', 'first_name', 'last_name', 'full_name',
            'national_code', 'phone_number', 'employee_id', 'department', 
            'position', 'is_verified', 'last_login', 'roles'
        ]
        read_only_fields = ['id', 'email', 'is_verified', 'last_login']
    
    def get_full_name(self, obj):
        return obj.get_full_name()
    
    def get_roles(self, obj):
        active_roles = obj.user_roles.filter(
            is_active=True,
            valid_from__lte=timezone.now()
        ).filter(
            models.Q(valid_until__isnull=True) | 
            models.Q(valid_until__gte=timezone.now())
        )
        return [role.role.name for role in active_roles]


class RoleSerializer(serializers.ModelSerializer):
    """سریالایزر نقش‌ها"""
    
    users_count = serializers.SerializerMethodField()
    
    class Meta:
        model = Role
        fields = [
            'id', 'name', 'description', 'permissions',
            'default_read_access', 'default_write_access', 
            'default_delete_access', 'users_count', 'created_at'
        ]
    
    def get_users_count(self, obj):
        return obj.role_users.filter(is_active=True).count()


class UserRoleSerializer(serializers.ModelSerializer):
    """سریالایزر تخصیص نقش به کاربر"""
    
    user_email = serializers.EmailField(source='user.email', read_only=True)
    user_name = serializers.CharField(source='user.get_full_name', read_only=True)
    role_name = serializers.CharField(source='role.name', read_only=True)
    assigned_by_name = serializers.CharField(source='assigned_by.get_full_name', read_only=True)
    
    class Meta:
        model = UserRole
        fields = [
            'id', 'user', 'user_email', 'user_name', 'role', 'role_name',
            'valid_from', 'valid_until', 'is_active', 'assigned_by', 
            'assigned_by_name', 'assigned_at'
        ]
        read_only_fields = ['assigned_by', 'assigned_at']
    
    def validate(self, attrs):
        # بررسی تداخل نقش‌ها
        user = attrs.get('user')
        role = attrs.get('role')
        valid_from = attrs.get('valid_from')
        valid_until = attrs.get('valid_until')
        
        if valid_until and valid_from >= valid_until:
            raise serializers.ValidationError('تاریخ پایان باید از تاریخ شروع بزرگ‌تر باشد')
        
        # بررسی تکراری نبودن نقش برای کاربر
        existing_role = UserRole.objects.filter(
            user=user,
            role=role,
            is_active=True
        ).exclude(id=self.instance.id if self.instance else None)
        
        if existing_role.exists():
            raise serializers.ValidationError('این نقش قبلاً به کاربر تخصیص داده شده است')
        
        return attrs</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">apps/locations/serializers.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from rest_framework import serializers
from rest_framework_gis.serializers import GeoFeatureModelSerializer
from django.contrib.gis.geos import Point, Polygon
from .models import LocationHierarchy, UserLocationAccess


class LocationHierarchySerializer(GeoFeatureModelSerializer):
    """سریالایزر مکان‌ها با قابلیت GIS"""
    
    parent_name = serializers.CharField(source='parent.name', read_only=True)
    children_count = serializers.SerializerMethodField()
    full_path = serializers.SerializerMethodField()
    
    class Meta:
        model = LocationHierarchy
        geo_field = 'geometry'
        fields = [
            'id', 'name', 'code', 'type', 'parent', 'parent_name',
            'level', 'path', 'description', 'metadata', 'area',
            'children_count', 'full_path', 'is_active', 'created_at'
        ]
        read_only_fields = ['level', 'path', 'created_at']
    
    def get_children_count(self, obj):
        return obj.children.filter(is_active=True).count()
    
    def get_full_path(self, obj):
        """دریافت مسیر کامل نام‌ها"""
        path_names = []
        current = obj
        while current:
            path_names.append(current.name)
            current = current.parent
        return ' / '.join(reversed(path_names))
    
    def validate_geometry(self, value):
        """اعتبارسنجی هندسه"""
        if value and not value.valid:
            raise serializers.ValidationError('هندسه معتبر نیست')
        return value
    
    def validate(self, attrs):
        parent = attrs.get('parent')
        location_type = attrs.get('type')
        
        # بررسی سلسله‌مراتب صحیح
        type_hierarchy = {
            'city': None,
            'district': 'city',
            'neighborhood': 'district',
            'street': 'neighborhood',
            'building': 'street'
        }
        
        expected_parent_type = type_hierarchy.get(location_type)
        
        if expected_parent_type and (not parent or parent.type != expected_parent_type):
            raise serializers.ValidationError(
                f'نوع والد برای {location_type} باید {expected_parent_type} باشد'
            )
        
        if not expected_parent_type and parent:
            raise serializers.ValidationError(f'{location_type} نمی‌تواند والد داشته باشد')
        
        return attrs


class LocationTreeSerializer(serializers.ModelSerializer):
    """سریالایزر درختی مکان‌ها"""
    
    children = serializers.SerializerMethodField()
    
    class Meta:
        model = LocationHierarchy
        fields = ['id', 'name', 'code', 'type', 'level', 'children']
    
    def get_children(self, obj):
        if hasattr(obj, 'prefetched_children'):
            children = obj.prefetched_children
        else:
            children = obj.children.filter(is_active=True)
        
        return LocationTreeSerializer(children, many=True, context=self.context).data


class UserLocationAccessSerializer(serializers.ModelSerializer):
    """سریالایزر دسترسی مکانی کاربران"""
    
    user_email = serializers.EmailField(source='user.email', read_only=True)
    user_name = serializers.CharField(source='user.get_full_name', read_only=True)
    location_name = serializers.CharField(source='location.name', read_only=True)
    location_path = serializers.CharField(source='location.path', read_only=True)
    granted_by_name = serializers.CharField(source='granted_by.get_full_name', read_only=True)
    
    access_summary = serializers.SerializerMethodField()
    
    class Meta:
        model = UserLocationAccess
        fields = [
            'id', 'user', 'user_email', 'user_name', 'location', 
            'location_name', 'location_path', 'can_read', 'can_write', 
            'can_delete', 'can_admin', 'accessible_fields', 'restricted_fields',
            'inherit_to_children', 'valid_from', 'valid_until', 'is_active',
            'granted_by', 'granted_by_name', 'granted_at', 'access_summary'
        ]
        read_only_fields = ['granted_by', 'granted_at']
    
    def get_access_summary(self, obj):
        """خلاصه دسترسی‌ها"""
        accesses = []
        if obj.can_read:
            accesses.append('خواندن')
        if obj.can_write:
            accesses.append('نوشتن')
        if obj.can_delete:
            accesses.append('حذف')
        if obj.can_admin:
            accesses.append('مدیریت')
        return ', '.join(accesses) if accesses else 'بدون دسترسی'
    
    def validate(self, attrs):
        user = attrs.get('user')
        location = attrs.get('location')
        valid_from = attrs.get('valid_from')
        valid_until = attrs.get('valid_until')
        
        # بررسی تاریخ‌ها
        if valid_until and valid_from >= valid_until:
            raise serializers.ValidationError('تاریخ پایان باید از تاریخ شروع بزرگ‌تر باشد')
        
        # بررسی تکراری نبودن دسترسی
        existing_access = UserLocationAccess.objects.filter(
            user=user,
            location=location,
            is_active=True
        ).exclude(id=self.instance.id if self.instance else None)
        
        if existing_access.exists():
            raise serializers.ValidationError('دسترسی به این مکان قبلاً تعریف شده است')
        
        return attrs


class LocationSearchSerializer(serializers.Serializer):
    """سریالایزر جستجوی مکانی"""
    
    query = serializers.CharField(max_length=200)
    location_type = serializers.ChoiceField(
        choices=LocationHierarchy.LOCATION_TYPES,
        required=False
    )
    parent_id = serializers.UUIDField(required=False)
    
    # جستجوی جغرافیایی
    latitude = serializers.FloatField(required=False)
    longitude = serializers.FloatField(required=False)
    radius = serializers.FloatField(required=False, min_value=0.1, max_value=50)  # کیلومتر
    
    def validate(self, attrs):
        # اگر مختصات داده شده، شعاع هم باید باشد
        if any([attrs.get('latitude'), attrs.get('longitude')]) and not attrs.get('radius'):
            raise serializers.ValidationError('برای جستجوی مکانی، شعاع الزامی است')
        
        if attrs.get('radius') and not all([attrs.get('latitude'), attrs.get('longitude')]):
            raise serializers.ValidationError('برای جستجوی مکانی، مختصات الزامی است')
        
        return attrs</code></pre>
                </div>
            </div>
        </div>

        <!-- ویوها -->
        <div class="section" id="views">
            <div class="section-header">
                <h2><span class="icon">👁️</span>ویوهای API</h2>
            </div>
            <div class="section-content">
                <div class="explanation">
                    <h4>ویوهای Django REST Framework</h4>
                    <p>ویوها منطق اصلی API را پیاده‌سازی می‌کنند و شامل احراز هویت و کنترل دسترسی هستند.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">apps/authentication/views.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import login, logout
from django.utils import timezone
from django.db import transaction
from django.core.cache import cache
import logging

from .models import CustomUser, Role, UserRole
from .serializers import (
    UserRegistrationSerializer, UserLoginSerializer, 
    UserProfileSerializer, RoleSerializer, UserRoleSerializer
)
from apps.audit.models import AuditLog, SecurityAlert
from .utils import get_client_ip, detect_suspicious_activity

logger = logging.getLogger(__name__)


class UserRegistrationView(generics.CreateAPIView):
    """ثبت‌نام کاربر جدید"""
    
    queryset = CustomUser.objects.all()
    serializer_class = UserRegistrationSerializer
    permission_classes = [permissions.AllowAny]
    
    def perform_create(self, serializer):
        with transaction.atomic():
            user = serializer.save()
            
            # ثبت لاگ
            AuditLog.objects.create(
                user=user,
                user_email=user.email,
                action='create',
                resource_type='User',
                resource_id=str(user.id),
                description=f'کاربر جدید ثبت‌نام کرد: {user.email}',
                ip_address=get_client_ip(self.request),
                user_agent=self.request.META.get('HTTP_USER_AGENT', ''),
                request_path=self.request.path,
                request_method=self.request.method,
                risk_level='low'
            )
            
            logger.info(f'New user registered: {user.email}')


class UserLoginView(APIView):
    """ورود کاربر و دریافت JWT Token"""
    
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = UserLoginSerializer(
            data=request.data, 
            context={'request': request}
        )
        
        if serializer.is_valid():
            user = serializer.validated_data['user']
            ip_address = get_client_ip(request)
            
            # بررسی فعالیت مشکوک
            if detect_suspicious_activity(user, ip_address):
                SecurityAlert.objects.create(
                    alert_type='suspicious_login',
                    severity='warning',
                    user=user,
                    ip_address=ip_address,
                    title='ورود مشکوک',
                    message=f'ورود از IP جدید: {ip_address}',
                    details={'previous_ips': user.last_login_ip}
                )
            
            # تولید JWT Token
            refresh = RefreshToken.for_user(user)
            access_token = refresh.access_token
            
            # به‌روزرسانی اطلاعات کاربر
            user.last_login_ip = ip_address
            user.failed_login_attempts = 0
            user.save(update_fields=['last_login_ip', 'failed_login_attempts'])
            
            # ثبت لاگ موفق
            AuditLog.objects.create(
                user=user,
                user_email=user.email,
                action='login',
                resource_type='Authentication',
                description='ورود موفق',
                ip_address=ip_address,
                user_agent=request.META.get('HTTP_USER_AGENT', ''),
                request_path=request.path,
                request_method=request.method,
                risk_level='low'
            )
            
            return Response({
                'access': str(access_token),
                'refresh': str(refresh),
                'user': UserProfileSerializer(user).data
            }, status=status.HTTP_200_OK)
        
        # ورود ناموفق
        email = request.data.get('email')
        if email:
            try:
                user = CustomUser.objects.get(email=email)
                user.failed_login_attempts += 1
                
                # قفل کردن حساب بعد از 5 تلاش ناموفق
                if user.failed_login_attempts >= 5:
                    user.account_locked_until = timezone.now() + timezone.timedelta(minutes=30)
                    
                    SecurityAlert.objects.create(
                        alert_type='multiple_failed_login',
                        severity='error',
                        user=user,
                        ip_address=get_client_ip(request),
                        title='حساب قفل شد',
                        message=f'حساب به دلیل تلاش‌های ناموفق متعدد قفل شد',
                        details={'failed_attempts': user.failed_login_attempts}
                    )
                
                user.save(update_fields=['failed_login_attempts', 'account_locked_until'])
                
            except CustomUser.DoesNotExist:
                pass
        
        # ثبت لاگ ناموفق
        AuditLog.objects.create(
            user_email=email or 'نامشخص',
            action='login',
            resource_type='Authentication',
            description='تلاش ورود ناموفق',
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
            request_path=request.path,
            request_method=request.method,
            risk_level='medium'
        )
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class UserLogoutView(APIView):
    """خروج کاربر"""
    
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        try:
            refresh_token = request.data.get('refresh')
            if refresh_token:
                token = RefreshToken(refresh_token)
                token.blacklist()
            
            # ثبت لاگ خروج
            AuditLog.objects.create(
                user=request.user,
                user_email=request.user.email,
                action='logout',
                resource_type='Authentication',
                description='خروج موفق',
                ip_address=get_client_ip(request),
                user_agent=request.META.get('HTTP_USER_AGENT', ''),
                request_path=request.path,
                request_method=request.method,
                risk_level='low'
            )
            
            return Response({'message': 'خروج موفق'}, status=status.HTTP_200_OK)
            
        except Exception as e:
            return Response({'error': 'خطا در خروج'}, status=status.HTTP_400_BAD_REQUEST)


class UserProfileView(generics.RetrieveUpdateAPIView):
    """مشاهده و ویرایش پروفایل کاربر"""
    
    serializer_class = UserProfileSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_object(self):
        return self.request.user
    
    def perform_update(self, serializer):
        old_values = {}
        new_values = {}
        
        # ذخیره مقادیر قبلی برای audit
        for field in serializer.validated_data:
            old_values[field] = getattr(self.request.user, field)
            new_values[field] = serializer.validated_data[field]
        
        user = serializer.save()
        
        # ثبت لاگ تغییرات
        AuditLog.objects.create(
            user=user,
            user_email=user.email,
            action='update',
            resource_type='User',
            resource_id=str(user.id),
            description='ویرایش پروفایل',
            old_values=old_values,
            new_values=new_values,
            ip_address=get_client_ip(self.request),
            user_agent=self.request.META.get('HTTP_USER_AGENT', ''),
            request_path=self.request.path,
            request_method=self.request.method,
            risk_level='low'
        )


class RoleListCreateView(generics.ListCreateAPIView):
    """لیست و ایجاد نقش‌ها"""
    
    queryset = Role.objects.all()
    serializer_class = RoleSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        # فقط کاربران مدیر می
                      توانند نقش‌ها را مشاهده کنند
        if self.request.user.is_superuser:
            return Role.objects.all()
        return Role.objects.none()
    
    def perform_create(self, serializer):
        role = serializer.save()
        
        # ثبت لاگ ایجاد نقش
        AuditLog.objects.create(
            user=self.request.user,
            user_email=self.request.user.email,
            action='create',
            resource_type='Role',
            resource_id=str(role.id),
            description=f'نقش جدید ایجاد شد: {role.name}',
            new_values=serializer.validated_data,
            ip_address=get_client_ip(self.request),
            user_agent=self.request.META.get('HTTP_USER_AGENT', ''),
            request_path=self.request.path,
            request_method=self.request.method,
            risk_level='medium'
        )


class UserRoleAssignView(generics.CreateAPIView):
    """تخصیص نقش به کاربر"""
    
    serializer_class = UserRoleSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def perform_create(self, serializer):
        user_role = serializer.save(assigned_by=self.request.user)
        
        # ثبت لاگ تخصیص نقش
        AuditLog.objects.create(
            user=self.request.user,
            user_email=self.request.user.email,
            action='permission_changed',
            resource_type='UserRole',
            resource_id=str(user_role.id),
            description=f'نقش {user_role.role.name} به {user_role.user.email} تخصیص داده شد',
            new_values={
                'user': user_role.user.email,
                'role': user_role.role.name,
                'valid_from': str(user_role.valid_from),
                'valid_until': str(user_role.valid_until) if user_role.valid_until else None
            },
            ip_address=get_client_ip(self.request),
            user_agent=self.request.META.get('HTTP_USER_AGENT', ''),
            request_path=self.request.path,
            request_method=self.request.method,
            risk_level='high'
        )


@api_view(['GET'])
@permission_classes([permissions.IsAuthenticated])
def user_permissions_view(request):
    """دریافت مجوزهای کاربر جاری"""
    
    user = request.user
    permissions_data = {
        'user_id': str(user.id),
        'roles': [],
        'location_accesses': [],
        'system_permissions': {
            'is_superuser': user.is_superuser,
            'is_staff': user.is_staff,
            'is_verified': user.is_verified
        }
    }
    
    # دریافت نقش‌های فعال
    active_roles = user.user_roles.filter(
        is_active=True,
        valid_from__lte=timezone.now()
    ).filter(
        models.Q(valid_until__isnull=True) | 
        models.Q(valid_until__gte=timezone.now())
    ).select_related('role')
    
    for user_role in active_roles:
        permissions_data['roles'].append({
            'name': user_role.role.name,
            'permissions': user_role.role.permissions,
            'valid_until': user_role.valid_until
        })
    
    # دریافت دسترسی‌های مکانی
    location_accesses = user.location_accesses.filter(
        is_active=True,
        valid_from__lte=timezone.now()
    ).filter(
        models.Q(valid_until__isnull=True) | 
        models.Q(valid_until__gte=timezone.now())
    ).select_related('location')
    
    for access in location_accesses:
        permissions_data['location_accesses'].append({
            'location_id': str(access.location.id),
            'location_name': access.location.name,
            'location_path': access.location.path,
            'can_read': access.can_read,
            'can_write': access.can_write,
            'can_delete': access.can_delete,
            'can_admin': access.can_admin,
            'accessible_fields': access.accessible_fields,
            'restricted_fields': access.restricted_fields
        })
    
    return Response(permissions_data)
</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">apps/locations/views.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from rest_framework import generics, status, permissions
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.gis.geos import Point
from django.contrib.gis.measure import Distance
from django.db.models import Q, Prefetch
from django.core.cache import cache
import logging

from .models import LocationHierarchy, UserLocationAccess
from .serializers import (
    LocationHierarchySerializer, LocationTreeSerializer,
    UserLocationAccessSerializer, LocationSearchSerializer
)
from .permissions import LocationPermission
from apps.audit.models import AuditLog
from apps.authentication.utils import get_client_ip

logger = logging.getLogger(__name__)


class LocationListCreateView(generics.ListCreateAPIView):
    """لیست و ایجاد مکان‌ها"""
    
    serializer_class = LocationHierarchySerializer
    permission_classes = [permissions.IsAuthenticated, LocationPermission]
    
    def get_queryset(self):
        queryset = LocationHierarchy.objects.filter(is_active=True)
        
        # فیلتر بر اساس دسترسی کاربر
        if not self.request.user.is_superuser:
            user_locations = UserLocationAccess.objects.filter(
                user=self.request.user,
                is_active=True,
                can_read=True
            ).values_list('location_id', flat=True)
            
            queryset = queryset.filter(id__in=user_locations)
        
        # فیلترهای اختیاری
        parent_id = self.request.query_params.get('parent')
        if parent_id:
            queryset = queryset.filter(parent_id=parent_id)
        
        location_type = self.request.query_params.get('type')
        if location_type:
            queryset = queryset.filter(type=location_type)
        
        return queryset.select_related('parent').order_by('level', 'name')
    
    def perform_create(self, serializer):
        location = serializer.save(created_by=self.request.user)
        
        # ثبت لاگ ایجاد مکان
        AuditLog.objects.create(
            user=self.request.user,
            user_email=self.request.user.email,
            action='create',
            resource_type='Location',
            resource_id=str(location.id),
            description=f'مکان جدید ایجاد شد: {location.name}',
            new_values={
                'name': location.name,
                'code': location.code,
                'type': location.type,
                'parent': str(location.parent.id) if location.parent else None
            },
            ip_address=get_client_ip(self.request),
            user_agent=self.request.META.get('HTTP_USER_AGENT', ''),
            request_path=self.request.path,
            request_method=self.request.method,
            risk_level='medium'
        )


class LocationDetailView(generics.RetrieveUpdateDestroyAPIView):
    """جزئیات، ویرایش و حذف مکان"""
    
    serializer_class = LocationHierarchySerializer
    permission_classes = [permissions.IsAuthenticated, LocationPermission]
    
    def get_queryset(self):
        return LocationHierarchy.objects.filter(is_active=True)
    
    def perform_update(self, serializer):
        old_values = {}
        new_values = {}
        
        # ذخیره مقادیر قبلی
        instance = self.get_object()
        for field in serializer.validated_data:
            old_values[field] = getattr(instance, field)
            new_values[field] = serializer.validated_data[field]
        
        location = serializer.save()
        
        # ثبت لاگ ویرایش
        AuditLog.objects.create(
            user=self.request.user,
            user_email=self.request.user.email,
            action='update',
            resource_type='Location',
            resource_id=str(location.id),
            description=f'مکان ویرایش شد: {location.name}',
            old_values=old_values,
            new_values=new_values,
            ip_address=get_client_ip(self.request),
            user_agent=self.request.META.get('HTTP_USER_AGENT', ''),
            request_path=self.request.path,
            request_method=self.request.method,
            risk_level='medium'
        )
    
    def perform_destroy(self, instance):
        # Soft delete
        instance.is_active = False
        instance.save()
        
        # ثبت لاگ حذف
        AuditLog.objects.create(
            user=self.request.user,
            user_email=self.request.user.email,
            action='delete',
            resource_type='Location',
            resource_id=str(instance.id),
            description=f'مکان حذف شد: {instance.name}',
            old_values={'is_active': True},
            new_values={'is_active': False},
            ip_address=get_client_ip(self.request),
            user_agent=self.request.META.get('HTTP_USER_AGENT', ''),
            request_path=self.request.path,
            request_method=self.request.method,
            risk_level='high'
        )


class LocationTreeView(APIView):
    """درخت سلسله‌مراتبی مکان‌ها"""
    
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        # استفاده از کش برای بهبود عملکرد
        cache_key = f"location_tree_{request.user.id}"
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return Response(cached_data)
        
        # دریافت مکان‌های ریشه
        root_locations = LocationHierarchy.objects.filter(
            parent__isnull=True,
            is_active=True
        ).prefetch_related(
            Prefetch(
                'children',
                queryset=LocationHierarchy.objects.filter(is_active=True),
                to_attr='prefetched_children'
            )
        )
        
        # فیلتر بر اساس دسترسی کاربر
        if not request.user.is_superuser:
            user_locations = UserLocationAccess.objects.filter(
                user=request.user,
                is_active=True,
                can_read=True
            ).values_list('location_id', flat=True)
            
            root_locations = root_locations.filter(id__in=user_locations)
        
        serializer = LocationTreeSerializer(root_locations, many=True)
        data = serializer.data
        
        # ذخیره در کش برای 15 دقیقه
        cache.set(cache_key, data, 900)
        
        return Response(data)


class LocationSearchView(APIView):
    """جستجوی مکان‌ها"""
    
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        serializer = LocationSearchSerializer(data=request.data)
        
        if serializer.is_valid():
            query = serializer.validated_data['query']
            location_type = serializer.validated_data.get('location_type')
            parent_id = serializer.validated_data.get('parent_id')
            latitude = serializer.validated_data.get('latitude')
            longitude = serializer.validated_data.get('longitude')
            radius = serializer.validated_data.get('radius')
            
            # جستجوی پایه
            queryset = LocationHierarchy.objects.filter(
                is_active=True,
                name__icontains=query
            )
            
            # فیلتر نوع مکان
            if location_type:
                queryset = queryset.filter(type=location_type)
            
            # فیلتر والد
            if parent_id:
                queryset = queryset.filter(parent_id=parent_id)
            
            # جستجوی جغرافیایی
            if latitude and longitude and radius:
                point = Point(longitude, latitude)
                queryset = queryset.filter(
                    center_point__distance_lte=(point, Distance(km=radius))
                )
            
            # فیلتر دسترسی کاربر
            if not request.user.is_superuser:
                user_locations = UserLocationAccess.objects.filter(
                    user=request.user,
                    is_active=True,
                    can_read=True
                ).values_list('location_id', flat=True)
                
                queryset = queryset.filter(id__in=user_locations)
            
            # محدود کردن نتایج
            queryset = queryset[:50]
            
            serializer = LocationHierarchySerializer(queryset, many=True)
            return Response(serializer.data)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class UserLocationAccessListCreateView(generics.ListCreateAPIView):
    """لیست و ایجاد دسترسی‌های مکانی"""
    
    serializer_class = UserLocationAccessSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        queryset = UserLocationAccess.objects.filter(is_active=True)
        
        # فقط مدیران می‌توانند همه دسترسی‌ها را ببینند
        if not self.request.user.is_superuser:
            queryset = queryset.filter(user=self.request.user)
        
        # فیلتر کاربر
        user_id = self.request.query_params.get('user')
        if user_id:
            queryset = queryset.filter(user_id=user_id)
        
        # فیلتر مکان
        location_id = self.request.query_params.get('location')
        if location_id:
            queryset = queryset.filter(location_id=location_id)
        
        return queryset.select_related('user', 'location', 'granted_by')
    
    def perform_create(self, serializer):
        access = serializer.save(granted_by=self.request.user)
        
        # پاک کردن کش مربوطه
        cache_key = f"location_tree_{access.user.id}"
        cache.delete(cache_key)
        
        # ثبت لاگ تخصیص دسترسی
        AuditLog.objects.create(
            user=self.request.user,
            user_email=self.request.user.email,
            action='permission_changed',
            resource_type='LocationAccess',
            resource_id=str(access.id),
            description=f'دسترسی مکانی به {access.user.email} داده شد',
            new_values={
                'user': access.user.email,
                'location': access.location.name,
                'can_read': access.can_read,
                'can_write': access.can_write,
                'can_delete': access.can_delete,
                'can_admin': access.can_admin
            },
            ip_address=get_client_ip(self.request),
            user_agent=self.request.META.get('HTTP_USER_AGENT', ''),
            request_path=self.request.path,
            request_method=self.request.method,
            risk_level='high'
        )


@api_view(['GET'])
@permission_classes([permissions.IsAuthenticated])
def user_accessible_locations(request):
    """دریافت مکان‌های قابل دسترسی برای کاربر"""
    
    user = request.user
    
    # استفاده از کش
    cache_key = f"user_locations_{user.id}"
    cached_data = cache.get(cache_key)
    
    if cached_data:
        return Response(cached_data)
    
    # دریافت دسترسی‌های مستقیم
    direct_accesses = UserLocationAccess.objects.filter(
        user=user,
        is_active=True
    ).select_related('location')
    
    accessible_locations = []
    
    for access in direct_accesses:
        location_data = {
            'id': str(access.location.id),
            'name': access.location.name,
            'path': access.location.path,
            'type': access.location.type,
            'permissions': {
                'can_read': access.can_read,
                'can_write': access.can_write,
                'can_delete': access.can_delete,
                'can_admin': access.can_admin
            },
            'accessible_fields': access.accessible_fields,
            'restricted_fields': access.restricted_fields
        }
        
        accessible_locations.append(location_data)
        
        # اگر ارث‌بری فعال باشد، فرزندان را هم اضافه کن
        if access.inherit_to_children:
            children = access.location.get_descendants()
            for child in children:
                child_data = {
                    'id': str(child.id),
                    'name': child.name,
                    'path': child.path,
                    'type': child.type,
                    'permissions': {
                        'can_read': access.can_read,
                        'can_write': access.can_write,
                        'can_delete': access.can_delete,
                        'can_admin': access.can_admin
                    },
                    'accessible_fields': access.accessible_fields,
                    'restricted_fields': access.restricted_fields,
                    'inherited_from': str(access.location.id)
                }
                accessible_locations.append(child_data)
    
    # ذخیره در کش برای 10 دقیقه
    cache.set(cache_key, accessible_locations, 600)
    
    return Response(accessible_locations)
</code></pre>
                </div>
            </div>
        </div>

        <!-- مجوزها -->
        <div class="section" id="permissions">
            <div class="section-header">
                <h2><span class="icon">🔐</span>سیستم مجوزها</h2>
            </div>
            <div class="section-content">
                <div class="explanation">
                    <h4>کنترل دسترسی پیشرفته</h4>
                    <p>سیستم مجوزهای سفارشی برای کنترل دقیق دسترسی‌ها بر اساس مکان و فیلدها.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">apps/locations/permissions.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from rest_framework import permissions
from django.utils import timezone
from django.db.models import Q
from .models import UserLocationAccess
from apps.audit.models import AuditLog, SecurityAlert
from apps.authentication.utils import get_client_ip


class LocationPermission(permissions.BasePermission):
    """مجوز دسترسی مکانی"""
    
    def has_permission(self, request, view):
        """بررسی مجوز کلی"""
        if not request.user.is_authenticated:
            return False
        
        # سوپر یوزر همه دسترسی‌ها را دارد
        if request.user.is_superuser:
            return True
        
        # بررسی دسترسی بر اساس متد درخواست
        if request.method in permissions.SAFE_METHODS:
            return True  # خواندن برای همه کاربران احراز هویت شده
        
        # برای عملیات تغییر، نیاز به بررسی دقیق‌تر
        return True
    
    def has_object_permission(self, request, view, obj):
        """بررسی مجوز روی شیء خاص"""
        if request.user.is_superuser:
            return True
        
        # دریافت دسترسی کاربر به این مکان
        access = self._get_user_access(request.user, obj)
        
        if not access:
            # ثبت تلاش دسترسی غیرمجاز
            self._log_unauthorized_access(request, obj)
            return False
        
        # بررسی نوع عملیات
        if request.method in permissions.SAFE_METHODS:
            return access.can_read
        elif request.method in ['POST', 'PUT', 'PATCH']:
            return access.can_write
        elif request.method == 'DELETE':
            return access.can_delete
        
        return False
    
    def _get_user_access(self, user, location):
        """دریافت دسترسی کاربر به مکان"""
        try:
            # جستجوی دسترسی مستقیم
            access = UserLocationAccess.objects.get(
                user=user,
                location=location,
                is_active=True,
                valid_from__lte=timezone.now()
            )
            
            # بررسی تاریخ انقضا
            if access.valid_until and access.valid_until < timezone.now():
                return None
            
            return access
            
        except UserLocationAccess.DoesNotExist:
            # جستجوی دسترسی ارثی از والدین
            ancestors = location.get_ancestors()
            
            for ancestor in ancestors:
                try:
                    access = UserLocationAccess.objects.get(
                        user=user,
                        location=ancestor,
                        is_active=True,
                        inherit_to_children=True,
                        valid_from__lte=timezone.now()
                    )
                    
                    if not access.valid_until or access.valid_until >= timezone.now():
                        return access
                        
                except UserLocationAccess.DoesNotExist:
                    continue
            
            return None
    
    def _log_unauthorized_access(self, request, obj):
        """ثبت تلاش دسترسی غیرمجاز"""
        AuditLog.objects.create(
            user=request.user,
            user_email=request.user.email,
            action='access_denied',
            resource_type='Location',
            resource_id=str(obj.id),
            description=f'تلاش دسترسی غیرمجاز به مکان: {obj.name}',
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
            request_path=request.path,
            request_method=request.method,
            risk_level='high'
        )
        
        # ایجاد هشدار امنیتی
        SecurityAlert.objects.create(
            alert_type='unauthorized_access',
            severity='warning',
            user=request.user,
            ip_address=get_client_ip(request),
            title='تلاش دسترسی غیرمجاز',
            message=f'کاربر {request.user.email} تلاش دسترسی به مکان {obj.name} را داشت',
            details={
                'location_id': str(obj.id),
                'location_name': obj.name,
                'method': request.method,
                'path': request.path
            }
        )


class FieldLevelPermission:
    """کنترل دسترسی در سطح فیلد"""
    
    def __init__(self, user, location):
        self.user = user
        self.location = location
        self.access = self._get_access()
    
    def _get_access(self):
        """دریافت دسترسی کاربر"""
        if self.user.is_superuser:
            return None  # سوپر یوزر همه دسترسی‌ها را دارد
        
        try:
            return UserLocationAccess.objects.get(
                user=self.user,
                location=self.location,
                is_active=True,
                valid_from__lte=timezone.now()
            )
        except UserLocationAccess.DoesNotExist:
            return None
    
    def can_access_field(self, field_name):
        """بررسی دسترسی به فیلد خاص"""
        if not self.access:
            return False
        
        # اگر فیلد در لیست محدود باشد
        if field_name in self.access.restricted_fields:
            return False
        
        # اگر لیست فیلدهای قابل دسترسی تعریف شده باشد
        if self.access.accessible_fields:
            return field_name in self.access.accessible_fields
        
        # در غیر این صورت دسترسی آزاد
        return True
    
    def filter_fields(self, data):
        """فیلتر کردن فیلدهای قابل دسترسی"""
        if self.user.is_superuser:
            return data
        
        if not self.access:
            return {}
        
        filtered_data = {}
        
        for field_name, value in data.items():
            if self.can_access_field(field_name):
                filtered_data[field_name] = value
        
        return filtered_data


class RoleBasedPermission(permissions.BasePermission):
    """مجوز بر اساس نقش"""
    
    def has_permission(self, request, view):
        if not request.user.is_authenticated:
            return False
        
        if request.user.is_superuser:
            return True
        
        # دریافت نقش‌های فعال کاربر
        active_roles = request.user.user_roles.filter(
            is_active=True,
            valid_from__lte=timezone.now()
        ).filter(
            Q(valid_until__isnull=True) | 
            Q(valid_until__gte=timezone.now())
        )
        
        # بررسی مجوزهای نقش‌ها
        for user_role in active_roles:
            role_permissions = user_role.role.permissions
            
            # بررسی مجوز بر اساس متد درخواست
            if request.method in permissions.SAFE_METHODS:
                if role_permissions.get('can_read', user_role.role.default_read_access):
                    return True
            elif request.method in ['POST', 'PUT', 'PATCH']:
                if role_permissions.get('can_write', user_role.role.default_write_access):
                    return True
            elif request.method == 'DELETE':
                if role_permissions.get('can_delete', user_role.role.default_delete_access):
                    return True
        
        return False


class IPWhitelistPermission(permissions.BasePermission):
    """محدودیت بر اساس IP"""
    
    ALLOWED_IPS = [
        '127.0.0.1',
        '192.168.1.0/24',  # شبکه داخلی
        # IP های مجاز شهرداری
    ]
    
    def has_permission(self, request, view):
        client_ip = get_client_ip(request)
        
        # بررسی IP در لیست مجاز
        for allowed_ip in self.ALLOWED_IPS:
            if '/' in allowed_ip:  # CIDR notation
                from ipaddress import ip_network, ip_address
                if ip_address(client_ip) in ip_network(allowed_ip):
                    return True
            else:
                if client_ip == allowed_ip:
                    return True
        
        # ثبت تلاش دسترسی از IP غیرمجاز
        SecurityAlert.objects.create(
            alert_type='unauthorized_access',
            severity='error',
            user=request.user if request.user.is_authenticated else None,
            ip_address=client_ip,
            title='دسترسی از IP غیرمجاز',
            message=f'تلاش دسترسی از IP غیرمجاز: {client_ip}',
            details={
                'path': request.path,
                'method': request.method,
                'user_agent': request.META.get('HTTP_USER_AGENT', '')
            }
        )
        
        return False


class TimeBasedPermission(permissions.BasePermission):
    """محدودیت بر اساس زمان"""
    
    ALLOWED_HOURS = range(8, 18)  # 8 صبح تا 6 عصر
    ALLOWED_DAYS = [0, 1, 2, 3, 4]  # دوشنبه تا جمعه
    
    def has_permission(self, request, view):
        from datetime import datetime
        import pytz
        
        # تنظیم منطقه زمانی ایران
        iran_tz = pytz.timezone('Asia/Tehran')
        now = datetime.now(iran_tz)
        
        # بررسی ساعت کاری
        if now.hour not in self.ALLOWED_HOURS:
            return False
        
        # بررسی روزهای کاری
        if now.weekday() not in self.ALLOWED_DAYS:
            return False
        
        return True
</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                 <span class="file-name">apps/authentication/utils.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">import re
import hashlib
from datetime import datetime, timedelta
from django.core.cache import cache
from django.conf import settings
from django.contrib.gis.geoip2 import GeoIP2
from django.core.exceptions import ValidationError
from user_agents import parse
import logging

logger = logging.getLogger(__name__)


def get_client_ip(request):
    """دریافت IP واقعی کلاینت"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0].strip()
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip


def get_client_location(ip_address):
    """دریافت موقعیت جغرافیایی بر اساس IP"""
    try:
        g = GeoIP2()
        location = g.city(ip_address)
        return {
            'country': location.get('country_name'),
            'city': location.get('city'),
            'latitude': location.get('latitude'),
            'longitude': location.get('longitude')
        }
    except Exception as e:
        logger.warning(f"Could not get location for IP {ip_address}: {e}")
        return None


def parse_user_agent(user_agent_string):
    """تجزیه User Agent"""
    try:
        user_agent = parse(user_agent_string)
        return {
            'browser': f"{user_agent.browser.family} {user_agent.browser.version_string}",
            'os': f"{user_agent.os.family} {user_agent.os.version_string}",
            'device': user_agent.device.family,
            'is_mobile': user_agent.is_mobile,
            'is_tablet': user_agent.is_tablet,
            'is_bot': user_agent.is_bot
        }
    except Exception as e:
        logger.warning(f"Could not parse user agent: {e}")
        return {}


def detect_suspicious_activity(user, ip_address):
    """تشخیص فعالیت مشکوک"""
    suspicious_indicators = []
    
    # بررسی IP جدید
    if user.last_login_ip and user.last_login_ip != ip_address:
        suspicious_indicators.append('new_ip')
        
        # بررسی موقعیت جغرافیایی
        current_location = get_client_location(ip_address)
        last_location = get_client_location(user.last_login_ip)
        
        if current_location and last_location:
            # محاسبه فاصله (ساده)
            if (current_location['country'] != last_location['country'] or 
                current_location['city'] != last_location['city']):
                suspicious_indicators.append('location_change')
    
    # بررسی زمان ورود غیرعادی
    now = datetime.now()
    if now.hour < 6 or now.hour > 22:  # خارج از ساعات عادی
        suspicious_indicators.append('unusual_time')
    
    # بررسی تعداد تلاش‌های اخیر
    cache_key = f"login_attempts_{ip_address}"
    recent_attempts = cache.get(cache_key, 0)
    if recent_attempts > 3:
        suspicious_indicators.append('multiple_attempts')
    
    return len(suspicious_indicators) > 0


def validate_iranian_national_code(national_code):
    """اعتبارسنجی کد ملی ایرانی"""
    if not national_code or len(national_code) != 10:
        raise ValidationError('کد ملی باید 10 رقم باشد')
    
    if not national_code.isdigit():
        raise ValidationError('کد ملی باید فقط شامل عدد باشد')
    
    # بررسی کدهای غیرمعتبر
    invalid_codes = [
        '0000000000', '1111111111', '2222222222', '3333333333',
        '4444444444', '5555555555', '6666666666', '7777777777',
        '8888888888', '9999999999'
    ]
    
    if national_code in invalid_codes:
        raise ValidationError('کد ملی وارد شده معتبر نیست')
    
    # الگوریتم اعتبارسنجی
    check = 0
    for i in range(9):
        check += int(national_code[i]) * (10 - i)
    
    check = check % 11
    
    if check < 2:
        if int(national_code[9]) != check:
            raise ValidationError('کد ملی وارد شده معتبر نیست')
    else:
        if int(national_code[9]) != 11 - check:
            raise ValidationError('کد ملی وارد شده معتبر نیست')
    
    return national_code


def validate_iranian_phone_number(phone_number):
    """اعتبارسنجی شماره تلفن ایرانی"""
    # حذف کاراکترهای غیرضروری
    phone_number = re.sub(r'[^\d+]', '', phone_number)
    
    # الگوهای معتبر
    patterns = [
        r'^09\d{9}$',  # 09xxxxxxxxx
        r'^\+989\d{9}$',  # +989xxxxxxxxx
        r'^00989\d{9}$',  # 00989xxxxxxxxx
    ]
    
    for pattern in patterns:
        if re.match(pattern, phone_number):
            # تبدیل به فرمت استاندارد
            if phone_number.startswith('+98'):
                return '0' + phone_number[3:]
            elif phone_number.startswith('0098'):
                return '0' + phone_number[4:]
            else:
                return phone_number
    
    raise ValidationError('شماره تلفن وارد شده معتبر نیست')


def generate_secure_token(length=32):
    """تولید توکن امن"""
    import secrets
    return secrets.token_urlsafe(length)


def hash_sensitive_data(data):
    """هش کردن داده‌های حساس"""
    return hashlib.sha256(data.encode()).hexdigest()


def rate_limit_check(identifier, limit=5, window=300):
    """بررسی محدودیت نرخ درخواست"""
    cache_key = f"rate_limit_{identifier}"
    current_requests = cache.get(cache_key, 0)
    
    if current_requests >= limit:
        return False
    
    # افزایش شمارنده
    cache.set(cache_key, current_requests + 1, window)
    return True


def log_security_event(event_type, user, ip_address, details=None):
    """ثبت رویداد امنیتی"""
    from apps.audit.models import SecurityAlert
    
    SecurityAlert.objects.create(
        alert_type=event_type,
        severity='warning',
        user=user,
        ip_address=ip_address,
        title=f'رویداد امنیتی: {event_type}',
        message=f'رویداد امنیتی برای کاربر {user.email if user else "ناشناس"}',
        details=details or {}
    )


class PasswordStrengthValidator:
    """اعتبارسنج قدرت رمز عبور"""
    
    def __init__(self, min_length=8):
        self.min_length = min_length
    
    def validate(self, password, user=None):
        errors = []
        
        # طول رمز عبور
        if len(password) < self.min_length:
            errors.append(f'رمز عبور باید حداقل {self.min_length} کاراکتر باشد')
        
        # وجود حروف بزرگ
        if not re.search(r'[A-Z]', password):
            errors.append('رمز عبور باید شامل حداقل یک حرف بزرگ باشد')
        
        # وجود حروف کوچک
        if not re.search(r'[a-z]', password):
            errors.append('رمز عبور باید شامل حداقل یک حرف کوچک باشد')
        
        # وجود عدد
        if not re.search(r'\d', password):
            errors.append('رمز عبور باید شامل حداقل یک عدد باشد')
        
        # وجود کاراکتر خاص
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
            errors.append('رمز عبور باید شامل حداقل یک کاراکتر خاص باشد')
        
        # بررسی عدم استفاده از اطلاعات کاربر
        if user:
            user_info = [
                user.email.split('@')[0].lower(),
                user.first_name.lower(),
                user.last_name.lower(),
                user.username.lower() if user.username else ''
            ]
            
            for info in user_info:
                if info and info in password.lower():
                    errors.append('رمز عبور نباید شامل اطلاعات شخصی باشد')
                    break
        
        if errors:
            raise ValidationError(errors)
    
    def get_help_text(self):
        return (
            f'رمز عبور باید حداقل {self.min_length} کاراکتر و شامل '
            'حروف بزرگ، کوچک، عدد و کاراکتر خاص باشد'
        )


def check_password_breach(password):
    """بررسی رمز عبور در پایگاه داده نشت‌ها"""
    import hashlib
    import requests
    
    # محاسبه SHA-1 hash
    sha1_hash = hashlib.sha1(password.encode()).hexdigest().upper()
    prefix = sha1_hash[:5]
    suffix = sha1_hash[5:]
    
    try:
        # استعلام از Have I Been Pwned API
        response = requests.get(
            f'https://api.pwnedpasswords.com/range/{prefix}',
            timeout=5
        )
        
        if response.status_code == 200:
            hashes = response.text.split('\n')
            for hash_line in hashes:
                if ':' in hash_line:
                    hash_suffix, count = hash_line.split(':')
                    if hash_suffix == suffix:
                        return int(count)
        
        return 0
        
    except Exception as e:
        logger.warning(f"Could not check password breach: {e}")
        return 0


def generate_otp(length=6):
    """تولید رمز یکبار مصرف"""
    import random
    return ''.join([str(random.randint(0, 9)) for _ in range(length)])


def send_sms(phone_number, message):
    """ارسال پیامک"""
    # پیاده‌سازی ارسال پیامک با سرویس مورد نظر
    # مثال: کاوه نگار، ملی پیامک و ...
    
    try:
        # کد ارسال پیامک
        logger.info(f"SMS sent to {phone_number}: {message}")
        return True
    except Exception as e:
        logger.error(f"Failed to send SMS: {e}")
        return False


def send_email_notification(email, subject, message):
    """ارسال ایمیل اطلاع‌رسانی"""
    from django.core.mail import send_mail
    from django.conf import settings
    
    try:
        send_mail(
            subject=subject,
            message=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[email],
            fail_silently=False
        )
        return True
    except Exception as e:
        logger.error(f"Failed to send email: {e}")
        return False


class SessionManager:
    """مدیریت نشست‌های کاربری"""
    
    @staticmethod
    def get_active_sessions(user):
        """دریافت نشست‌های فعال کاربر"""
        from django.contrib.sessions.models import Session
        from django.utils import timezone
        
        sessions = Session.objects.filter(expire_date__gte=timezone.now())
        user_sessions = []
        
        for session in sessions:
            data = session.get_decoded()
            if data.get('_auth_user_id') == str(user.id):
                user_sessions.append({
                    'session_key': session.session_key,
                    'expire_date': session.expire_date,
                    'ip_address': data.get('ip_address'),
                    'user_agent': data.get('user_agent')
                })
        
        return user_sessions
    
    @staticmethod
    def terminate_session(session_key):
        """پایان دادن به نشست"""
        from django.contrib.sessions.models import Session
        
        try:
            session = Session.objects.get(session_key=session_key)
            session.delete()
            return True
        except Session.DoesNotExist:
            return False
    
    @staticmethod
    def terminate_all_sessions(user):
        """پایان دادن به همه نشست‌های کاربر"""
        sessions = SessionManager.get_active_sessions(user)
        for session in sessions:
            SessionManager.terminate_session(session['session_key'])
        return len(sessions)
</code></pre>
                </div>
            </div>
        </div>

        <!-- تنظیمات -->
        <div class="section" id="settings">
            <div class="section-header">
                <h2><span class="icon">⚙️</span>تنظیمات پروژه</h2>
            </div>
            <div class="section-content">
                <div class="explanation">
                    <h4>پیکربندی Django</h4>
                    <p>تنظیمات امنیتی و عملکردی پروژه شامل پایگاه داده، کش، امنیت و JWT.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">config/settings/base.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">import os
from pathlib import Path
from datetime import timedelta

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.environ.get('SECRET_KEY', 'your-secret-key-here')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.environ.get('DEBUG', 'False').lower() == 'true'

ALLOWED_HOSTS = os.environ.get('ALLOWED_HOSTS', 'localhost,127.0.0.1').split(',')

# Application definition
DJANGO_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',
]

THIRD_PARTY_APPS = [
    'rest_framework',
    'rest_framework_gis',
    'rest_framework_simplejwt',
    'corsheaders',
    'django_filters',
    'drf_spectacular',
    'django_extensions',
]

LOCAL_APPS = [
    'apps.authentication',
    'apps.locations',
    'apps.audit',
    'apps.core',
]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'apps.core.middleware.AuditMiddleware',
    'apps.core.middleware.SecurityMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': os.environ.get('DB_NAME', 'location_auth_db'),
        'USER': os.environ.get('DB_USER', 'postgres'),
        'PASSWORD': os.environ.get('DB_PASSWORD', 'password'),
        'HOST': os.environ.get('DB_HOST', 'localhost'),
        'PORT': os.environ.get('DB_PORT', '5432'),
        'OPTIONS': {
            'sslmode': 'require' if not DEBUG else 'prefer',
        }
    }
}

# Cache Configuration
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': os.environ.get('REDIS_URL', 'redis://localhost:6379/1'),
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'max_connections': 20,
                'retry_on_timeout': True,
            }
        },
        'KEY_PREFIX': 'location_auth',
        'TIMEOUT': 300,  # 5 minutes default
    }
}

# Custom User Model
AUTH_USER_MODEL = 'authentication.CustomUser'

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 8,
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
    {
        'NAME': 'apps.authentication.utils.PasswordStrengthValidator',
        'OPTIONS': {
            'min_length': 8,
        }
    },
]

# Internationalization
LANGUAGE_CODE = 'fa-ir'
TIME_ZONE = 'Asia/Tehran'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'
STATICFILES_DIRS = [
    BASE_DIR / 'static',
]

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# REST Framework Configuration
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.MultiPartParser',
        'rest_framework.parsers.FormParser',
    ],
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
        'rest_framework.filters.SearchFilter',
        'rest_framework.filters.OrderingFilter',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20,
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
    'EXCEPTION_HANDLER': 'apps.core.exceptions.custom_exception_handler',
}

# JWT Configuration
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': True,
    
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUDIENCE': None,
    'ISSUER': None,
    
    'AUTH_HEADER_TYPES': ('Bearer',),
    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'USER_AUTHENTICATION_RULE': 'rest_framework_simplejwt.authentication.default_user_authentication_rule',
    
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
    
    'JTI_CLAIM': 'jti',
    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',
    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=60),
    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),
}

# CORS Configuration
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",  # React development server
    "http://127.0.0.1:3000",
    "https://your-frontend-domain.com",
]

CORS_ALLOW_CREDENTIALS = True

# Security Settings
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'
SECURE_HSTS_SECONDS = 31536000 if not DEBUG else 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# Session Configuration
SESSION_COOKIE_SECURE = not DEBUG
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Lax'
SESSION_COOKIE_AGE = 3600  # 1 hour

CSRF_COOKIE_SECURE = not DEBUG
CSRF_COOKIE_HTTPONLY = True
CSRF_COOKIE_SAMESITE = 'Lax'

# Email Configuration
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = os.environ.get('EMAIL_HOST', 'smtp.gmail.com')
EMAIL_PORT = int(os.environ.get('EMAIL_PORT', '587'))
EMAIL_USE_TLS = True
EMAIL_HOST_USER = os.environ.get('EMAIL_HOST_USER', '')
EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_HOST_PASSWORD', '')
DEFAULT_FROM_EMAIL = os.environ.get('DEFAULT_FROM_EMAIL', 'noreply@municipality.ir')

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': BASE_DIR / 'logs' / 'django.log',
            'maxBytes': 1024*1024*15,  # 15MB
            'backupCount': 10,
            'formatter': 'verbose',
        },
        'security_file': {
            'level': 'WARNING',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': BASE_DIR / 'logs' / 'security.log',
            'maxBytes': 1024*1024*15,  # 15MB
            'backupCount': 10,
            'formatter': 'verbose',
        },
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
        'apps.authentication': {
            'handlers': ['file', 'security_file', 'console'],
            'level': 'INFO',
            'propagate': False,
        },
        'apps.audit': {
            'handlers': ['security_file', 'console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# API Documentation
SPECTACULAR_SETTINGS = {
    'TITLE': 'Location-Based Authentication API',
    'DESCRIPTION': 'سیستم احراز هویت و کنترل دسترسی مکانی',
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA': False,
    'COMPONENT_SPLIT_REQUEST': True,
    'SCHEMA_PATH_PREFIX': '/api/v1/',
}

# Custom Settings
MUNICIPALITY_SETTINGS = {
    'MAX_LOGIN_ATTEMPTS': 5,
    'ACCOUNT_LOCKOUT_DURATION': 30,  # minutes
    'PASSWORD_RESET_TIMEOUT': 3600,  # seconds
    'OTP_EXPIRY': 300,  # 5 minutes
    'SESSION_TIMEOUT': 3600,  # 1 hour
    'MAX_CONCURRENT_SESSIONS': 3,
    'ENABLE_GIS_FEATURES': True,
    'DEFAULT_LOCATION_RADIUS': 1000,  # meters
    'AUDIT_LOG_RETENTION_DAYS': 365,
    'SECURITY_ALERT_RETENTION_DAYS': 90,
}

# File Upload Settings
FILE_UPLOAD_MAX_MEMORY_SIZE = 5242880  # 5MB
DATA_UPLOAD_MAX_MEMORY_SIZE = 5242880  # 5MB
FILE_UPLOAD_PERMISSIONS = 0o644

# GIS Settings
GDAL_LIBRARY_PATH = os.environ.get('GDAL_LIBRARY_PATH')
GEOS_LIBRARY_PATH = os.environ.get('GEOS_LIBRARY_PATH')

# Rate Limiting
RATELIMIT_ENABLE = True
RATELIMIT_USE_CACHE = 'default'
</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">config/settings/production.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from .base import *
import os

# Security Settings for Production
DEBUG = False

ALLOWED_HOSTS = os.environ.get('ALLOWED_HOSTS', '').split(',')

# Database with SSL
DATABASES['default'].update({
    'OPTIONS': {
        'sslmode': 'require',
        'sslcert': os.environ.get('DB_SSL_CERT'),
        'sslkey': os.environ.get('DB_SSL_KEY'),
        'sslrootcert': os.environ.get('DB_SSL_ROOT_CERT'),
    }
})

# Redis with SSL
CACHES['default']['LOCATION'] = os.environ.get('REDIS_URL')
CACHES['default']['OPTIONS'].update({
    'CONNECTION_POOL_KWARGS': {
        'ssl_cert_reqs': 'required',
        'ssl_ca_certs': os.environ.get('REDIS_SSL_CA_CERTS'),
    }
})

# Security Headers
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# Session Security
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True

# CORS for Production
CORS_ALLOWED_ORIGINS = [
    "https://municipality-frontend.ir",
    "https://admin.municipality.ir",
]

# Logging for Production
LOGGING['handlers']['file']['filename'] = '/var/log/municipality/django.log'
LOGGING['handlers']['security_file']['filename'] = '/var/log/municipality/security.log'

# Remove console handler in production
LOGGING['loggers']['django']['handlers'] = ['file']
LOGGING['loggers']['apps.authentication']['handlers'] = ['file', 'security_file']
LOGGING['loggers']['apps.audit']['handlers'] = ['security_file']

# Static Files with CDN
STATIC_URL = 'https://cdn.municipality.ir/static/'
MEDIA_URL = 'https://cdn.municipality.ir/media/'

# Email with Production SMTP
EMAIL_HOST = os.environ.get('EMAIL_HOST')
EMAIL_HOST_USER = os.environ.get('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_HOST_PASSWORD')

# Performance Optimizations
CONN_MAX_AGE = 60

# Performance Optimizations
CONN_MAX_AGE = 60

# Sentry for Error Tracking
if os.environ.get('SENTRY_DSN'):
    import sentry_sdk
    from sentry_sdk.integrations.django import DjangoIntegration
    from sentry_sdk.integrations.redis import RedisIntegration
    
    sentry_sdk.init(
        dsn=os.environ.get('SENTRY_DSN'),
        integrations=[
            DjangoIntegration(auto_enabling=True),
            RedisIntegration(),
        ],
        traces_sample_rate=0.1,
        send_default_pii=True,
        environment='production'
    )

# File Storage with S3/MinIO
DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
STATICFILES_STORAGE = 'storages.backends.s3boto3.StaticS3Boto3Storage'

AWS_ACCESS_KEY_ID = os.environ.get('AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = os.environ.get('AWS_SECRET_ACCESS_KEY')
AWS_STORAGE_BUCKET_NAME = os.environ.get('AWS_STORAGE_BUCKET_NAME')
AWS_S3_ENDPOINT_URL = os.environ.get('AWS_S3_ENDPOINT_URL')  # For MinIO
AWS_S3_CUSTOM_DOMAIN = os.environ.get('AWS_S3_CUSTOM_DOMAIN')
AWS_DEFAULT_ACL = 'private'
AWS_S3_FILE_OVERWRITE = False
</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">config/urls.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView

urlpatterns = [
    # Admin
    path('admin/', admin.site.urls),
    
    # API Documentation
    path('api/schema/', SpectacularAPIView.as_view(), name='schema'),
    path('api/docs/', SpectacularSwaggerView.as_view(url_name='schema'), name='swagger-ui'),
    
    # API Routes
    path('api/v1/auth/', include('apps.authentication.urls')),
    path('api/v1/locations/', include('apps.locations.urls')),
    path('api/v1/audit/', include('apps.audit.urls')),
    
    # Health Check
    path('health/', include('apps.core.urls')),
]

# Serve media files in development
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

# Custom error handlers
handler400 = 'apps.core.views.bad_request'
handler403 = 'apps.core.views.permission_denied'
handler404 = 'apps.core.views.page_not_found'
handler500 = 'apps.core.views.server_error'
</code></pre>
                </div>
            </div>
        </div>

        <!-- میدل‌ور -->
        <div class="section" id="middleware">
            <div class="section-header">
                <h2><span class="icon">🔗</span>میدل‌ور امنیتی</h2>
            </div>
            <div class="section-content">
                <div class="explanation">
                    <h4>لایه‌های امنیتی میانی</h4>
                    <p>میدل‌ورهای سفارشی برای کنترل امنیت، ثبت لاگ و محدودیت نرخ درخواست.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">apps/core/middleware.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">import time
import json
import logging
from django.utils.deprecation import MiddlewareMixin
from django.core.cache import cache
from django.http import JsonResponse
from django.conf import settings
from django.utils import timezone
from apps.authentication.utils import get_client_ip, parse_user_agent
from apps.audit.models import AuditLog, SecurityAlert

logger = logging.getLogger(__name__)


class AuditMiddleware(MiddlewareMixin):
    """میدل‌ور ثبت لاگ درخواست‌ها"""
    
    def process_request(self, request):
        request.start_time = time.time()
        request.client_ip = get_client_ip(request)
        request.user_agent_info = parse_user_agent(
            request.META.get('HTTP_USER_AGENT', '')
        )
    
    def process_response(self, request, response):
        # محاسبه زمان پردازش
        if hasattr(request, 'start_time'):
            processing_time = time.time() - request.start_time
        else:
            processing_time = 0
        
        # ثبت درخواست‌های مهم
        if self._should_log_request(request, response):
            self._log_request(request, response, processing_time)
        
        return response
    
    def _should_log_request(self, request, response):
        """تعیین اینکه آیا درخواست باید لاگ شود یا نه"""
        # لاگ درخواست‌های ناموفق
        if response.status_code >= 400:
            return True
        
        # لاگ عملیات تغییر داده
        if request.method in ['POST', 'PUT', 'PATCH', 'DELETE']:
            return True
        
        # لاگ درخواست‌های احراز هویت
        if '/auth/' in request.path:
            return True
        
        return False
    
    def _log_request(self, request, response, processing_time):
        """ثبت لاگ درخواست"""
        try:
            # تعیین سطح ریسک
            risk_level = 'low'
            if response.status_code >= 500:
                risk_level = 'high'
            elif response.status_code >= 400:
                risk_level = 'medium'
            elif request.method in ['POST', 'PUT', 'PATCH', 'DELETE']:
                risk_level = 'medium'
            
            # ثبت در پایگاه داده
            AuditLog.objects.create(
                user=request.user if request.user.is_authenticated else None,
                user_email=request.user.email if request.user.is_authenticated else None,
                action='http_request',
                resource_type='HTTP',
                description=f'{request.method} {request.path}',
                ip_address=request.client_ip,
                user_agent=request.META.get('HTTP_USER_AGENT', ''),
                request_path=request.path,
                request_method=request.method,
                response_status=response.status_code,
                processing_time=processing_time,
                risk_level=risk_level,
                details={
                    'query_params': dict(request.GET),
                    'content_type': request.content_type,
                    'response_size': len(response.content) if hasattr(response, 'content') else 0,
                    'user_agent_info': request.user_agent_info
                }
            )
            
        except Exception as e:
            logger.error(f"Failed to log request: {e}")


class SecurityMiddleware(MiddlewareMixin):
    """میدل‌ور امنیتی"""
    
    def process_request(self, request):
        client_ip = get_client_ip(request)
        
        # بررسی IP در لیست سیاه
        if self._is_blacklisted_ip(client_ip):
            return JsonResponse({
                'error': 'دسترسی از این IP مسدود شده است'
            }, status=403)
        
        # بررسی محدودیت نرخ درخواست
        if not self._check_rate_limit(request):
            return JsonResponse({
                'error': 'تعداد درخواست‌های شما از حد مجاز بیشتر است'
            }, status=429)
        
        # بررسی User Agent مشکوک
        if self._is_suspicious_user_agent(request):
            self._log_suspicious_activity(request, 'suspicious_user_agent')
        
        # بررسی درخواست‌های مشکوک
        if self._is_suspicious_request(request):
            self._log_suspicious_activity(request, 'suspicious_request')
        
        return None
    
    def _is_blacklisted_ip(self, ip):
        """بررسی IP در لیست سیاه"""
        blacklist_key = f"blacklist_ip_{ip}"
        return cache.get(blacklist_key, False)
    
    def _check_rate_limit(self, request):
        """بررسی محدودیت نرخ درخواست"""
        client_ip = get_client_ip(request)
        
        # محدودیت کلی بر اساس IP
        ip_key = f"rate_limit_ip_{client_ip}"
        ip_requests = cache.get(ip_key, 0)
        
        if ip_requests >= 100:  # 100 درخواست در دقیقه
            return False
        
        cache.set(ip_key, ip_requests + 1, 60)  # 1 دقیقه
        
        # محدودیت برای کاربران احراز هویت شده
        if request.user.is_authenticated:
            user_key = f"rate_limit_user_{request.user.id}"
            user_requests = cache.get(user_key, 0)
            
            if user_requests >= 200:  # 200 درخواست در دقیقه
                return False
            
            cache.set(user_key, user_requests + 1, 60)
        
        return True
    
    def _is_suspicious_user_agent(self, request):
        """تشخیص User Agent مشکوک"""
        user_agent = request.META.get('HTTP_USER_AGENT', '').lower()
        
        suspicious_patterns = [
            'bot', 'crawler', 'spider', 'scraper',
            'curl', 'wget', 'python-requests',
            'sqlmap', 'nikto', 'nmap'
        ]
        
        for pattern in suspicious_patterns:
            if pattern in user_agent:
                return True
        
        return False
    
    def _is_suspicious_request(self, request):
        """تشخیص درخواست مشکوک"""
        # بررسی SQL Injection
        sql_patterns = [
            'union select', 'drop table', 'insert into',
            'update set', 'delete from', 'exec(',
            'script>', '<iframe', 'javascript:'
        ]
        
        # بررسی در query parameters
        for key, value in request.GET.items():
            for pattern in sql_patterns:
                if pattern in str(value).lower():
                    return True
        
        # بررسی در POST data
        if request.method == 'POST' and hasattr(request, 'body'):
            try:
                body = request.body.decode('utf-8').lower()
                for pattern in sql_patterns:
                    if pattern in body:
                        return True
            except:
                pass
        
        return False
    
    def _log_suspicious_activity(self, request, activity_type):
        """ثبت فعالیت مشکوک"""
        SecurityAlert.objects.create(
            alert_type=activity_type,
            severity='warning',
            user=request.user if request.user.is_authenticated else None,
            ip_address=get_client_ip(request),
            title=f'فعالیت مشکوک: {activity_type}',
            message=f'فعالیت مشکوک از IP {get_client_ip(request)} شناسایی شد',
            details={
                'path': request.path,
                'method': request.method,
                'user_agent': request.META.get('HTTP_USER_AGENT', ''),
                'query_params': dict(request.GET),
                'referer': request.META.get('HTTP_REFERER', '')
            }
        )


class SessionSecurityMiddleware(MiddlewareMixin):
    """میدل‌ور امنیت نشست"""
    
    def process_request(self, request):
        if request.user.is_authenticated:
            # بررسی تغییر IP
            session_ip = request.session.get('ip_address')
            current_ip = get_client_ip(request)
            
            if session_ip and session_ip != current_ip:
                # IP تغییر کرده، نیاز به احراز هویت مجدد
                self._log_ip_change(request, session_ip, current_ip)
                
                # در صورت تنظیم سختگیرانه، نشست را پاک کن
                if getattr(settings, 'STRICT_IP_CHECK', False):
                    request.session.flush()
                    return JsonResponse({
                        'error': 'نشست شما به دلیل تغییر IP منقضی شد'
                    }, status=401)
            
            # ذخیره IP فعلی
            request.session['ip_address'] = current_ip
            
            # بررسی انقضای نشست
            last_activity = request.session.get('last_activity')
            if last_activity:
                from datetime import datetime
                last_time = datetime.fromisoformat(last_activity)
                timeout = getattr(settings, 'SESSION_TIMEOUT', 3600)
                
                if (timezone.now() - last_time).seconds > timeout:
                    request.session.flush()
                    return JsonResponse({
                        'error': 'نشست شما منقضی شده است'
                    }, status=401)
            
            # بروزرسانی زمان آخرین فعالیت
            request.session['last_activity'] = timezone.now().isoformat()
    
    def _log_ip_change(self, request, old_ip, new_ip):
        """ثبت لاگ تغییر IP"""
        AuditLog.objects.create(
            user=request.user,
            user_email=request.user.email,
            action='ip_changed',
            resource_type='Session',
            description=f'IP کاربر تغییر کرد از {old_ip} به {new_ip}',
            ip_address=new_ip,
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
            request_path=request.path,
            request_method=request.method,
            risk_level='medium',
            old_values={'ip_address': old_ip},
            new_values={'ip_address': new_ip}
        )


class CORSSecurityMiddleware(MiddlewareMixin):
    """میدل‌ور امنیت CORS"""
    
    def process_response(self, request, response):
        # تنظیم هدرهای امنیتی
        response['X-Content-Type-Options'] = 'nosniff'
        response['X-Frame-Options'] = 'DENY'
        response['X-XSS-Protection'] = '1; mode=block'
        response['Referrer-Policy'] = 'strict-origin-when-cross-origin'
        
        # Content Security Policy
        csp = (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-inline'; "
            "style-src 'self' 'unsafe-inline'; "
            "img-src 'self' data: https:; "
            "font-src 'self'; "
            "connect-src 'self'; "
            "frame-ancestors 'none';"
        )
        response['Content-Security-Policy'] = csp
        
        return response


class RequestSizeMiddleware(MiddlewareMixin):
    """میدل‌ور محدودیت اندازه درخواست"""
    
    MAX_REQUEST_SIZE = 10 * 1024 * 1024  # 10MB
    
    def process_request(self, request):
        if hasattr(request, 'META'):
            content_length = request.META.get('CONTENT_LENGTH')
            
            if content_length and int(content_length) > self.MAX_REQUEST_SIZE:
                return JsonResponse({
                    'error': 'اندازه درخواست بیش از حد مجاز است'
                }, status=413)
        
        return None


class GeoLocationMiddleware(MiddlewareMixin):
    """میدل‌ور موقعیت جغرافیایی"""
    
    def process_request(self, request):
        if request.user.is_authenticated:
            client_ip = get_client_ip(request)
            
            # دریافت موقعیت جغرافیایی از IP
            try:
                from apps.authentication.utils import get_client_location
                location = get_client_location(client_ip)
                
                if location:
                    request.geo_location = location
                    
                    # ذخیره در نشست
                    request.session['geo_location'] = location
                    
                    # بررسی محدودیت جغرافیایی
                    if hasattr(request.user, 'allowed_countries'):
                        allowed_countries = request.user.allowed_countries or []
                        if (allowed_countries and 
                            location.get('country') not in allowed_countries):
                            
                            return JsonResponse({
                                'error': 'دسترسی از این کشور مجاز نیست'
                            }, status=403)
            
            except Exception as e:
                logger.warning(f"Could not get geo location: {e}")
        
        return None
</code></pre>
                </div>
            </div>
        </div>

        <!-- تست‌ها -->
        <div class="section" id="tests">
            <div class="section-header">
                <h2><span class="icon">🧪</span>تست‌های سیستم</h2>
            </div>
            <div class="section-content">
                <div class="explanation">
                    <h4>تست‌های جامع</h4>
                    <p>مجموعه کاملی از تست‌های واحد، یکپارچگی و عملکرد برای اطمینان از کیفیت سیستم.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">tests/test_authentication.py</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-python">import pytest
from django.test import TestCase, TransactionTestCase
from django.contrib.auth import get_user_model
from django.urls import reverse
from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from unittest.mock import patch, Mock
from datetime import datetime, timedelta
from django.utils import timezone

from apps.authentication.models import CustomUser, Role, UserRole
from apps.locations.models import LocationHierarchy, UserLocationAccess
from apps.audit.models import AuditLog, SecurityAlert

User = get_user_model()


class UserModelTest(TestCase):
    """تست مدل کاربر"""
    
    def setUp(self):
        self.user_data = {
            'email': 'test@municipality.ir',
            'password': 'TestPass123!',
            'first_name': 'علی',
            'last_name': 'احمدی',
            'national_code': '1234567890',
            'phone_number': '09123456789',
            'employee_id': 'EMP001'
        }
    
    def test_create_user(self):
        """تست ایجاد کاربر"""
        user = User.objects.create_user(**self.user_data)
        
        self.assertEqual(user.email, self.user_data['email'])
        self.assertTrue(user.check_password(self.user_data['password']))
        self.assertFalse(user.is_superuser)
        self.assertFalse(user.is_staff)
        self.assertTrue(user.is_active)
    
    def test_create_superuser(self):
        """تست ایجاد سوپر یوزر"""
        user = User.objects.create_superuser(
            email='admin@municipality.ir',
            password='AdminPass123!'
        )
        
        self.assertTrue(user.is_superuser)
        self.assertTrue(user.is_staff)
    
    def test_email_normalization(self):
        """تست نرمال‌سازی ایمیل"""
        user = User.objects.create_user(
            email='Test@Municipality.IR',
            password='TestPass123!'
        )
        
        self.assertEqual(user.email, 'test@municipality.ir')
    
    def test_national_code_validation(self):
        """تست اعتبارسنجی کد ملی"""
        # کد ملی نامعتبر
        invalid_data = self.user_data.copy()
        invalid_data['national_code'] = '1234567891'
        
        with self.assertRaises(Exception):
            User.objects.create_user(**invalid_data)
    
    def test_phone_number_validation(self):
        """تست اعتبارسنجی شماره تلفن"""
        # شماره تلفن نامعتبر
        invalid_data = self.user_data.copy()
        invalid_data['phone_number'] = '123456789'
        
        with self.assertRaises(Exception):
            User.objects.create_user(**invalid_data)


class AuthenticationAPITest(APITestCase):
    """تست API احراز هویت"""
    
    def setUp(self):
        self.client = APIClient()
        self.register_url = reverse('authentication:register')
        self.login_url = reverse('authentication:login')
        self.refresh_url = reverse('authentication:token_refresh')
        
        self.user_data = {
            'email': 'test@municipality.ir',
            'password': 'TestPass123!',
            'first_name': 'علی',
            'last_name': 'احمدی',
            'national_code': '0123456789',
            'phone_number': '09123456789'
        }
    
    def test_user_registration(self):
        """تست ثبت‌نام کاربر"""
        response = self.client.post(self.register_url, self.user_data)
        
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertTrue(User.objects.filter(email=self.user_data['email']).exists())
        
        # بررسی ثبت لاگ
        self.assertTrue(
            AuditLog.objects.filter(
                action='create',
                resource_type='User'
            ).exists()
        )
    
    def test_user_login(self):
        """تست ورود کاربر"""
        # ایجاد کاربر
        user = User.objects.create_user(**self.user_data)
        user.is_verified = True
        user.save()
        
        # تست ورود
        login_data = {
            'email': self.user_data['email'],
            'password': self.user_data['password']
        }
        
        response = self.client.post(self.login_url, login_data)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('access', response.data)
        self.assertIn('refresh', response.data)
    
    def test_login_with_invalid_credentials(self):
        """تست ورود با اطلاعات نامعتبر"""
        login_data = {
            'email': 'wrong@email.com',
            'password': 'wrongpassword'
        }
        
        response = self.client.post(self.login_url, login_data)
        
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
    
    def test_token_refresh(self):
        """تست تازه‌سازی توکن"""
        # ایجاد کاربر و ورود
        user = User.objects.create_user(**self.user_data)
        user.is_verified = True
        user.save()
        
        login_response = self.client.post(self.login_url, {
            'email': self.user_data['email'],
            'password': self.user_data['password']
        })
        
        refresh_token = login_response.data['refresh']
        
        # تست تازه‌سازی
        refresh_response = self.client.post(self.refresh_url, {
            'refresh': refresh_token
        })
        
        self.assertEqual(refresh_response.status_code, status.HTTP_200_OK)
        self.assertIn('access', refresh_response.data)
    
    @patch('apps.authentication.utils.send_sms')
    def test_otp_verification(self, mock_send_sms):
        """تست تایید OTP"""
        mock_send_sms.return_value = True
        
        # درخواست OTP
        otp_request_url = reverse('authentication:request_otp')
        response = self.client.post(otp_request_url, {
            'phone_number': '09123456789'
        })
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_sms.assert_called_once()
    
    def test_rate_limiting(self):
        """تست محدودیت نرخ درخواست"""
        # ارسال درخواست‌های متعدد
        for _ in range(6):  # بیش از حد مجاز
            response = self.client.post(self.login_url, {
                'email': 'test@test.com',
                'password': 'wrongpass'
            })
        
        # آخرین درخواست باید محدود شود
        self.assertEqual(response.status_code, status.HTTP_429_TOO_MANY_REQUESTS)


class LocationPermissionTest(APITestCase):
    """تست مجوزهای مکانی"""
    
    def setUp(self):
        self.client = APIClient()
        
        # ایجاد کاربران
        self.admin_user = User.objects.create_user(
            email='admin@municipality.ir',
            password='AdminPass123!',
            is_superuser=True
        )
        
        self.regular_user = User.objects.create_user(
            email='user@municipality.ir',
            password='UserPass123!'
        )
        
        # ایجاد مکان‌ها
        self.city = LocationHierarchy.objects.create(
            name='تهران',
            code='THR',
            type='city',
            level=1
        )
        
        self.district = LocationHierarchy.objects.create(
            name='منطقه ۱',
            code='D01',
            type='district',
            level=2,
            parent=self.city
        )
        
        # تخصیص دسترسی
        UserLocationAccess.objects.create(
            user=self.regular_user,
            location=self.district,
            can_read=True,
            can_write=False,
            granted_by=self.admin_user
        )
    
    def test_admin_access_all_locations(self):
        """تست دسترسی ادمین به همه مکان‌ها"""
        self.client.force_authenticate(user=self.admin_user)
        
        url = reverse('locations:location-list')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 2)
    
    def test_user_access_permitted_locations_only(self):
        """تست دسترسی کاربر فقط به مکان‌های مجاز"""
        self.client.force_authenticate(user=self.regular_user)
        
        url = reverse('locations:location-list')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['name'], 'منطقه ۱')
    
    def test_user_cannot_write_without_permission(self):
        """تست عدم امکان نوشتن بدون مجوز"""
        self.client.force_authenticate(user=self.regular_user)
        
        url = reverse('locations:location-detail', kwargs={'pk': self.district.id})
        response = self.client.patch(url, {'name': 'منطقه جدید'})
        
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
    
    def test_inherited_permissions(self):
        """تست مجوزهای ارثی"""
        # تخصیص دسترسی به شهر با ارث‌بری
        UserLocationAccess.objects.create(
            user=self.regular_user,
            location=self.city,
            can_read=True,
            can_write=True,
            inherit_to_children=True,
            granted_by=self.admin_user
        )
        
        self.client.force_authenticate(user=self.regular_user)
        
        # باید بتواند منطقه را ویرایش کند
        url = reverse('locations:location-detail', kwargs={'pk': self.district.id})
        response = self.client.patch(url, {'name': 'منطقه ویرایش شده'})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)


class SecurityTest(TransactionTestCase):
    """تست‌های امنیتی"""
    
    def setUp(self):
        self.client = APIClient()
       self.user = User.objects.create_user(
            email='test@municipality.ir',
            password='TestPass123!',
            is_verified=True
        )
    
    def test_sql_injection_protection(self):
        """تست محافظت در برابر SQL Injection"""
        self.client.force_authenticate(user=self.user)
        
        # تلاش برای SQL Injection
        malicious_data = {
            'name': "'; DROP TABLE auth_user; --",
            'code': 'TEST'
        }
        
        url = reverse('locations:location-list')
        response = self.client.post(url, malicious_data)
        
        # باید خطای اعتبارسنجی برگردد، نه خطای پایگاه داده
        self.assertIn(response.status_code, [400, 403])
        
        # بررسی که جدول هنوز موجود است
        self.assertTrue(User.objects.filter(id=self.user.id).exists())
    
    def test_xss_protection(self):
        """تست محافظت در برابر XSS"""
        self.client.force_authenticate(user=self.user)
        
        # تلاش برای XSS
        malicious_data = {
            'name': '<script>alert("XSS")</script>',
            'code': 'TEST'
        }
        
        url = reverse('locations:location-list')
        response = self.client.post(url, malicious_data)
        
        if response.status_code == 201:
            # اگر ایجاد شد، باید محتوا escape شده باشد
            location_id = response.data['id']
            location_url = reverse('locations:location-detail', kwargs={'pk': location_id})
            get_response = self.client.get(location_url)
            
            self.assertNotIn('<script>', str(get_response.data))
    
    def test_csrf_protection(self):
        """تست محافظت در برابر CSRF"""
        # درخواست بدون CSRF token
        client = APIClient(enforce_csrf_checks=True)
        
        response = client.post('/api/v1/auth/login/', {
            'email': 'test@test.com',
            'password': '[REDACTED]'
        })
        
        # باید خطای CSRF برگردد (در صورت فعال بودن)
        self.assertIn(response.status_code, [403, 401])
    
    def test_brute_force_protection(self):
        """تست محافظت در برابر حمله Brute Force"""
        # تلاش‌های متعدد ورود با رمز اشتباه
        for i in range(6):
            response = self.client.post('/api/v1/auth/login/', {
                'email': self.user.email,
                'password': f'wrongpass{i}'
            })
        
        # بررسی که حساب قفل شده یا محدودیت اعمال شده
        self.assertIn(response.status_code, [429, 423])
        
        # بررسی ثبت هشدار امنیتی
        self.assertTrue(
            SecurityAlert.objects.filter(
                alert_type='multiple_failed_logins'
            ).exists()
        )
    
    @patch('apps.authentication.utils.get_client_location')
    def test_geo_location_restriction(self, mock_geo):
        """تست محدودیت جغرافیایی"""
        # شبیه‌سازی موقعیت غیرمجاز
        mock_geo.return_value = {
            'country': 'China',
            'city': 'Beijing'
        }
        
        # تنظیم محدودیت جغرافیایی برای کاربر
        self.user.allowed_countries = ['Iran']
        self.user.save()
        
        self.client.force_authenticate(user=self.user)
        
        response = self.client.get('/api/v1/locations/')
        
        # باید دسترسی محدود شود
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
    
    def test_sensitive_data_masking(self):
        """تست پوشاندن داده‌های حساس در لاگ‌ها"""
        # ورود با رمز عبور
        response = self.client.post('/api/v1/auth/login/', {
            'email': self.user.email,
            'password': 'TestPass123!'
        })
        
        # بررسی که رمز عبور در لاگ‌ها ذخیره نشده
        audit_logs = AuditLog.objects.filter(
            user=self.user,
            action='login'
        )
        
        for log in audit_logs:
            self.assertNotIn('TestPass123!', str(log.details))
            self.assertNotIn('password', str(log.details))


class PerformanceTest(APITestCase):
    """تست‌های عملکرد"""
    
    def setUp(self):
        self.client = APIClient()
        
        # ایجاد کاربر تست
        self.user = User.objects.create_user(
            email='perf@municipality.ir',
            password='[REDACTED]',
            is_verified=True
        )
        
        # ایجاد داده‌های تست
        self.create_test_data()
    
    def create_test_data(self):
        """ایجاد داده‌های تست برای بررسی عملکرد"""
        # ایجاد 1000 مکان
        locations = []
        for i in range(1000):
            locations.append(LocationHierarchy(
                name=f'مکان {i}',
                code=f'LOC{i:04d}',
                type='building',
                level=3
            ))
        
        LocationHierarchy.objects.bulk_create(locations)
        
        # ایجاد 100 کاربر
        users = []
        for i in range(100):
            users.append(User(
                email=f'user{i}@municipality.ir',
                first_name=f'کاربر{i}',
                last_name='تست'
            ))
        
        User.objects.bulk_create(users)
    
    def test_location_list_performance(self):
        """تست عملکرد لیست مکان‌ها"""
        self.client.force_authenticate(user=self.user)
        
        import time
        start_time = time.time()
        
        response = self.client.get('/api/v1/locations/')
        
        end_time = time.time()
        response_time = end_time - start_time
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertLess(response_time, 1.0)  # کمتر از 1 ثانیه
    
    def test_pagination_performance(self):
        """تست عملکرد صفحه‌بندی"""
        self.client.force_authenticate(user=self.user)
        
        # تست صفحات مختلف
        for page in [1, 5, 10]:
            start_time = time.time()
            
            response = self.client.get(f'/api/v1/locations/?page={page}')
            
            end_time = time.time()
            response_time = end_time - start_time
            
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertLess(response_time, 0.5)  # کمتر از نیم ثانیه
    
    def test_search_performance(self):
        """تست عملکرد جستجو"""
        self.client.force_authenticate(user=self.user)
        
        search_terms = ['مکان', 'LOC0001', 'تست']
        
        for term in search_terms:
            start_time = time.time()
            
            response = self.client.get(f'/api/v1/locations/?search={term}')
            
            end_time = time.time()
            response_time = end_time - start_time
            
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertLess(response_time, 0.8)  # کمتر از 0.8 ثانیه
    
    def test_concurrent_requests(self):
        """تست درخواست‌های همزمان"""
        import threading
        import time
        
        results = []
        
        def make_request():
            client = APIClient()
            client.force_authenticate(user=self.user)
            
            start_time = time.time()
            response = client.get('/api/v1/locations/')
            end_time = time.time()
            
            results.append({
                'status': response.status_code,
                'time': end_time - start_time
            })
        
        # ایجاد 10 thread همزمان
        threads = []
        for _ in range(10):
            thread = threading.Thread(target=make_request)
            threads.append(thread)
        
        # شروع همه thread ها
        start_time = time.time()
        for thread in threads:
            thread.start()
        
        # انتظار برای پایان همه thread ها
        for thread in threads:
            thread.join()
        
        total_time = time.time() - start_time
        
        # بررسی نتایج
        self.assertEqual(len(results), 10)
        for result in results:
            self.assertEqual(result['status'], 200)
            self.assertLess(result['time'], 2.0)
        
        self.assertLess(total_time, 5.0)  # کل فرآیند کمتر از 5 ثانیه


class IntegrationTest(TransactionTestCase):
    """تست‌های یکپارچگی"""
    
    def setUp(self):
        self.client = APIClient()
        
        # ایجاد ادمین
        self.admin = User.objects.create_user(
            email='admin@municipality.ir',
            password='AdminPass123!',
            is_superuser=True,
            is_verified=True
        )
        
        # ایجاد کاربر عادی
        self.user = User.objects.create_user(
            email='user@municipality.ir',
            password='[REDACTED]',
            is_verified=True
        )
    
    def test_complete_user_workflow(self):
        """تست گردش کار کامل کاربر"""
        # 1. ثبت‌نام
        register_data = {
            'email': 'newuser@municipality.ir',
            'password': 'NewPass123!',
            'first_name': 'کاربر',
            'last_name': 'جدید',
            'national_code': '0123456789',
            'phone_number': '09123456789'
        }
        
        response = self.client.post('/api/v1/auth/register/', register_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        # 2. فعال‌سازی حساب (شبیه‌سازی)
        new_user = User.objects.get(email=register_data['email'])
        new_user.is_verified = True
        new_user.save()
        
        # 3. ورود
        login_response = self.client.post('/api/v1/auth/login/', {
            'email': register_data['email'],
            'password': register_data['password']
        })
        self.assertEqual(login_response.status_code, status.HTTP_200_OK)
        
        # 4. دسترسی به API با توکن
        access_token = login_response.data['access']
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {access_token}')
        
        profile_response = self.client.get('/api/v1/auth/profile/')
        self.assertEqual(profile_response.status_code, status.HTTP_200_OK)
        
        # 5. بروزرسانی پروفایل
        update_response = self.client.patch('/api/v1/auth/profile/', {
            'first_name': 'کاربر بروزرسانی شده'
        })
        self.assertEqual(update_response.status_code, status.HTTP_200_OK)
        
        # 6. خروج
        logout_response = self.client.post('/api/v1/auth/logout/', {
            'refresh': login_response.data['refresh']
        })
        self.assertEqual(logout_response.status_code, status.HTTP_200_OK)
    
    def test_location_permission_workflow(self):
        """تست گردش کار مجوزهای مکانی"""
        self.client.force_authenticate(user=self.admin)
        
        # 1. ایجاد مکان توسط ادمین
        location_data = {
            'name': 'شهرداری منطقه ۱',
            'code': 'MUN01',
            'type': 'municipality',
            'level': 1
        }
        
        location_response = self.client.post('/api/v1/locations/', location_data)
        self.assertEqual(location_response.status_code, status.HTTP_201_CREATED)
        location_id = location_response.data['id']
        
        # 2. تخصیص دسترسی به کاربر
        access_data = {
            'user': self.user.id,
            'location': location_id,
            'can_read': True,
            'can_write': False,
            'can_delete': False
        }
        
        access_response = self.client.post('/api/v1/locations/access/', access_data)
        self.assertEqual(access_response.status_code, status.HTTP_201_CREATED)
        
        # 3. تست دسترسی کاربر
        self.client.force_authenticate(user=self.user)
        
        # خواندن - باید موفق باشد
        read_response = self.client.get(f'/api/v1/locations/{location_id}/')
        self.assertEqual(read_response.status_code, status.HTTP_200_OK)
        
        # نوشتن - باید ناموفق باشد
        write_response = self.client.patch(f'/api/v1/locations/{location_id}/', {
            'name': 'نام جدید'
        })
        self.assertEqual(write_response.status_code, status.HTTP_403_FORBIDDEN)
        
        # 4. بروزرسانی مجوز توسط ادمین
        self.client.force_authenticate(user=self.admin)
        
        access_id = access_response.data['id']
        update_access_response = self.client.patch(f'/api/v1/locations/access/{access_id}/', {
            'can_write': True
        })
        self.assertEqual(update_access_response.status_code, status.HTTP_200_OK)
        
        # 5. تست مجدد دسترسی کاربر
        self.client.force_authenticate(user=self.user)
        
        # نوشتن - حالا باید موفق باشد
        write_response2 = self.client.patch(f'/api/v1/locations/{location_id}/', {
            'name': 'نام بروزرسانی شده'
        })
        self.assertEqual(write_response2.status_code, status.HTTP_200_OK)
    
    def test_audit_logging_integration(self):
        """تست یکپارچگی سیستم لاگ"""
        self.client.force_authenticate(user=self.user)
        
        # انجام عملیات مختلف
        operations = [
            ('GET', '/api/v1/auth/profile/'),
            ('PATCH', '/api/v1/auth/profile/', {'first_name': 'نام جدید'}),
            ('GET', '/api/v1/locations/'),
        ]
        
        for method, url, data in operations:
            if method == 'GET':
                response = self.client.get(url)
            elif method == 'PATCH':
                response = self.client.patch(url, data or {})
            
            # بررسی که لاگ ثبت شده
            audit_log = AuditLog.objects.filter(
                user=self.user,
                request_path=url,
                request_method=method
            ).first()
            
            self.assertIsNotNone(audit_log)
            self.assertEqual(audit_log.response_status, response.status_code)


@pytest.mark.django_db
class APIDocumentationTest:
    """تست مستندات API"""
    
    def test_schema_generation(self, client):
        """تست تولید schema"""
        response = client.get('/api/schema/')
        assert response.status_code == 200
        
        schema = response.json()
        assert 'openapi' in schema
        assert 'paths' in schema
        assert 'components' in schema
    
    def test_swagger_ui_accessible(self, client):
        """تست دسترسی به Swagger UI"""
        response = client.get('/api/docs/')
        assert response.status_code == 200
        assert 'swagger' in response.content.decode().lower()
    
    def test_api_endpoints_documented(self, client):
        """تست مستندسازی endpoint ها"""
        response = client.get('/api/schema/')
        schema = response.json()
        
        required_endpoints = [
            '/api/v1/auth/login/',
            '/api/v1/auth/register/',
            '/api/v1/auth/profile/',
            '/api/v1/locations/',
            '/api/v1/audit/logs/'
        ]
        
        for endpoint in required_endpoints:
            assert endpoint in schema['paths']


class LoadTest(APITestCase):
    """تست بار"""
    
    def setUp(self):
        self.client = APIClient()
        self.user = User.objects.create_user(
            email='load@municipality.ir',
            password='[REDACTED]',
            is_verified=True
        )
    
    @pytest.mark.slow
    def test_high_load_authentication(self):
        """تست بار بالا برای احراز هویت"""
        import time
        import statistics
        
        response_times = []
        
        for i in range(100):  # 100 درخواست
            start_time = time.time()
            
            response = self.client.post('/api/v1/auth/login/', {
                'email': self.user.email,
                'password': '[REDACTED]'
            })
            
            end_time = time.time()
            response_times.append(end_time - start_time)
            
            self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # تحلیل عملکرد
        avg_time = statistics.mean(response_times)
        max_time = max(response_times)
        min_time = min(response_times)
        
        print(f"Authentication Load Test Results:")
        print(f"Average response time: {avg_time:.3f}s")
        print(f"Max response time: {max_time:.3f}s")
        print(f"Min response time: {min_time:.3f}s")
        
        # بررسی که میانگین زمان پاسخ قابل قبول باشد
        self.assertLess(avg_time, 0.5)  # کمتر از نیم ثانیه
        self.assertLess(max_time, 2.0)   # حداکثر 2 ثانیه
    
    @pytest.mark.slow
    def test_memory_usage_under_load(self):
        """تست استفاده از حافظه تحت بار"""
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss
        
        # انجام 500 درخواست
        self.client.force_authenticate(user=self.user)
        
        for i in range(500):
            response = self.client.get('/api/v1/locations/')
            self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        final_memory = process.memory_info().rss
        memory_increase = final_memory - initial_memory
        
        print(f"Memory usage increase: {memory_increase / 1024 / 1024:.2f} MB")
        
        # بررسی که افزایش حافظه معقول باشد (کمتر از 100 مگابایت)
        self.assertLess(memory_increase, 100 * 1024 * 1024)


# تنظیمات pytest
pytest_plugins = ['pytest_django']

def pytest_configure(config):
    """تنظیمات pytest"""
    import django
    from django.conf import settings
    
    if not settings.configured:
        settings.configure(
            DEBUG=True,
            DATABASES={
                'default': {
                    'ENGINE': 'django.contrib.gis.db.backends.postgis',
                    'NAME': ':memory:',
                }
            },
            INSTALLED_APPS=[
                'django.contrib.auth',
                'django.contrib.contenttypes',
                'django.contrib.gis',
                'rest_framework',
                'apps.authentication',
                'apps.locations',
                'apps.audit',
            ],
            SECRET_KEY='test-secret-key',
            USE_TZ=True,
        )
    
    django.setup()
</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">pytest.ini</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-ini">[tool:pytest]
DJANGO_SETTINGS_MODULE = config.settings.test
python_files = tests.py test_*.py *_tests.py
python_classes = Test* *Test *Tests
python_functions = test_*
addopts = 
    --verbose
    --tb=short
    --strict-markers
    --disable-warnings
    --cov=apps
    --cov-report=html
    --cov-report=term-missing
    --cov-fail-under=80
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
    unit: marks tests as unit tests
    security: marks tests as security tests
    performance: marks tests as performance tests
testpaths = tests
filterwarnings =
    ignore::django.utils.deprecation.RemovedInDjango40Warning
    ignore::django.utils.deprecation.RemovedInDjango41Warning
</code></pre>
                </div>
            </div>
        </div>

        <!-- مستندات -->
        <div class="section" id="documentation">
            <div class="section-header">
                <h2><span class="icon">📚</span>مستندات و راهنما</h2>
            </div>
            <div class="section-content">
                <div class="explanation">
                    <h4>مستندات کامل سیستم</h4>
                    <p>راهنمای جامع نصب، پیکربندی، استفاده و نگهداری سیستم احراز هویت مکانی.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="file-name">README.md</span>
                        <button class="copy-btn" onclick="copyCode(this)">کپی</button>
                    </div>
                    <pre><code class="language-markdown"># سیستم احراز هویت و کنترل دسترسی مکانی

## 🏛️ معرفی پروژه

سیستم احراز هویت و کنترل دسترسی مکانی یک راه‌حل جامع برای مدیریت کاربران و کنترل دسترسی‌ها بر اساس موقعیت جغرافیایی و سلسله مراتب سازمانی است. این سیستم به‌ویژه برای سازمان‌های بزرگ مانند شهرداری‌ها، بانک‌ها و مراکز درمانی طراحی شده است.

## ✨ ویژگی‌های کلیدی

### 🔐 احراز هویت پیشرفته
- احراز هویت چندمرحله‌ای (MFA)
- تایید دو مرحله‌ای با SMS/Email
- مدیریت نشست‌های امن
- پشتیبانی از JWT Token

### 🗺️ کنترل دسترسی مکانی
- سلسله مراتب مکانی قابل تنظیم
- مجوزهای ارثی
- کنترل دسترسی در سطح فیلد
- محدودیت جغرافیایی بر اساس IP

### 🛡️ امنیت پیشرفته
- محافظت در برابر حملات رایج (SQL Injection, XSS, CSRF)
- سیستم تشخیص نفوذ
- Rate Limiting هوشمند
- رمزگذاری داده‌های حساس

### 📊 نظارت و گزارش‌گیری
- ثبت کامل لاگ‌های امنیتی
- داشبورد مدیریتی
- هشدارهای امنیتی خودکار
- گزارش‌های عملکرد

## 🏗️ معماری سیستم
              
                          ‌
